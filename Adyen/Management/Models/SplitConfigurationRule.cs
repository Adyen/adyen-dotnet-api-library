// <auto-generated>
/*
 * Management API
 *
 * Configure and manage your Adyen company and merchant accounts, stores, and payment terminals. ## Authentication Each request to the Management API must be signed with an API key. [Generate your API key](https://docs.adyen.com/development-resources/api-credentials#generate-api-key) in the Customer Area and then set this key to the `X-API-Key` header value.  To access the live endpoints, you need to generate a new API key in your live Customer Area. ## Versioning  Management API handles versioning as part of the endpoint URL. For example, to send a request to this version of the `/companies/{companyId}/webhooks` endpoint, use:  ```text https://management-test.adyen.com/v3/companies/{companyId}/webhooks ```  ## Going live  To access the live endpoints, you need an API key from your live Customer Area. Use this API key to make requests to:  ```text https://management-live.adyen.com/v3 ```  ## Release notes Have a look at the [release notes](https://docs.adyen.com/release-notes/management-api) to find out what changed in this version!
 *
 * The version of the OpenAPI document: 3
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using Adyen.Core;
using Adyen.Management.Client;

namespace Adyen.Management.Models
{
    /// <summary>
    /// SplitConfigurationRule.
    /// </summary>
    public partial class SplitConfigurationRule : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SplitConfigurationRule" /> class.
        /// </summary>
        /// <param name="currency">The currency condition that defines whether the split logic applies. Its value must be a three-character [ISO currency code](https://en.wikipedia.org/wiki/ISO_4217).</param>
        /// <param name="fundingSource">The funding source of the payment method.  Possible values: * **credit** * **debit** * **prepaid** * **deferred_debit** * **charged** * **ANY**</param>
        /// <param name="paymentMethod">The payment method condition that defines whether the split logic applies.  Possible values: * [Payment method variant](https://docs.adyen.com/development-resources/paymentmethodvariant): Apply the split logic for a specific payment method. * **ANY**: Apply the split logic for all available payment methods.</param>
        /// <param name="shopperInteraction">The sales channel condition that defines whether the split logic applies.  Possible values: * **Ecommerce**: online transactions where the cardholder is present. * **ContAuth**: card on file and/or subscription transactions, where the cardholder is known to the merchant (returning customer). * **Moto**: mail-order and telephone-order transactions where the customer is in contact with the merchant via email or telephone. * **POS**: point-of-sale transactions where the customer is physically present to make a payment using a secure payment terminal. * **ANY**: all sales channels.</param>
        /// <param name="splitLogic">splitLogic</param>
        /// <param name="cardRegion">The card region condition that determines whether the [split logic](https://docs.adyen.com/api-explorer/Management/latest/post/merchants/(merchantId)/splitConfigurations#request-rules-splitLogic) applies to the transaction.  &gt; This condition is in pilot phase, and not yet available for all platforms.  Possible values: * **domestic**: The card issuer and the store where the transaction is processed are registered in the same country. * **international**: The card issuer and the store where the transaction is processed are registered in different countries or regions. Includes all **interRegional** and **intraRegional** transactions. * **interRegional**: The card issuer and the store where the transaction is processed are registered in different regions. * **intraRegional**: The card issuer and the store where the transaction is processed are registered in different countries, but in the same region. * **ANY**: Applies to all transactions, regardless of the processing and issuing country/region.</param>
        /// <param name="ruleId">The unique identifier of the split configuration rule.</param>
        [JsonConstructor]
        public SplitConfigurationRule(string currency, FundingSourceEnum fundingSource, string paymentMethod, ShopperInteractionEnum shopperInteraction, SplitConfigurationLogic splitLogic, Option<CardRegionEnum?> cardRegion = default, Option<string?> ruleId = default)
        {
            Currency = currency;
            FundingSource = fundingSource;
            PaymentMethod = paymentMethod;
            ShopperInteraction = shopperInteraction;
            SplitLogic = splitLogic;
            _CardRegionOption = cardRegion;
            _RuleIdOption = ruleId;
            OnCreated();
        }
        
        /// <summary>
        /// Best practice: Use the constructor to initialize your objects to understand which parameters are required/optional.
        /// </summary>
        public SplitConfigurationRule()
        {
        }

        partial void OnCreated();

        /// <summary>
        /// The funding source of the payment method.  Possible values: * **credit** * **debit** * **prepaid** * **deferred_debit** * **charged** * **ANY**
        /// </summary>
        /// <value>The funding source of the payment method.  Possible values: * **credit** * **debit** * **prepaid** * **deferred_debit** * **charged** * **ANY**</value>
        [JsonConverter(typeof(FundingSourceEnumJsonConverter))]
        public class FundingSourceEnum : IEnum
        {
            /// <summary>
            /// Returns the value of the FundingSourceEnum.
            /// </summary>
            public string? Value { get; set; }

            /// <summary>
            /// FundingSourceEnum.Charged - charged
            /// </summary>
            public static readonly FundingSourceEnum Charged = new("charged");

            /// <summary>
            /// FundingSourceEnum.Credit - credit
            /// </summary>
            public static readonly FundingSourceEnum Credit = new("credit");

            /// <summary>
            /// FundingSourceEnum.Debit - debit
            /// </summary>
            public static readonly FundingSourceEnum Debit = new("debit");

            /// <summary>
            /// FundingSourceEnum.DeferredDebit - deferred_debit
            /// </summary>
            public static readonly FundingSourceEnum DeferredDebit = new("deferred_debit");

            /// <summary>
            /// FundingSourceEnum.Prepaid - prepaid
            /// </summary>
            public static readonly FundingSourceEnum Prepaid = new("prepaid");

            /// <summary>
            /// FundingSourceEnum.ANY - ANY
            /// </summary>
            public static readonly FundingSourceEnum ANY = new("ANY");
        
            private FundingSourceEnum(string? value)
            {
                Value = value;
            }

            /// <summary>
            /// Converts a string to a <see cref="FundingSourceEnum"/> implicitly.
            /// </summary>
            /// <param name="value">The string value to convert. Defaults to null.</param>
            /// <returns>A new <see cref="FundingSourceEnum"/> instance initialized with the string value.</returns>
            public static implicit operator FundingSourceEnum?(string? value) => value == null ? null : new FundingSourceEnum(value);
    
            /// <summary>
            /// Converts a <see cref="FundingSourceEnum"/> instance to a string implicitly.
            /// </summary>
            /// <param name="option">The <see cref="FundingSourceEnum"/> instance. Default to null.</param>
            /// <returns>String value of the <see cref="FundingSourceEnum"/> instance./// </returns>
            public static implicit operator string?(FundingSourceEnum? option) => option?.Value;
        
            public static bool operator ==(FundingSourceEnum? left, FundingSourceEnum? right) => string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);
    
            public static bool operator !=(FundingSourceEnum? left, FundingSourceEnum? right) => !string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);

            public override bool Equals(object? obj) => obj is FundingSourceEnum other && string.Equals(Value, other.Value, StringComparison.OrdinalIgnoreCase);
    
            public override int GetHashCode() => Value?.GetHashCode() ?? 0;
        
            public override string ToString() => Value ?? string.Empty;
        
            /// <summary>
            /// Returns a <see cref="FundingSourceEnum?"/>.
            /// </summary>
            /// <param name="value"></param>
            /// <returns><see cref="FundingSourceEnum"/> or null.</returns>
            public static FundingSourceEnum? FromStringOrDefault(string value)
            {
                return value switch {
                    "charged" => FundingSourceEnum.Charged,
                    "credit" => FundingSourceEnum.Credit,
                    "debit" => FundingSourceEnum.Debit,
                    "deferred_debit" => FundingSourceEnum.DeferredDebit,
                    "prepaid" => FundingSourceEnum.Prepaid,
                    "ANY" => FundingSourceEnum.ANY,
                    _ => null,
                };
            }
    
            /// <summary>
            /// Converts the <see cref="FundingSourceEnum"/> to the json value.
            /// </summary>
            /// <param name="value"><see cref="FundingSourceEnum"/></param>
            /// <returns>String value of the enum.</returns>
            /// <exception cref="NotImplementedException"></exception>
            public static string? ToJsonValue(FundingSourceEnum? value)
            {
                if (value == null)
                    return null;
            
                if (value == FundingSourceEnum.Charged)
                    return "charged";
                
                if (value == FundingSourceEnum.Credit)
                    return "credit";
                
                if (value == FundingSourceEnum.Debit)
                    return "debit";
                
                if (value == FundingSourceEnum.DeferredDebit)
                    return "deferred_debit";
                
                if (value == FundingSourceEnum.Prepaid)
                    return "prepaid";
                
                if (value == FundingSourceEnum.ANY)
                    return "ANY";
                
                return null;
            }
            
            /// <summary>
            /// JsonConverter for writing FundingSourceEnum.               
            /// </summary>
            public class FundingSourceEnumJsonConverter : JsonConverter<FundingSourceEnum>
            {
                public override FundingSourceEnum? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions jsonOptions)
                {
                    string value = reader.GetString();
                    return value == null ? null : FundingSourceEnum.FromStringOrDefault(value) ?? new FundingSourceEnum(value);
                }

                public override void Write(Utf8JsonWriter writer, FundingSourceEnum value, JsonSerializerOptions jsonOptions)
                {
                    writer.WriteStringValue(FundingSourceEnum.ToJsonValue(value));
                }
            }
        }

        /// <summary>
        /// The funding source of the payment method.  Possible values: * **credit** * **debit** * **prepaid** * **deferred_debit** * **charged** * **ANY**
        /// </summary>
        /// <value>The funding source of the payment method.  Possible values: * **credit** * **debit** * **prepaid** * **deferred_debit** * **charged** * **ANY**</value>
        [JsonPropertyName("fundingSource")]
        public FundingSourceEnum FundingSource { get; set; }

        /// <summary>
        /// The sales channel condition that defines whether the split logic applies.  Possible values: * **Ecommerce**: online transactions where the cardholder is present. * **ContAuth**: card on file and/or subscription transactions, where the cardholder is known to the merchant (returning customer). * **Moto**: mail-order and telephone-order transactions where the customer is in contact with the merchant via email or telephone. * **POS**: point-of-sale transactions where the customer is physically present to make a payment using a secure payment terminal. * **ANY**: all sales channels.
        /// </summary>
        /// <value>The sales channel condition that defines whether the split logic applies.  Possible values: * **Ecommerce**: online transactions where the cardholder is present. * **ContAuth**: card on file and/or subscription transactions, where the cardholder is known to the merchant (returning customer). * **Moto**: mail-order and telephone-order transactions where the customer is in contact with the merchant via email or telephone. * **POS**: point-of-sale transactions where the customer is physically present to make a payment using a secure payment terminal. * **ANY**: all sales channels.</value>
        [JsonConverter(typeof(ShopperInteractionEnumJsonConverter))]
        public class ShopperInteractionEnum : IEnum
        {
            /// <summary>
            /// Returns the value of the ShopperInteractionEnum.
            /// </summary>
            public string? Value { get; set; }

            /// <summary>
            /// ShopperInteractionEnum.Ecommerce - Ecommerce
            /// </summary>
            public static readonly ShopperInteractionEnum Ecommerce = new("Ecommerce");

            /// <summary>
            /// ShopperInteractionEnum.ContAuth - ContAuth
            /// </summary>
            public static readonly ShopperInteractionEnum ContAuth = new("ContAuth");

            /// <summary>
            /// ShopperInteractionEnum.Moto - Moto
            /// </summary>
            public static readonly ShopperInteractionEnum Moto = new("Moto");

            /// <summary>
            /// ShopperInteractionEnum.POS - POS
            /// </summary>
            public static readonly ShopperInteractionEnum POS = new("POS");

            /// <summary>
            /// ShopperInteractionEnum.ANY - ANY
            /// </summary>
            public static readonly ShopperInteractionEnum ANY = new("ANY");
        
            private ShopperInteractionEnum(string? value)
            {
                Value = value;
            }

            /// <summary>
            /// Converts a string to a <see cref="ShopperInteractionEnum"/> implicitly.
            /// </summary>
            /// <param name="value">The string value to convert. Defaults to null.</param>
            /// <returns>A new <see cref="ShopperInteractionEnum"/> instance initialized with the string value.</returns>
            public static implicit operator ShopperInteractionEnum?(string? value) => value == null ? null : new ShopperInteractionEnum(value);
    
            /// <summary>
            /// Converts a <see cref="ShopperInteractionEnum"/> instance to a string implicitly.
            /// </summary>
            /// <param name="option">The <see cref="ShopperInteractionEnum"/> instance. Default to null.</param>
            /// <returns>String value of the <see cref="ShopperInteractionEnum"/> instance./// </returns>
            public static implicit operator string?(ShopperInteractionEnum? option) => option?.Value;
        
            public static bool operator ==(ShopperInteractionEnum? left, ShopperInteractionEnum? right) => string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);
    
            public static bool operator !=(ShopperInteractionEnum? left, ShopperInteractionEnum? right) => !string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);

            public override bool Equals(object? obj) => obj is ShopperInteractionEnum other && string.Equals(Value, other.Value, StringComparison.OrdinalIgnoreCase);
    
            public override int GetHashCode() => Value?.GetHashCode() ?? 0;
        
            public override string ToString() => Value ?? string.Empty;
        
            /// <summary>
            /// Returns a <see cref="ShopperInteractionEnum?"/>.
            /// </summary>
            /// <param name="value"></param>
            /// <returns><see cref="ShopperInteractionEnum"/> or null.</returns>
            public static ShopperInteractionEnum? FromStringOrDefault(string value)
            {
                return value switch {
                    "Ecommerce" => ShopperInteractionEnum.Ecommerce,
                    "ContAuth" => ShopperInteractionEnum.ContAuth,
                    "Moto" => ShopperInteractionEnum.Moto,
                    "POS" => ShopperInteractionEnum.POS,
                    "ANY" => ShopperInteractionEnum.ANY,
                    _ => null,
                };
            }
    
            /// <summary>
            /// Converts the <see cref="ShopperInteractionEnum"/> to the json value.
            /// </summary>
            /// <param name="value"><see cref="ShopperInteractionEnum"/></param>
            /// <returns>String value of the enum.</returns>
            /// <exception cref="NotImplementedException"></exception>
            public static string? ToJsonValue(ShopperInteractionEnum? value)
            {
                if (value == null)
                    return null;
            
                if (value == ShopperInteractionEnum.Ecommerce)
                    return "Ecommerce";
                
                if (value == ShopperInteractionEnum.ContAuth)
                    return "ContAuth";
                
                if (value == ShopperInteractionEnum.Moto)
                    return "Moto";
                
                if (value == ShopperInteractionEnum.POS)
                    return "POS";
                
                if (value == ShopperInteractionEnum.ANY)
                    return "ANY";
                
                return null;
            }
            
            /// <summary>
            /// JsonConverter for writing ShopperInteractionEnum.               
            /// </summary>
            public class ShopperInteractionEnumJsonConverter : JsonConverter<ShopperInteractionEnum>
            {
                public override ShopperInteractionEnum? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions jsonOptions)
                {
                    string value = reader.GetString();
                    return value == null ? null : ShopperInteractionEnum.FromStringOrDefault(value) ?? new ShopperInteractionEnum(value);
                }

                public override void Write(Utf8JsonWriter writer, ShopperInteractionEnum value, JsonSerializerOptions jsonOptions)
                {
                    writer.WriteStringValue(ShopperInteractionEnum.ToJsonValue(value));
                }
            }
        }

        /// <summary>
        /// The sales channel condition that defines whether the split logic applies.  Possible values: * **Ecommerce**: online transactions where the cardholder is present. * **ContAuth**: card on file and/or subscription transactions, where the cardholder is known to the merchant (returning customer). * **Moto**: mail-order and telephone-order transactions where the customer is in contact with the merchant via email or telephone. * **POS**: point-of-sale transactions where the customer is physically present to make a payment using a secure payment terminal. * **ANY**: all sales channels.
        /// </summary>
        /// <value>The sales channel condition that defines whether the split logic applies.  Possible values: * **Ecommerce**: online transactions where the cardholder is present. * **ContAuth**: card on file and/or subscription transactions, where the cardholder is known to the merchant (returning customer). * **Moto**: mail-order and telephone-order transactions where the customer is in contact with the merchant via email or telephone. * **POS**: point-of-sale transactions where the customer is physically present to make a payment using a secure payment terminal. * **ANY**: all sales channels.</value>
        [JsonPropertyName("shopperInteraction")]
        public ShopperInteractionEnum ShopperInteraction { get; set; }

        /// <summary>
        /// The card region condition that determines whether the [split logic](https://docs.adyen.com/api-explorer/Management/latest/post/merchants/(merchantId)/splitConfigurations#request-rules-splitLogic) applies to the transaction.  > This condition is in pilot phase, and not yet available for all platforms.  Possible values: * **domestic**: The card issuer and the store where the transaction is processed are registered in the same country. * **international**: The card issuer and the store where the transaction is processed are registered in different countries or regions. Includes all **interRegional** and **intraRegional** transactions. * **interRegional**: The card issuer and the store where the transaction is processed are registered in different regions. * **intraRegional**: The card issuer and the store where the transaction is processed are registered in different countries, but in the same region. * **ANY**: Applies to all transactions, regardless of the processing and issuing country/region.
        /// </summary>
        /// <value>The card region condition that determines whether the [split logic](https://docs.adyen.com/api-explorer/Management/latest/post/merchants/(merchantId)/splitConfigurations#request-rules-splitLogic) applies to the transaction.  &gt; This condition is in pilot phase, and not yet available for all platforms.  Possible values: * **domestic**: The card issuer and the store where the transaction is processed are registered in the same country. * **international**: The card issuer and the store where the transaction is processed are registered in different countries or regions. Includes all **interRegional** and **intraRegional** transactions. * **interRegional**: The card issuer and the store where the transaction is processed are registered in different regions. * **intraRegional**: The card issuer and the store where the transaction is processed are registered in different countries, but in the same region. * **ANY**: Applies to all transactions, regardless of the processing and issuing country/region.</value>
        [JsonConverter(typeof(CardRegionEnumJsonConverter))]
        public class CardRegionEnum : IEnum
        {
            /// <summary>
            /// Returns the value of the CardRegionEnum.
            /// </summary>
            public string? Value { get; set; }

            /// <summary>
            /// CardRegionEnum.International - international
            /// </summary>
            public static readonly CardRegionEnum International = new("international");

            /// <summary>
            /// CardRegionEnum.IntraRegional - intraRegional
            /// </summary>
            public static readonly CardRegionEnum IntraRegional = new("intraRegional");

            /// <summary>
            /// CardRegionEnum.InterRegional - interRegional
            /// </summary>
            public static readonly CardRegionEnum InterRegional = new("interRegional");

            /// <summary>
            /// CardRegionEnum.Domestic - domestic
            /// </summary>
            public static readonly CardRegionEnum Domestic = new("domestic");

            /// <summary>
            /// CardRegionEnum.ANY - ANY
            /// </summary>
            public static readonly CardRegionEnum ANY = new("ANY");
        
            private CardRegionEnum(string? value)
            {
                Value = value;
            }

            /// <summary>
            /// Converts a string to a <see cref="CardRegionEnum"/> implicitly.
            /// </summary>
            /// <param name="value">The string value to convert. Defaults to null.</param>
            /// <returns>A new <see cref="CardRegionEnum"/> instance initialized with the string value.</returns>
            public static implicit operator CardRegionEnum?(string? value) => value == null ? null : new CardRegionEnum(value);
    
            /// <summary>
            /// Converts a <see cref="CardRegionEnum"/> instance to a string implicitly.
            /// </summary>
            /// <param name="option">The <see cref="CardRegionEnum"/> instance. Default to null.</param>
            /// <returns>String value of the <see cref="CardRegionEnum"/> instance./// </returns>
            public static implicit operator string?(CardRegionEnum? option) => option?.Value;
        
            public static bool operator ==(CardRegionEnum? left, CardRegionEnum? right) => string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);
    
            public static bool operator !=(CardRegionEnum? left, CardRegionEnum? right) => !string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);

            public override bool Equals(object? obj) => obj is CardRegionEnum other && string.Equals(Value, other.Value, StringComparison.OrdinalIgnoreCase);
    
            public override int GetHashCode() => Value?.GetHashCode() ?? 0;
        
            public override string ToString() => Value ?? string.Empty;
        
            /// <summary>
            /// Returns a <see cref="CardRegionEnum?"/>.
            /// </summary>
            /// <param name="value"></param>
            /// <returns><see cref="CardRegionEnum"/> or null.</returns>
            public static CardRegionEnum? FromStringOrDefault(string value)
            {
                return value switch {
                    "international" => CardRegionEnum.International,
                    "intraRegional" => CardRegionEnum.IntraRegional,
                    "interRegional" => CardRegionEnum.InterRegional,
                    "domestic" => CardRegionEnum.Domestic,
                    "ANY" => CardRegionEnum.ANY,
                    _ => null,
                };
            }
    
            /// <summary>
            /// Converts the <see cref="CardRegionEnum"/> to the json value.
            /// </summary>
            /// <param name="value"><see cref="CardRegionEnum"/></param>
            /// <returns>String value of the enum.</returns>
            /// <exception cref="NotImplementedException"></exception>
            public static string? ToJsonValue(CardRegionEnum? value)
            {
                if (value == null)
                    return null;
            
                if (value == CardRegionEnum.International)
                    return "international";
                
                if (value == CardRegionEnum.IntraRegional)
                    return "intraRegional";
                
                if (value == CardRegionEnum.InterRegional)
                    return "interRegional";
                
                if (value == CardRegionEnum.Domestic)
                    return "domestic";
                
                if (value == CardRegionEnum.ANY)
                    return "ANY";
                
                return null;
            }
            
            /// <summary>
            /// JsonConverter for writing CardRegionEnum.               
            /// </summary>
            public class CardRegionEnumJsonConverter : JsonConverter<CardRegionEnum>
            {
                public override CardRegionEnum? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions jsonOptions)
                {
                    string value = reader.GetString();
                    return value == null ? null : CardRegionEnum.FromStringOrDefault(value) ?? new CardRegionEnum(value);
                }

                public override void Write(Utf8JsonWriter writer, CardRegionEnum value, JsonSerializerOptions jsonOptions)
                {
                    writer.WriteStringValue(CardRegionEnum.ToJsonValue(value));
                }
            }
        }

        /// <summary>
        /// This is used to track if an optional field is set. If set, <see cref="CardRegion"/> will be populated.
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<CardRegionEnum?> _CardRegionOption { get; private set; }

        /// <summary>
        /// The card region condition that determines whether the [split logic](https://docs.adyen.com/api-explorer/Management/latest/post/merchants/(merchantId)/splitConfigurations#request-rules-splitLogic) applies to the transaction.  > This condition is in pilot phase, and not yet available for all platforms.  Possible values: * **domestic**: The card issuer and the store where the transaction is processed are registered in the same country. * **international**: The card issuer and the store where the transaction is processed are registered in different countries or regions. Includes all **interRegional** and **intraRegional** transactions. * **interRegional**: The card issuer and the store where the transaction is processed are registered in different regions. * **intraRegional**: The card issuer and the store where the transaction is processed are registered in different countries, but in the same region. * **ANY**: Applies to all transactions, regardless of the processing and issuing country/region.
        /// </summary>
        /// <value>The card region condition that determines whether the [split logic](https://docs.adyen.com/api-explorer/Management/latest/post/merchants/(merchantId)/splitConfigurations#request-rules-splitLogic) applies to the transaction.  &gt; This condition is in pilot phase, and not yet available for all platforms.  Possible values: * **domestic**: The card issuer and the store where the transaction is processed are registered in the same country. * **international**: The card issuer and the store where the transaction is processed are registered in different countries or regions. Includes all **interRegional** and **intraRegional** transactions. * **interRegional**: The card issuer and the store where the transaction is processed are registered in different regions. * **intraRegional**: The card issuer and the store where the transaction is processed are registered in different countries, but in the same region. * **ANY**: Applies to all transactions, regardless of the processing and issuing country/region.</value>
        [JsonPropertyName("cardRegion")]
        public CardRegionEnum? CardRegion { get { return this._CardRegionOption; } set { this._CardRegionOption = new(value); } }

        /// <summary>
        /// The currency condition that defines whether the split logic applies. Its value must be a three-character [ISO currency code](https://en.wikipedia.org/wiki/ISO_4217).
        /// </summary>
        /// <value>The currency condition that defines whether the split logic applies. Its value must be a three-character [ISO currency code](https://en.wikipedia.org/wiki/ISO_4217).</value>
        [JsonPropertyName("currency")]
        public string Currency { get; set; }

        /// <summary>
        /// The payment method condition that defines whether the split logic applies.  Possible values: * [Payment method variant](https://docs.adyen.com/development-resources/paymentmethodvariant): Apply the split logic for a specific payment method. * **ANY**: Apply the split logic for all available payment methods.
        /// </summary>
        /// <value>The payment method condition that defines whether the split logic applies.  Possible values: * [Payment method variant](https://docs.adyen.com/development-resources/paymentmethodvariant): Apply the split logic for a specific payment method. * **ANY**: Apply the split logic for all available payment methods.</value>
        [JsonPropertyName("paymentMethod")]
        public string PaymentMethod { get; set; }

        /// <summary>
        /// <see cref="SplitLogic"/>.
        /// </summary>
        [JsonPropertyName("splitLogic")]
        public SplitConfigurationLogic SplitLogic { get; set; }

        /// <summary>
        /// This is used to track if an optional field is set. If set, <see cref="RuleId"/> will be populated.
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> _RuleIdOption { get; }

        /// <summary>
        /// The unique identifier of the split configuration rule.
        /// </summary>
        /// <value>The unique identifier of the split configuration rule.</value>
        [JsonPropertyName("ruleId")]
        public string? RuleId { get { return this._RuleIdOption; } }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class SplitConfigurationRule {\n");
            sb.Append("  Currency: ").Append(Currency).Append("\n");
            sb.Append("  FundingSource: ").Append(FundingSource).Append("\n");
            sb.Append("  PaymentMethod: ").Append(PaymentMethod).Append("\n");
            sb.Append("  ShopperInteraction: ").Append(ShopperInteraction).Append("\n");
            sb.Append("  SplitLogic: ").Append(SplitLogic).Append("\n");
            sb.Append("  CardRegion: ").Append(CardRegion).Append("\n");
            sb.Append("  RuleId: ").Append(RuleId).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="SplitConfigurationRule" />
    /// </summary>
    public class SplitConfigurationRuleJsonConverter : JsonConverter<SplitConfigurationRule>
    {
        /// <summary>
        /// Deserializes json to <see cref="SplitConfigurationRule"/>.
        /// </summary>
        /// <param name="utf8JsonReader"><see cref="Utf8JsonReader"/>.</param>
        /// <param name="typeToConvert"><see cref="Type"/>.</param>
        /// <param name="jsonSerializerOptions">The <see cref="JsonSerializerOptions"/>, initialized from <see cref="HostConfiguration"/>.</param>
        /// <returns><see cref="SplitConfigurationRule"/>.</returns>
        /// <exception cref="JsonException"></exception>
        public override SplitConfigurationRule Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<string?> currency = default;
            Option<SplitConfigurationRule.FundingSourceEnum?> fundingSource = default;
            Option<string?> paymentMethod = default;
            Option<SplitConfigurationRule.ShopperInteractionEnum?> shopperInteraction = default;
            Option<SplitConfigurationLogic?> splitLogic = default;
            Option<SplitConfigurationRule.CardRegionEnum?> cardRegion = default;
            Option<string?> ruleId = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? jsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (jsonPropertyName)
                    {
                        case "currency":
                            currency = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "fundingSource":
                            string? fundingSourceRawValue = utf8JsonReader.GetString();
                            fundingSource = new Option<SplitConfigurationRule.FundingSourceEnum?>(SplitConfigurationRule.FundingSourceEnum.FromStringOrDefault(fundingSourceRawValue));
                            break;
                        case "paymentMethod":
                            paymentMethod = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "shopperInteraction":
                            string? shopperInteractionRawValue = utf8JsonReader.GetString();
                            shopperInteraction = new Option<SplitConfigurationRule.ShopperInteractionEnum?>(SplitConfigurationRule.ShopperInteractionEnum.FromStringOrDefault(shopperInteractionRawValue));
                            break;
                        case "splitLogic":
                            splitLogic = new Option<SplitConfigurationLogic?>(JsonSerializer.Deserialize<SplitConfigurationLogic>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "cardRegion":
                            string? cardRegionRawValue = utf8JsonReader.GetString();
                            cardRegion = new Option<SplitConfigurationRule.CardRegionEnum?>(SplitConfigurationRule.CardRegionEnum.FromStringOrDefault(cardRegionRawValue));
                            break;
                        case "ruleId":
                            ruleId = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        default:
                            break;
                    }
                }
            }
            
            if (!currency.IsSet)
                throw new ArgumentException("Property is required for class SplitConfigurationRule.", nameof(currency));

            if (!fundingSource.IsSet)
                throw new ArgumentException("Property is required for class SplitConfigurationRule.", nameof(fundingSource));

            if (!paymentMethod.IsSet)
                throw new ArgumentException("Property is required for class SplitConfigurationRule.", nameof(paymentMethod));

            if (!shopperInteraction.IsSet)
                throw new ArgumentException("Property is required for class SplitConfigurationRule.", nameof(shopperInteraction));

            if (!splitLogic.IsSet)
                throw new ArgumentException("Property is required for class SplitConfigurationRule.", nameof(splitLogic));

            return new SplitConfigurationRule(currency.Value!, fundingSource.Value!.Value!, paymentMethod.Value!, shopperInteraction.Value!.Value!, splitLogic.Value!, cardRegion, ruleId);
        }

        /// <summary>
        /// Serializes a <see cref="SplitConfigurationRule"/>.
        /// </summary>
        /// <param name="writer"><see cref="Utf8JsonWriter"/></param>
        /// <param name="splitConfigurationRule"></param>
        /// <param name="jsonSerializerOptions"><see cref="JsonSerializerOptions"/></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, SplitConfigurationRule splitConfigurationRule, JsonSerializerOptions jsonSerializerOptions)
        {
            
            writer.WriteStartObject();
            
            WriteProperties(writer, splitConfigurationRule, jsonSerializerOptions);
            
            writer.WriteEndObject();
            
        }

        /// <summary>
        /// Serializes the properties of <see cref="SplitConfigurationRule"/>.
        /// </summary>
        /// <param name="writer"><see creft="Utf8JsonWriter"/></param>
        /// <param name="splitConfigurationRule"></param>
        /// <param name="jsonSerializerOptions"><see cref="JsonSerializerOptions"/></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, SplitConfigurationRule splitConfigurationRule, JsonSerializerOptions jsonSerializerOptions)
        {
            
            if (splitConfigurationRule.Currency != null)
                writer.WriteString("currency", splitConfigurationRule.Currency);

            if (splitConfigurationRule.FundingSource != null) 
            {
                string? fundingSourceRawValue = SplitConfigurationRule.FundingSourceEnum.ToJsonValue(splitConfigurationRule.FundingSource);
                writer.WriteString("fundingSource", fundingSourceRawValue);
            }
            
            if (splitConfigurationRule.PaymentMethod != null)
                writer.WriteString("paymentMethod", splitConfigurationRule.PaymentMethod);

            if (splitConfigurationRule.ShopperInteraction != null) 
            {
                string? shopperInteractionRawValue = SplitConfigurationRule.ShopperInteractionEnum.ToJsonValue(splitConfigurationRule.ShopperInteraction);
                writer.WriteString("shopperInteraction", shopperInteractionRawValue);
            }
            
            writer.WritePropertyName("splitLogic");
            JsonSerializer.Serialize(writer, splitConfigurationRule.SplitLogic, jsonSerializerOptions);
            if (splitConfigurationRule._CardRegionOption.IsSet && splitConfigurationRule.CardRegion != null) 
            {
                string? cardRegionRawValue = SplitConfigurationRule.CardRegionEnum.ToJsonValue(splitConfigurationRule._CardRegionOption.Value!.Value);
                writer.WriteString("cardRegion", cardRegionRawValue);
            }
            
            if (splitConfigurationRule._RuleIdOption.IsSet)
                if (splitConfigurationRule.RuleId != null)
                    writer.WriteString("ruleId", splitConfigurationRule.RuleId);
        }
    }
}
