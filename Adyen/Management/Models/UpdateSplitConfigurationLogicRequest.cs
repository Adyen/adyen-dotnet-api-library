// <auto-generated>
/*
 * Management API
 *
 * Configure and manage your Adyen company and merchant accounts, stores, and payment terminals. ## Authentication Each request to the Management API must be signed with an API key. [Generate your API key](https://docs.adyen.com/development-resources/api-credentials#generate-api-key) in the Customer Area and then set this key to the `X-API-Key` header value.  To access the live endpoints, you need to generate a new API key in your live Customer Area. ## Versioning  Management API handles versioning as part of the endpoint URL. For example, to send a request to this version of the `/companies/{companyId}/webhooks` endpoint, use:  ```text https://management-test.adyen.com/v3/companies/{companyId}/webhooks ```  ## Going live  To access the live endpoints, you need an API key from your live Customer Area. Use this API key to make requests to:  ```text https://management-live.adyen.com/v3 ```  ## Release notes Have a look at the [release notes](https://docs.adyen.com/release-notes/management-api) to find out what changed in this version!
 *
 * The version of the OpenAPI document: 3
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using Adyen.Core;
using Adyen.Management.Client;

namespace Adyen.Management.Models
{
    /// <summary>
    /// UpdateSplitConfigurationLogicRequest.
    /// </summary>
    public partial class UpdateSplitConfigurationLogicRequest : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="UpdateSplitConfigurationLogicRequest" /> class.
        /// </summary>
        /// <param name="commission">commission</param>
        /// <param name="acquiringFees">Deducts the acquiring fees (the aggregated amount of interchange and scheme fee) from the specified balance account.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.</param>
        /// <param name="additionalCommission">additionalCommission</param>
        /// <param name="adyenCommission">Deducts the transaction fee due to Adyen under [blended rates](https://www.adyen.com/knowledge-hub/guides/payments-training-guide/get-the-best-from-your-card-processing) from the specified balance account.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.</param>
        /// <param name="adyenFees">Deducts the fees due to Adyen (markup or commission) from the specified balance account.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.</param>
        /// <param name="adyenMarkup">Deducts the transaction fee due to Adyen under [Interchange ++ pricing](https://www.adyen.com/what-is-interchange) from the specified balance account.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.</param>
        /// <param name="chargeback">Specifies how and from which balance account(s) to deduct the chargeback amount.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**, **deductAccordingToSplitRatio**.</param>
        /// <param name="chargebackCostAllocation">Deducts the chargeback costs from the specified balance account.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**</param>
        /// <param name="interchange">Deducts the interchange fee from specified balance account.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.</param>
        /// <param name="paymentFee">Deducts all transaction fees incurred by the payment from the specified balance account. The transaction fees include the acquiring fees (interchange and scheme fee), and the fees due to Adyen (markup or commission). You can book any and all these fees to different balance account by specifying other transaction fee parameters in your split configuration profile:  - [&#x60;adyenCommission&#x60;](https://docs.adyen.com/api-explorer/Management/latest/post/merchants/(merchantId)/splitConfigurations#request-rules-splitLogic-adyenCommission): The transaction fee due to Adyen under [blended rates](https://www.adyen.com/knowledge-hub/interchange-fees-explained#interchange-vs-blended). - [&#x60;adyenMarkup&#x60;](https://docs.adyen.com/api-explorer/Management/latest/post/merchants/(merchantId)/splitConfigurations#request-rules-splitLogic-adyenMarkup): The transaction fee due to Adyen under [Interchange ++ pricing](https://www.adyen.com/knowledge-hub/interchange-fees-explained#interchange-vs-blended). - [&#x60;schemeFee&#x60;](https://docs.adyen.com/api-explorer/Management/latest/post/merchants/(merchantId)/splitConfigurations#request-rules-splitLogic-schemeFee): The fee paid to the card scheme for using their network. - [&#x60;interchange&#x60;](https://docs.adyen.com/api-explorer/Management/latest/post/merchants/(merchantId)/splitConfigurations#request-rules-splitLogic-interchange): The fee paid to the issuer for each payment transaction made with the card network. - [&#x60;adyenFees&#x60;](https://docs.adyen.com/api-explorer/Management/latest/post/merchants/(merchantId)/splitConfigurations#request-rules-splitLogic-adyenFees): The aggregated amount of Adyen&#39;s commission and markup. - [&#x60;acquiringFees&#x60;](https://docs.adyen.com/api-explorer/Management/latest/post/merchants/(merchantId)/splitConfigurations#request-rules-splitLogic-acquiringFees): The aggregated amount of the interchange and scheme fees.  If you don&#39;t include at least one transaction fee type in the &#x60;splitLogic&#x60; object, Adyen updates the payment request with the &#x60;paymentFee&#x60; parameter, booking all transaction fees to your platform&#39;s liable balance account.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.</param>
        /// <param name="refund">Specifies how and from which balance account(s) to deduct the refund amount.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**, **deductAccordingToSplitRatio**</param>
        /// <param name="refundCostAllocation">Deducts the refund costs from the specified balance account.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**</param>
        /// <param name="remainder">Books the amount left over after currency conversion to the specified balance account.  Possible values: **addToLiableAccount**, **addToOneBalanceAccount**.</param>
        /// <param name="schemeFee">Deducts the scheme fee from the specified balance account.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.</param>
        /// <param name="splitLogicId">Unique identifier of the collection of split instructions that are applied when the rule conditions are met.</param>
        /// <param name="surcharge">Books the surcharge amount to the specified balance account.  Possible values: **addToLiableAccount**, **addToOneBalanceAccount**</param>
        /// <param name="tip">Books the tips (gratuity) to the specified balance account.  Possible values: **addToLiableAccount**, **addToOneBalanceAccount**.</param>
        [JsonConstructor]
        public UpdateSplitConfigurationLogicRequest(Commission commission, Option<AcquiringFeesEnum?> acquiringFees = default, Option<AdditionalCommission?> additionalCommission = default, Option<AdyenCommissionEnum?> adyenCommission = default, Option<AdyenFeesEnum?> adyenFees = default, Option<AdyenMarkupEnum?> adyenMarkup = default, Option<ChargebackEnum?> chargeback = default, Option<ChargebackCostAllocationEnum?> chargebackCostAllocation = default, Option<InterchangeEnum?> interchange = default, Option<PaymentFeeEnum?> paymentFee = default, Option<RefundEnum?> refund = default, Option<RefundCostAllocationEnum?> refundCostAllocation = default, Option<RemainderEnum?> remainder = default, Option<SchemeFeeEnum?> schemeFee = default, Option<string?> splitLogicId = default, Option<SurchargeEnum?> surcharge = default, Option<TipEnum?> tip = default)
        {
            Commission = commission;
            _AcquiringFeesOption = acquiringFees;
            _AdditionalCommissionOption = additionalCommission;
            _AdyenCommissionOption = adyenCommission;
            _AdyenFeesOption = adyenFees;
            _AdyenMarkupOption = adyenMarkup;
            _ChargebackOption = chargeback;
            _ChargebackCostAllocationOption = chargebackCostAllocation;
            _InterchangeOption = interchange;
            _PaymentFeeOption = paymentFee;
            _RefundOption = refund;
            _RefundCostAllocationOption = refundCostAllocation;
            _RemainderOption = remainder;
            _SchemeFeeOption = schemeFee;
            _SplitLogicIdOption = splitLogicId;
            _SurchargeOption = surcharge;
            _TipOption = tip;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// Deducts the acquiring fees (the aggregated amount of interchange and scheme fee) from the specified balance account.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.
        /// </summary>
        /// <value>Deducts the acquiring fees (the aggregated amount of interchange and scheme fee) from the specified balance account.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.</value>
        [JsonConverter(typeof(AcquiringFeesEnumJsonConverter))]
        public class AcquiringFeesEnum: IEnum
        {
            /// <summary>
            /// Returns the value of the AcquiringFeesEnum.
            /// </summary>
            public string? Value { get; set; }

            /// <summary>
            /// AcquiringFeesEnum.DeductFromLiableAccount - deductFromLiableAccount
            /// </summary>
            public static readonly AcquiringFeesEnum DeductFromLiableAccount = new("deductFromLiableAccount");

            /// <summary>
            /// AcquiringFeesEnum.DeductFromOneBalanceAccount - deductFromOneBalanceAccount
            /// </summary>
            public static readonly AcquiringFeesEnum DeductFromOneBalanceAccount = new("deductFromOneBalanceAccount");
        
            private AcquiringFeesEnum(string? value)
            {
                Value = value;
            }

            /// <summary>
            /// Converts a string to a <see cref="AcquiringFeesEnum"/> implicitly.
            /// </summary>
            /// <param name="value">The string value to convert. Defaults to null.</param>
            /// <returns>A new <see cref="AcquiringFeesEnum"/> instance initialized with the string value.</returns>
            public static implicit operator AcquiringFeesEnum?(string? value) => value == null ? null : new AcquiringFeesEnum(value);
    
            /// <summary>
            /// Converts a <see cref="AcquiringFeesEnum"/> instance to a string implicitly.
            /// </summary>
            /// <param name="option">The <see cref="AcquiringFeesEnum"/> instance. Default to null.</param>
            /// <returns>String value of the <see cref="AcquiringFeesEnum"/> instance./// </returns>
            public static implicit operator string?(AcquiringFeesEnum? option) => option?.Value;
        
            public static bool operator ==(AcquiringFeesEnum? left, AcquiringFeesEnum? right) => string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);
    
            public static bool operator !=(AcquiringFeesEnum? left, AcquiringFeesEnum? right) => !string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);

            public override bool Equals(object? obj) => obj is AcquiringFeesEnum other && string.Equals(Value, other.Value, StringComparison.OrdinalIgnoreCase);
    
            public override int GetHashCode() => Value?.GetHashCode() ?? 0;
        
            public override string ToString() => Value ?? string.Empty;
        
            /// <summary>
            /// Returns a <see cref="AcquiringFeesEnum?"/>.
            /// </summary>
            /// <param name="value"></param>
            /// <returns><see cref="AcquiringFeesEnum"/> or null.</returns>
            public static AcquiringFeesEnum? FromStringOrDefault(string value)
            {
                return value switch {
                    "deductFromLiableAccount" => AcquiringFeesEnum.DeductFromLiableAccount,
                    "deductFromOneBalanceAccount" => AcquiringFeesEnum.DeductFromOneBalanceAccount,
                    _ => null,
                };
            }
    
            /// <summary>
            /// Converts the <see cref="AcquiringFeesEnum"/> to the json value.
            /// </summary>
            /// <param name="value"><see cref="AcquiringFeesEnum"/></param>
            /// <returns>String value of the enum.</returns>
            /// <exception cref="NotImplementedException"></exception>
            public static string? ToJsonValue(AcquiringFeesEnum? value)
            {
                if (value == null)
                    return null;
            
                if (value == AcquiringFeesEnum.DeductFromLiableAccount)
                    return "deductFromLiableAccount";
                
                if (value == AcquiringFeesEnum.DeductFromOneBalanceAccount)
                    return "deductFromOneBalanceAccount";
                
                return null;
            }
            
            /// <summary>
            /// JsonConverter for writing AcquiringFeesEnum.               
            /// </summary>
            public class AcquiringFeesEnumJsonConverter : JsonConverter<AcquiringFeesEnum>
            {
                public override AcquiringFeesEnum? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions jsonOptions)
                {
                    string value = reader.GetString();
                    return value == null ? null : AcquiringFeesEnum.FromStringOrDefault(value) ?? new AcquiringFeesEnum(value);
                }

                public override void Write(Utf8JsonWriter writer, AcquiringFeesEnum value, JsonSerializerOptions jsonOptions)
                {
                    writer.WriteStringValue(AcquiringFeesEnum.ToJsonValue(value));
                }
            }
        }

        /// <summary>
        /// Used to track whether AcquiringFees is set or not.
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<AcquiringFeesEnum?> _AcquiringFeesOption { get; private set; }

        /// <summary>
        /// Deducts the acquiring fees (the aggregated amount of interchange and scheme fee) from the specified balance account.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.
        /// </summary>
        /// <value>Deducts the acquiring fees (the aggregated amount of interchange and scheme fee) from the specified balance account.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.</value>
        [JsonPropertyName("acquiringFees")]
        public AcquiringFeesEnum? AcquiringFees { get { return this._AcquiringFeesOption; } set { this._AcquiringFeesOption = new(value); } }

        /// <summary>
        /// Deducts the transaction fee due to Adyen under [blended rates](https://www.adyen.com/knowledge-hub/guides/payments-training-guide/get-the-best-from-your-card-processing) from the specified balance account.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.
        /// </summary>
        /// <value>Deducts the transaction fee due to Adyen under [blended rates](https://www.adyen.com/knowledge-hub/guides/payments-training-guide/get-the-best-from-your-card-processing) from the specified balance account.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.</value>
        [JsonConverter(typeof(AdyenCommissionEnumJsonConverter))]
        public class AdyenCommissionEnum: IEnum
        {
            /// <summary>
            /// Returns the value of the AdyenCommissionEnum.
            /// </summary>
            public string? Value { get; set; }

            /// <summary>
            /// AdyenCommissionEnum.DeductFromLiableAccount - deductFromLiableAccount
            /// </summary>
            public static readonly AdyenCommissionEnum DeductFromLiableAccount = new("deductFromLiableAccount");

            /// <summary>
            /// AdyenCommissionEnum.DeductFromOneBalanceAccount - deductFromOneBalanceAccount
            /// </summary>
            public static readonly AdyenCommissionEnum DeductFromOneBalanceAccount = new("deductFromOneBalanceAccount");
        
            private AdyenCommissionEnum(string? value)
            {
                Value = value;
            }

            /// <summary>
            /// Converts a string to a <see cref="AdyenCommissionEnum"/> implicitly.
            /// </summary>
            /// <param name="value">The string value to convert. Defaults to null.</param>
            /// <returns>A new <see cref="AdyenCommissionEnum"/> instance initialized with the string value.</returns>
            public static implicit operator AdyenCommissionEnum?(string? value) => value == null ? null : new AdyenCommissionEnum(value);
    
            /// <summary>
            /// Converts a <see cref="AdyenCommissionEnum"/> instance to a string implicitly.
            /// </summary>
            /// <param name="option">The <see cref="AdyenCommissionEnum"/> instance. Default to null.</param>
            /// <returns>String value of the <see cref="AdyenCommissionEnum"/> instance./// </returns>
            public static implicit operator string?(AdyenCommissionEnum? option) => option?.Value;
        
            public static bool operator ==(AdyenCommissionEnum? left, AdyenCommissionEnum? right) => string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);
    
            public static bool operator !=(AdyenCommissionEnum? left, AdyenCommissionEnum? right) => !string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);

            public override bool Equals(object? obj) => obj is AdyenCommissionEnum other && string.Equals(Value, other.Value, StringComparison.OrdinalIgnoreCase);
    
            public override int GetHashCode() => Value?.GetHashCode() ?? 0;
        
            public override string ToString() => Value ?? string.Empty;
        
            /// <summary>
            /// Returns a <see cref="AdyenCommissionEnum?"/>.
            /// </summary>
            /// <param name="value"></param>
            /// <returns><see cref="AdyenCommissionEnum"/> or null.</returns>
            public static AdyenCommissionEnum? FromStringOrDefault(string value)
            {
                return value switch {
                    "deductFromLiableAccount" => AdyenCommissionEnum.DeductFromLiableAccount,
                    "deductFromOneBalanceAccount" => AdyenCommissionEnum.DeductFromOneBalanceAccount,
                    _ => null,
                };
            }
    
            /// <summary>
            /// Converts the <see cref="AdyenCommissionEnum"/> to the json value.
            /// </summary>
            /// <param name="value"><see cref="AdyenCommissionEnum"/></param>
            /// <returns>String value of the enum.</returns>
            /// <exception cref="NotImplementedException"></exception>
            public static string? ToJsonValue(AdyenCommissionEnum? value)
            {
                if (value == null)
                    return null;
            
                if (value == AdyenCommissionEnum.DeductFromLiableAccount)
                    return "deductFromLiableAccount";
                
                if (value == AdyenCommissionEnum.DeductFromOneBalanceAccount)
                    return "deductFromOneBalanceAccount";
                
                return null;
            }
            
            /// <summary>
            /// JsonConverter for writing AdyenCommissionEnum.               
            /// </summary>
            public class AdyenCommissionEnumJsonConverter : JsonConverter<AdyenCommissionEnum>
            {
                public override AdyenCommissionEnum? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions jsonOptions)
                {
                    string value = reader.GetString();
                    return value == null ? null : AdyenCommissionEnum.FromStringOrDefault(value) ?? new AdyenCommissionEnum(value);
                }

                public override void Write(Utf8JsonWriter writer, AdyenCommissionEnum value, JsonSerializerOptions jsonOptions)
                {
                    writer.WriteStringValue(AdyenCommissionEnum.ToJsonValue(value));
                }
            }
        }

        /// <summary>
        /// Used to track whether AdyenCommission is set or not.
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<AdyenCommissionEnum?> _AdyenCommissionOption { get; private set; }

        /// <summary>
        /// Deducts the transaction fee due to Adyen under [blended rates](https://www.adyen.com/knowledge-hub/guides/payments-training-guide/get-the-best-from-your-card-processing) from the specified balance account.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.
        /// </summary>
        /// <value>Deducts the transaction fee due to Adyen under [blended rates](https://www.adyen.com/knowledge-hub/guides/payments-training-guide/get-the-best-from-your-card-processing) from the specified balance account.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.</value>
        [JsonPropertyName("adyenCommission")]
        public AdyenCommissionEnum? AdyenCommission { get { return this._AdyenCommissionOption; } set { this._AdyenCommissionOption = new(value); } }

        /// <summary>
        /// Deducts the fees due to Adyen (markup or commission) from the specified balance account.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.
        /// </summary>
        /// <value>Deducts the fees due to Adyen (markup or commission) from the specified balance account.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.</value>
        [JsonConverter(typeof(AdyenFeesEnumJsonConverter))]
        public class AdyenFeesEnum: IEnum
        {
            /// <summary>
            /// Returns the value of the AdyenFeesEnum.
            /// </summary>
            public string? Value { get; set; }

            /// <summary>
            /// AdyenFeesEnum.DeductFromLiableAccount - deductFromLiableAccount
            /// </summary>
            public static readonly AdyenFeesEnum DeductFromLiableAccount = new("deductFromLiableAccount");

            /// <summary>
            /// AdyenFeesEnum.DeductFromOneBalanceAccount - deductFromOneBalanceAccount
            /// </summary>
            public static readonly AdyenFeesEnum DeductFromOneBalanceAccount = new("deductFromOneBalanceAccount");
        
            private AdyenFeesEnum(string? value)
            {
                Value = value;
            }

            /// <summary>
            /// Converts a string to a <see cref="AdyenFeesEnum"/> implicitly.
            /// </summary>
            /// <param name="value">The string value to convert. Defaults to null.</param>
            /// <returns>A new <see cref="AdyenFeesEnum"/> instance initialized with the string value.</returns>
            public static implicit operator AdyenFeesEnum?(string? value) => value == null ? null : new AdyenFeesEnum(value);
    
            /// <summary>
            /// Converts a <see cref="AdyenFeesEnum"/> instance to a string implicitly.
            /// </summary>
            /// <param name="option">The <see cref="AdyenFeesEnum"/> instance. Default to null.</param>
            /// <returns>String value of the <see cref="AdyenFeesEnum"/> instance./// </returns>
            public static implicit operator string?(AdyenFeesEnum? option) => option?.Value;
        
            public static bool operator ==(AdyenFeesEnum? left, AdyenFeesEnum? right) => string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);
    
            public static bool operator !=(AdyenFeesEnum? left, AdyenFeesEnum? right) => !string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);

            public override bool Equals(object? obj) => obj is AdyenFeesEnum other && string.Equals(Value, other.Value, StringComparison.OrdinalIgnoreCase);
    
            public override int GetHashCode() => Value?.GetHashCode() ?? 0;
        
            public override string ToString() => Value ?? string.Empty;
        
            /// <summary>
            /// Returns a <see cref="AdyenFeesEnum?"/>.
            /// </summary>
            /// <param name="value"></param>
            /// <returns><see cref="AdyenFeesEnum"/> or null.</returns>
            public static AdyenFeesEnum? FromStringOrDefault(string value)
            {
                return value switch {
                    "deductFromLiableAccount" => AdyenFeesEnum.DeductFromLiableAccount,
                    "deductFromOneBalanceAccount" => AdyenFeesEnum.DeductFromOneBalanceAccount,
                    _ => null,
                };
            }
    
            /// <summary>
            /// Converts the <see cref="AdyenFeesEnum"/> to the json value.
            /// </summary>
            /// <param name="value"><see cref="AdyenFeesEnum"/></param>
            /// <returns>String value of the enum.</returns>
            /// <exception cref="NotImplementedException"></exception>
            public static string? ToJsonValue(AdyenFeesEnum? value)
            {
                if (value == null)
                    return null;
            
                if (value == AdyenFeesEnum.DeductFromLiableAccount)
                    return "deductFromLiableAccount";
                
                if (value == AdyenFeesEnum.DeductFromOneBalanceAccount)
                    return "deductFromOneBalanceAccount";
                
                return null;
            }
            
            /// <summary>
            /// JsonConverter for writing AdyenFeesEnum.               
            /// </summary>
            public class AdyenFeesEnumJsonConverter : JsonConverter<AdyenFeesEnum>
            {
                public override AdyenFeesEnum? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions jsonOptions)
                {
                    string value = reader.GetString();
                    return value == null ? null : AdyenFeesEnum.FromStringOrDefault(value) ?? new AdyenFeesEnum(value);
                }

                public override void Write(Utf8JsonWriter writer, AdyenFeesEnum value, JsonSerializerOptions jsonOptions)
                {
                    writer.WriteStringValue(AdyenFeesEnum.ToJsonValue(value));
                }
            }
        }

        /// <summary>
        /// Used to track whether AdyenFees is set or not.
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<AdyenFeesEnum?> _AdyenFeesOption { get; private set; }

        /// <summary>
        /// Deducts the fees due to Adyen (markup or commission) from the specified balance account.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.
        /// </summary>
        /// <value>Deducts the fees due to Adyen (markup or commission) from the specified balance account.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.</value>
        [JsonPropertyName("adyenFees")]
        public AdyenFeesEnum? AdyenFees { get { return this._AdyenFeesOption; } set { this._AdyenFeesOption = new(value); } }

        /// <summary>
        /// Deducts the transaction fee due to Adyen under [Interchange ++ pricing](https://www.adyen.com/what-is-interchange) from the specified balance account.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.
        /// </summary>
        /// <value>Deducts the transaction fee due to Adyen under [Interchange ++ pricing](https://www.adyen.com/what-is-interchange) from the specified balance account.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.</value>
        [JsonConverter(typeof(AdyenMarkupEnumJsonConverter))]
        public class AdyenMarkupEnum: IEnum
        {
            /// <summary>
            /// Returns the value of the AdyenMarkupEnum.
            /// </summary>
            public string? Value { get; set; }

            /// <summary>
            /// AdyenMarkupEnum.DeductFromLiableAccount - deductFromLiableAccount
            /// </summary>
            public static readonly AdyenMarkupEnum DeductFromLiableAccount = new("deductFromLiableAccount");

            /// <summary>
            /// AdyenMarkupEnum.DeductFromOneBalanceAccount - deductFromOneBalanceAccount
            /// </summary>
            public static readonly AdyenMarkupEnum DeductFromOneBalanceAccount = new("deductFromOneBalanceAccount");
        
            private AdyenMarkupEnum(string? value)
            {
                Value = value;
            }

            /// <summary>
            /// Converts a string to a <see cref="AdyenMarkupEnum"/> implicitly.
            /// </summary>
            /// <param name="value">The string value to convert. Defaults to null.</param>
            /// <returns>A new <see cref="AdyenMarkupEnum"/> instance initialized with the string value.</returns>
            public static implicit operator AdyenMarkupEnum?(string? value) => value == null ? null : new AdyenMarkupEnum(value);
    
            /// <summary>
            /// Converts a <see cref="AdyenMarkupEnum"/> instance to a string implicitly.
            /// </summary>
            /// <param name="option">The <see cref="AdyenMarkupEnum"/> instance. Default to null.</param>
            /// <returns>String value of the <see cref="AdyenMarkupEnum"/> instance./// </returns>
            public static implicit operator string?(AdyenMarkupEnum? option) => option?.Value;
        
            public static bool operator ==(AdyenMarkupEnum? left, AdyenMarkupEnum? right) => string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);
    
            public static bool operator !=(AdyenMarkupEnum? left, AdyenMarkupEnum? right) => !string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);

            public override bool Equals(object? obj) => obj is AdyenMarkupEnum other && string.Equals(Value, other.Value, StringComparison.OrdinalIgnoreCase);
    
            public override int GetHashCode() => Value?.GetHashCode() ?? 0;
        
            public override string ToString() => Value ?? string.Empty;
        
            /// <summary>
            /// Returns a <see cref="AdyenMarkupEnum?"/>.
            /// </summary>
            /// <param name="value"></param>
            /// <returns><see cref="AdyenMarkupEnum"/> or null.</returns>
            public static AdyenMarkupEnum? FromStringOrDefault(string value)
            {
                return value switch {
                    "deductFromLiableAccount" => AdyenMarkupEnum.DeductFromLiableAccount,
                    "deductFromOneBalanceAccount" => AdyenMarkupEnum.DeductFromOneBalanceAccount,
                    _ => null,
                };
            }
    
            /// <summary>
            /// Converts the <see cref="AdyenMarkupEnum"/> to the json value.
            /// </summary>
            /// <param name="value"><see cref="AdyenMarkupEnum"/></param>
            /// <returns>String value of the enum.</returns>
            /// <exception cref="NotImplementedException"></exception>
            public static string? ToJsonValue(AdyenMarkupEnum? value)
            {
                if (value == null)
                    return null;
            
                if (value == AdyenMarkupEnum.DeductFromLiableAccount)
                    return "deductFromLiableAccount";
                
                if (value == AdyenMarkupEnum.DeductFromOneBalanceAccount)
                    return "deductFromOneBalanceAccount";
                
                return null;
            }
            
            /// <summary>
            /// JsonConverter for writing AdyenMarkupEnum.               
            /// </summary>
            public class AdyenMarkupEnumJsonConverter : JsonConverter<AdyenMarkupEnum>
            {
                public override AdyenMarkupEnum? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions jsonOptions)
                {
                    string value = reader.GetString();
                    return value == null ? null : AdyenMarkupEnum.FromStringOrDefault(value) ?? new AdyenMarkupEnum(value);
                }

                public override void Write(Utf8JsonWriter writer, AdyenMarkupEnum value, JsonSerializerOptions jsonOptions)
                {
                    writer.WriteStringValue(AdyenMarkupEnum.ToJsonValue(value));
                }
            }
        }

        /// <summary>
        /// Used to track whether AdyenMarkup is set or not.
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<AdyenMarkupEnum?> _AdyenMarkupOption { get; private set; }

        /// <summary>
        /// Deducts the transaction fee due to Adyen under [Interchange ++ pricing](https://www.adyen.com/what-is-interchange) from the specified balance account.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.
        /// </summary>
        /// <value>Deducts the transaction fee due to Adyen under [Interchange ++ pricing](https://www.adyen.com/what-is-interchange) from the specified balance account.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.</value>
        [JsonPropertyName("adyenMarkup")]
        public AdyenMarkupEnum? AdyenMarkup { get { return this._AdyenMarkupOption; } set { this._AdyenMarkupOption = new(value); } }

        /// <summary>
        /// Specifies how and from which balance account(s) to deduct the chargeback amount.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**, **deductAccordingToSplitRatio**.
        /// </summary>
        /// <value>Specifies how and from which balance account(s) to deduct the chargeback amount.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**, **deductAccordingToSplitRatio**.</value>
        [JsonConverter(typeof(ChargebackEnumJsonConverter))]
        public class ChargebackEnum: IEnum
        {
            /// <summary>
            /// Returns the value of the ChargebackEnum.
            /// </summary>
            public string? Value { get; set; }

            /// <summary>
            /// ChargebackEnum.DeductFromLiableAccount - deductFromLiableAccount
            /// </summary>
            public static readonly ChargebackEnum DeductFromLiableAccount = new("deductFromLiableAccount");

            /// <summary>
            /// ChargebackEnum.DeductFromOneBalanceAccount - deductFromOneBalanceAccount
            /// </summary>
            public static readonly ChargebackEnum DeductFromOneBalanceAccount = new("deductFromOneBalanceAccount");

            /// <summary>
            /// ChargebackEnum.DeductAccordingToSplitRatio - deductAccordingToSplitRatio
            /// </summary>
            public static readonly ChargebackEnum DeductAccordingToSplitRatio = new("deductAccordingToSplitRatio");
        
            private ChargebackEnum(string? value)
            {
                Value = value;
            }

            /// <summary>
            /// Converts a string to a <see cref="ChargebackEnum"/> implicitly.
            /// </summary>
            /// <param name="value">The string value to convert. Defaults to null.</param>
            /// <returns>A new <see cref="ChargebackEnum"/> instance initialized with the string value.</returns>
            public static implicit operator ChargebackEnum?(string? value) => value == null ? null : new ChargebackEnum(value);
    
            /// <summary>
            /// Converts a <see cref="ChargebackEnum"/> instance to a string implicitly.
            /// </summary>
            /// <param name="option">The <see cref="ChargebackEnum"/> instance. Default to null.</param>
            /// <returns>String value of the <see cref="ChargebackEnum"/> instance./// </returns>
            public static implicit operator string?(ChargebackEnum? option) => option?.Value;
        
            public static bool operator ==(ChargebackEnum? left, ChargebackEnum? right) => string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);
    
            public static bool operator !=(ChargebackEnum? left, ChargebackEnum? right) => !string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);

            public override bool Equals(object? obj) => obj is ChargebackEnum other && string.Equals(Value, other.Value, StringComparison.OrdinalIgnoreCase);
    
            public override int GetHashCode() => Value?.GetHashCode() ?? 0;
        
            public override string ToString() => Value ?? string.Empty;
        
            /// <summary>
            /// Returns a <see cref="ChargebackEnum?"/>.
            /// </summary>
            /// <param name="value"></param>
            /// <returns><see cref="ChargebackEnum"/> or null.</returns>
            public static ChargebackEnum? FromStringOrDefault(string value)
            {
                return value switch {
                    "deductFromLiableAccount" => ChargebackEnum.DeductFromLiableAccount,
                    "deductFromOneBalanceAccount" => ChargebackEnum.DeductFromOneBalanceAccount,
                    "deductAccordingToSplitRatio" => ChargebackEnum.DeductAccordingToSplitRatio,
                    _ => null,
                };
            }
    
            /// <summary>
            /// Converts the <see cref="ChargebackEnum"/> to the json value.
            /// </summary>
            /// <param name="value"><see cref="ChargebackEnum"/></param>
            /// <returns>String value of the enum.</returns>
            /// <exception cref="NotImplementedException"></exception>
            public static string? ToJsonValue(ChargebackEnum? value)
            {
                if (value == null)
                    return null;
            
                if (value == ChargebackEnum.DeductFromLiableAccount)
                    return "deductFromLiableAccount";
                
                if (value == ChargebackEnum.DeductFromOneBalanceAccount)
                    return "deductFromOneBalanceAccount";
                
                if (value == ChargebackEnum.DeductAccordingToSplitRatio)
                    return "deductAccordingToSplitRatio";
                
                return null;
            }
            
            /// <summary>
            /// JsonConverter for writing ChargebackEnum.               
            /// </summary>
            public class ChargebackEnumJsonConverter : JsonConverter<ChargebackEnum>
            {
                public override ChargebackEnum? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions jsonOptions)
                {
                    string value = reader.GetString();
                    return value == null ? null : ChargebackEnum.FromStringOrDefault(value) ?? new ChargebackEnum(value);
                }

                public override void Write(Utf8JsonWriter writer, ChargebackEnum value, JsonSerializerOptions jsonOptions)
                {
                    writer.WriteStringValue(ChargebackEnum.ToJsonValue(value));
                }
            }
        }

        /// <summary>
        /// Used to track whether Chargeback is set or not.
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<ChargebackEnum?> _ChargebackOption { get; private set; }

        /// <summary>
        /// Specifies how and from which balance account(s) to deduct the chargeback amount.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**, **deductAccordingToSplitRatio**.
        /// </summary>
        /// <value>Specifies how and from which balance account(s) to deduct the chargeback amount.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**, **deductAccordingToSplitRatio**.</value>
        [JsonPropertyName("chargeback")]
        public ChargebackEnum? Chargeback { get { return this._ChargebackOption; } set { this._ChargebackOption = new(value); } }

        /// <summary>
        /// Deducts the chargeback costs from the specified balance account.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**
        /// </summary>
        /// <value>Deducts the chargeback costs from the specified balance account.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**</value>
        [JsonConverter(typeof(ChargebackCostAllocationEnumJsonConverter))]
        public class ChargebackCostAllocationEnum: IEnum
        {
            /// <summary>
            /// Returns the value of the ChargebackCostAllocationEnum.
            /// </summary>
            public string? Value { get; set; }

            /// <summary>
            /// ChargebackCostAllocationEnum.DeductFromLiableAccount - deductFromLiableAccount
            /// </summary>
            public static readonly ChargebackCostAllocationEnum DeductFromLiableAccount = new("deductFromLiableAccount");

            /// <summary>
            /// ChargebackCostAllocationEnum.DeductFromOneBalanceAccount - deductFromOneBalanceAccount
            /// </summary>
            public static readonly ChargebackCostAllocationEnum DeductFromOneBalanceAccount = new("deductFromOneBalanceAccount");
        
            private ChargebackCostAllocationEnum(string? value)
            {
                Value = value;
            }

            /// <summary>
            /// Converts a string to a <see cref="ChargebackCostAllocationEnum"/> implicitly.
            /// </summary>
            /// <param name="value">The string value to convert. Defaults to null.</param>
            /// <returns>A new <see cref="ChargebackCostAllocationEnum"/> instance initialized with the string value.</returns>
            public static implicit operator ChargebackCostAllocationEnum?(string? value) => value == null ? null : new ChargebackCostAllocationEnum(value);
    
            /// <summary>
            /// Converts a <see cref="ChargebackCostAllocationEnum"/> instance to a string implicitly.
            /// </summary>
            /// <param name="option">The <see cref="ChargebackCostAllocationEnum"/> instance. Default to null.</param>
            /// <returns>String value of the <see cref="ChargebackCostAllocationEnum"/> instance./// </returns>
            public static implicit operator string?(ChargebackCostAllocationEnum? option) => option?.Value;
        
            public static bool operator ==(ChargebackCostAllocationEnum? left, ChargebackCostAllocationEnum? right) => string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);
    
            public static bool operator !=(ChargebackCostAllocationEnum? left, ChargebackCostAllocationEnum? right) => !string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);

            public override bool Equals(object? obj) => obj is ChargebackCostAllocationEnum other && string.Equals(Value, other.Value, StringComparison.OrdinalIgnoreCase);
    
            public override int GetHashCode() => Value?.GetHashCode() ?? 0;
        
            public override string ToString() => Value ?? string.Empty;
        
            /// <summary>
            /// Returns a <see cref="ChargebackCostAllocationEnum?"/>.
            /// </summary>
            /// <param name="value"></param>
            /// <returns><see cref="ChargebackCostAllocationEnum"/> or null.</returns>
            public static ChargebackCostAllocationEnum? FromStringOrDefault(string value)
            {
                return value switch {
                    "deductFromLiableAccount" => ChargebackCostAllocationEnum.DeductFromLiableAccount,
                    "deductFromOneBalanceAccount" => ChargebackCostAllocationEnum.DeductFromOneBalanceAccount,
                    _ => null,
                };
            }
    
            /// <summary>
            /// Converts the <see cref="ChargebackCostAllocationEnum"/> to the json value.
            /// </summary>
            /// <param name="value"><see cref="ChargebackCostAllocationEnum"/></param>
            /// <returns>String value of the enum.</returns>
            /// <exception cref="NotImplementedException"></exception>
            public static string? ToJsonValue(ChargebackCostAllocationEnum? value)
            {
                if (value == null)
                    return null;
            
                if (value == ChargebackCostAllocationEnum.DeductFromLiableAccount)
                    return "deductFromLiableAccount";
                
                if (value == ChargebackCostAllocationEnum.DeductFromOneBalanceAccount)
                    return "deductFromOneBalanceAccount";
                
                return null;
            }
            
            /// <summary>
            /// JsonConverter for writing ChargebackCostAllocationEnum.               
            /// </summary>
            public class ChargebackCostAllocationEnumJsonConverter : JsonConverter<ChargebackCostAllocationEnum>
            {
                public override ChargebackCostAllocationEnum? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions jsonOptions)
                {
                    string value = reader.GetString();
                    return value == null ? null : ChargebackCostAllocationEnum.FromStringOrDefault(value) ?? new ChargebackCostAllocationEnum(value);
                }

                public override void Write(Utf8JsonWriter writer, ChargebackCostAllocationEnum value, JsonSerializerOptions jsonOptions)
                {
                    writer.WriteStringValue(ChargebackCostAllocationEnum.ToJsonValue(value));
                }
            }
        }

        /// <summary>
        /// Used to track whether ChargebackCostAllocation is set or not.
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<ChargebackCostAllocationEnum?> _ChargebackCostAllocationOption { get; private set; }

        /// <summary>
        /// Deducts the chargeback costs from the specified balance account.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**
        /// </summary>
        /// <value>Deducts the chargeback costs from the specified balance account.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**</value>
        [JsonPropertyName("chargebackCostAllocation")]
        public ChargebackCostAllocationEnum? ChargebackCostAllocation { get { return this._ChargebackCostAllocationOption; } set { this._ChargebackCostAllocationOption = new(value); } }

        /// <summary>
        /// Deducts the interchange fee from specified balance account.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.
        /// </summary>
        /// <value>Deducts the interchange fee from specified balance account.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.</value>
        [JsonConverter(typeof(InterchangeEnumJsonConverter))]
        public class InterchangeEnum: IEnum
        {
            /// <summary>
            /// Returns the value of the InterchangeEnum.
            /// </summary>
            public string? Value { get; set; }

            /// <summary>
            /// InterchangeEnum.DeductFromLiableAccount - deductFromLiableAccount
            /// </summary>
            public static readonly InterchangeEnum DeductFromLiableAccount = new("deductFromLiableAccount");

            /// <summary>
            /// InterchangeEnum.DeductFromOneBalanceAccount - deductFromOneBalanceAccount
            /// </summary>
            public static readonly InterchangeEnum DeductFromOneBalanceAccount = new("deductFromOneBalanceAccount");
        
            private InterchangeEnum(string? value)
            {
                Value = value;
            }

            /// <summary>
            /// Converts a string to a <see cref="InterchangeEnum"/> implicitly.
            /// </summary>
            /// <param name="value">The string value to convert. Defaults to null.</param>
            /// <returns>A new <see cref="InterchangeEnum"/> instance initialized with the string value.</returns>
            public static implicit operator InterchangeEnum?(string? value) => value == null ? null : new InterchangeEnum(value);
    
            /// <summary>
            /// Converts a <see cref="InterchangeEnum"/> instance to a string implicitly.
            /// </summary>
            /// <param name="option">The <see cref="InterchangeEnum"/> instance. Default to null.</param>
            /// <returns>String value of the <see cref="InterchangeEnum"/> instance./// </returns>
            public static implicit operator string?(InterchangeEnum? option) => option?.Value;
        
            public static bool operator ==(InterchangeEnum? left, InterchangeEnum? right) => string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);
    
            public static bool operator !=(InterchangeEnum? left, InterchangeEnum? right) => !string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);

            public override bool Equals(object? obj) => obj is InterchangeEnum other && string.Equals(Value, other.Value, StringComparison.OrdinalIgnoreCase);
    
            public override int GetHashCode() => Value?.GetHashCode() ?? 0;
        
            public override string ToString() => Value ?? string.Empty;
        
            /// <summary>
            /// Returns a <see cref="InterchangeEnum?"/>.
            /// </summary>
            /// <param name="value"></param>
            /// <returns><see cref="InterchangeEnum"/> or null.</returns>
            public static InterchangeEnum? FromStringOrDefault(string value)
            {
                return value switch {
                    "deductFromLiableAccount" => InterchangeEnum.DeductFromLiableAccount,
                    "deductFromOneBalanceAccount" => InterchangeEnum.DeductFromOneBalanceAccount,
                    _ => null,
                };
            }
    
            /// <summary>
            /// Converts the <see cref="InterchangeEnum"/> to the json value.
            /// </summary>
            /// <param name="value"><see cref="InterchangeEnum"/></param>
            /// <returns>String value of the enum.</returns>
            /// <exception cref="NotImplementedException"></exception>
            public static string? ToJsonValue(InterchangeEnum? value)
            {
                if (value == null)
                    return null;
            
                if (value == InterchangeEnum.DeductFromLiableAccount)
                    return "deductFromLiableAccount";
                
                if (value == InterchangeEnum.DeductFromOneBalanceAccount)
                    return "deductFromOneBalanceAccount";
                
                return null;
            }
            
            /// <summary>
            /// JsonConverter for writing InterchangeEnum.               
            /// </summary>
            public class InterchangeEnumJsonConverter : JsonConverter<InterchangeEnum>
            {
                public override InterchangeEnum? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions jsonOptions)
                {
                    string value = reader.GetString();
                    return value == null ? null : InterchangeEnum.FromStringOrDefault(value) ?? new InterchangeEnum(value);
                }

                public override void Write(Utf8JsonWriter writer, InterchangeEnum value, JsonSerializerOptions jsonOptions)
                {
                    writer.WriteStringValue(InterchangeEnum.ToJsonValue(value));
                }
            }
        }

        /// <summary>
        /// Used to track whether Interchange is set or not.
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<InterchangeEnum?> _InterchangeOption { get; private set; }

        /// <summary>
        /// Deducts the interchange fee from specified balance account.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.
        /// </summary>
        /// <value>Deducts the interchange fee from specified balance account.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.</value>
        [JsonPropertyName("interchange")]
        public InterchangeEnum? Interchange { get { return this._InterchangeOption; } set { this._InterchangeOption = new(value); } }

        /// <summary>
        /// Deducts all transaction fees incurred by the payment from the specified balance account. The transaction fees include the acquiring fees (interchange and scheme fee), and the fees due to Adyen (markup or commission). You can book any and all these fees to different balance account by specifying other transaction fee parameters in your split configuration profile:  - [&#x60;adyenCommission&#x60;](https://docs.adyen.com/api-explorer/Management/latest/post/merchants/(merchantId)/splitConfigurations#request-rules-splitLogic-adyenCommission): The transaction fee due to Adyen under [blended rates](https://www.adyen.com/knowledge-hub/interchange-fees-explained#interchange-vs-blended). - [&#x60;adyenMarkup&#x60;](https://docs.adyen.com/api-explorer/Management/latest/post/merchants/(merchantId)/splitConfigurations#request-rules-splitLogic-adyenMarkup): The transaction fee due to Adyen under [Interchange ++ pricing](https://www.adyen.com/knowledge-hub/interchange-fees-explained#interchange-vs-blended). - [&#x60;schemeFee&#x60;](https://docs.adyen.com/api-explorer/Management/latest/post/merchants/(merchantId)/splitConfigurations#request-rules-splitLogic-schemeFee): The fee paid to the card scheme for using their network. - [&#x60;interchange&#x60;](https://docs.adyen.com/api-explorer/Management/latest/post/merchants/(merchantId)/splitConfigurations#request-rules-splitLogic-interchange): The fee paid to the issuer for each payment transaction made with the card network. - [&#x60;adyenFees&#x60;](https://docs.adyen.com/api-explorer/Management/latest/post/merchants/(merchantId)/splitConfigurations#request-rules-splitLogic-adyenFees): The aggregated amount of Adyen&#39;s commission and markup. - [&#x60;acquiringFees&#x60;](https://docs.adyen.com/api-explorer/Management/latest/post/merchants/(merchantId)/splitConfigurations#request-rules-splitLogic-acquiringFees): The aggregated amount of the interchange and scheme fees.  If you don&#39;t include at least one transaction fee type in the &#x60;splitLogic&#x60; object, Adyen updates the payment request with the &#x60;paymentFee&#x60; parameter, booking all transaction fees to your platform&#39;s liable balance account.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.
        /// </summary>
        /// <value>Deducts all transaction fees incurred by the payment from the specified balance account. The transaction fees include the acquiring fees (interchange and scheme fee), and the fees due to Adyen (markup or commission). You can book any and all these fees to different balance account by specifying other transaction fee parameters in your split configuration profile:  - [&#x60;adyenCommission&#x60;](https://docs.adyen.com/api-explorer/Management/latest/post/merchants/(merchantId)/splitConfigurations#request-rules-splitLogic-adyenCommission): The transaction fee due to Adyen under [blended rates](https://www.adyen.com/knowledge-hub/interchange-fees-explained#interchange-vs-blended). - [&#x60;adyenMarkup&#x60;](https://docs.adyen.com/api-explorer/Management/latest/post/merchants/(merchantId)/splitConfigurations#request-rules-splitLogic-adyenMarkup): The transaction fee due to Adyen under [Interchange ++ pricing](https://www.adyen.com/knowledge-hub/interchange-fees-explained#interchange-vs-blended). - [&#x60;schemeFee&#x60;](https://docs.adyen.com/api-explorer/Management/latest/post/merchants/(merchantId)/splitConfigurations#request-rules-splitLogic-schemeFee): The fee paid to the card scheme for using their network. - [&#x60;interchange&#x60;](https://docs.adyen.com/api-explorer/Management/latest/post/merchants/(merchantId)/splitConfigurations#request-rules-splitLogic-interchange): The fee paid to the issuer for each payment transaction made with the card network. - [&#x60;adyenFees&#x60;](https://docs.adyen.com/api-explorer/Management/latest/post/merchants/(merchantId)/splitConfigurations#request-rules-splitLogic-adyenFees): The aggregated amount of Adyen&#39;s commission and markup. - [&#x60;acquiringFees&#x60;](https://docs.adyen.com/api-explorer/Management/latest/post/merchants/(merchantId)/splitConfigurations#request-rules-splitLogic-acquiringFees): The aggregated amount of the interchange and scheme fees.  If you don&#39;t include at least one transaction fee type in the &#x60;splitLogic&#x60; object, Adyen updates the payment request with the &#x60;paymentFee&#x60; parameter, booking all transaction fees to your platform&#39;s liable balance account.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.</value>
        [JsonConverter(typeof(PaymentFeeEnumJsonConverter))]
        public class PaymentFeeEnum: IEnum
        {
            /// <summary>
            /// Returns the value of the PaymentFeeEnum.
            /// </summary>
            public string? Value { get; set; }

            /// <summary>
            /// PaymentFeeEnum.DeductFromLiableAccount - deductFromLiableAccount
            /// </summary>
            public static readonly PaymentFeeEnum DeductFromLiableAccount = new("deductFromLiableAccount");

            /// <summary>
            /// PaymentFeeEnum.DeductFromOneBalanceAccount - deductFromOneBalanceAccount
            /// </summary>
            public static readonly PaymentFeeEnum DeductFromOneBalanceAccount = new("deductFromOneBalanceAccount");
        
            private PaymentFeeEnum(string? value)
            {
                Value = value;
            }

            /// <summary>
            /// Converts a string to a <see cref="PaymentFeeEnum"/> implicitly.
            /// </summary>
            /// <param name="value">The string value to convert. Defaults to null.</param>
            /// <returns>A new <see cref="PaymentFeeEnum"/> instance initialized with the string value.</returns>
            public static implicit operator PaymentFeeEnum?(string? value) => value == null ? null : new PaymentFeeEnum(value);
    
            /// <summary>
            /// Converts a <see cref="PaymentFeeEnum"/> instance to a string implicitly.
            /// </summary>
            /// <param name="option">The <see cref="PaymentFeeEnum"/> instance. Default to null.</param>
            /// <returns>String value of the <see cref="PaymentFeeEnum"/> instance./// </returns>
            public static implicit operator string?(PaymentFeeEnum? option) => option?.Value;
        
            public static bool operator ==(PaymentFeeEnum? left, PaymentFeeEnum? right) => string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);
    
            public static bool operator !=(PaymentFeeEnum? left, PaymentFeeEnum? right) => !string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);

            public override bool Equals(object? obj) => obj is PaymentFeeEnum other && string.Equals(Value, other.Value, StringComparison.OrdinalIgnoreCase);
    
            public override int GetHashCode() => Value?.GetHashCode() ?? 0;
        
            public override string ToString() => Value ?? string.Empty;
        
            /// <summary>
            /// Returns a <see cref="PaymentFeeEnum?"/>.
            /// </summary>
            /// <param name="value"></param>
            /// <returns><see cref="PaymentFeeEnum"/> or null.</returns>
            public static PaymentFeeEnum? FromStringOrDefault(string value)
            {
                return value switch {
                    "deductFromLiableAccount" => PaymentFeeEnum.DeductFromLiableAccount,
                    "deductFromOneBalanceAccount" => PaymentFeeEnum.DeductFromOneBalanceAccount,
                    _ => null,
                };
            }
    
            /// <summary>
            /// Converts the <see cref="PaymentFeeEnum"/> to the json value.
            /// </summary>
            /// <param name="value"><see cref="PaymentFeeEnum"/></param>
            /// <returns>String value of the enum.</returns>
            /// <exception cref="NotImplementedException"></exception>
            public static string? ToJsonValue(PaymentFeeEnum? value)
            {
                if (value == null)
                    return null;
            
                if (value == PaymentFeeEnum.DeductFromLiableAccount)
                    return "deductFromLiableAccount";
                
                if (value == PaymentFeeEnum.DeductFromOneBalanceAccount)
                    return "deductFromOneBalanceAccount";
                
                return null;
            }
            
            /// <summary>
            /// JsonConverter for writing PaymentFeeEnum.               
            /// </summary>
            public class PaymentFeeEnumJsonConverter : JsonConverter<PaymentFeeEnum>
            {
                public override PaymentFeeEnum? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions jsonOptions)
                {
                    string value = reader.GetString();
                    return value == null ? null : PaymentFeeEnum.FromStringOrDefault(value) ?? new PaymentFeeEnum(value);
                }

                public override void Write(Utf8JsonWriter writer, PaymentFeeEnum value, JsonSerializerOptions jsonOptions)
                {
                    writer.WriteStringValue(PaymentFeeEnum.ToJsonValue(value));
                }
            }
        }

        /// <summary>
        /// Used to track whether PaymentFee is set or not.
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<PaymentFeeEnum?> _PaymentFeeOption { get; private set; }

        /// <summary>
        /// Deducts all transaction fees incurred by the payment from the specified balance account. The transaction fees include the acquiring fees (interchange and scheme fee), and the fees due to Adyen (markup or commission). You can book any and all these fees to different balance account by specifying other transaction fee parameters in your split configuration profile:  - [&#x60;adyenCommission&#x60;](https://docs.adyen.com/api-explorer/Management/latest/post/merchants/(merchantId)/splitConfigurations#request-rules-splitLogic-adyenCommission): The transaction fee due to Adyen under [blended rates](https://www.adyen.com/knowledge-hub/interchange-fees-explained#interchange-vs-blended). - [&#x60;adyenMarkup&#x60;](https://docs.adyen.com/api-explorer/Management/latest/post/merchants/(merchantId)/splitConfigurations#request-rules-splitLogic-adyenMarkup): The transaction fee due to Adyen under [Interchange ++ pricing](https://www.adyen.com/knowledge-hub/interchange-fees-explained#interchange-vs-blended). - [&#x60;schemeFee&#x60;](https://docs.adyen.com/api-explorer/Management/latest/post/merchants/(merchantId)/splitConfigurations#request-rules-splitLogic-schemeFee): The fee paid to the card scheme for using their network. - [&#x60;interchange&#x60;](https://docs.adyen.com/api-explorer/Management/latest/post/merchants/(merchantId)/splitConfigurations#request-rules-splitLogic-interchange): The fee paid to the issuer for each payment transaction made with the card network. - [&#x60;adyenFees&#x60;](https://docs.adyen.com/api-explorer/Management/latest/post/merchants/(merchantId)/splitConfigurations#request-rules-splitLogic-adyenFees): The aggregated amount of Adyen&#39;s commission and markup. - [&#x60;acquiringFees&#x60;](https://docs.adyen.com/api-explorer/Management/latest/post/merchants/(merchantId)/splitConfigurations#request-rules-splitLogic-acquiringFees): The aggregated amount of the interchange and scheme fees.  If you don&#39;t include at least one transaction fee type in the &#x60;splitLogic&#x60; object, Adyen updates the payment request with the &#x60;paymentFee&#x60; parameter, booking all transaction fees to your platform&#39;s liable balance account.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.
        /// </summary>
        /// <value>Deducts all transaction fees incurred by the payment from the specified balance account. The transaction fees include the acquiring fees (interchange and scheme fee), and the fees due to Adyen (markup or commission). You can book any and all these fees to different balance account by specifying other transaction fee parameters in your split configuration profile:  - [&#x60;adyenCommission&#x60;](https://docs.adyen.com/api-explorer/Management/latest/post/merchants/(merchantId)/splitConfigurations#request-rules-splitLogic-adyenCommission): The transaction fee due to Adyen under [blended rates](https://www.adyen.com/knowledge-hub/interchange-fees-explained#interchange-vs-blended). - [&#x60;adyenMarkup&#x60;](https://docs.adyen.com/api-explorer/Management/latest/post/merchants/(merchantId)/splitConfigurations#request-rules-splitLogic-adyenMarkup): The transaction fee due to Adyen under [Interchange ++ pricing](https://www.adyen.com/knowledge-hub/interchange-fees-explained#interchange-vs-blended). - [&#x60;schemeFee&#x60;](https://docs.adyen.com/api-explorer/Management/latest/post/merchants/(merchantId)/splitConfigurations#request-rules-splitLogic-schemeFee): The fee paid to the card scheme for using their network. - [&#x60;interchange&#x60;](https://docs.adyen.com/api-explorer/Management/latest/post/merchants/(merchantId)/splitConfigurations#request-rules-splitLogic-interchange): The fee paid to the issuer for each payment transaction made with the card network. - [&#x60;adyenFees&#x60;](https://docs.adyen.com/api-explorer/Management/latest/post/merchants/(merchantId)/splitConfigurations#request-rules-splitLogic-adyenFees): The aggregated amount of Adyen&#39;s commission and markup. - [&#x60;acquiringFees&#x60;](https://docs.adyen.com/api-explorer/Management/latest/post/merchants/(merchantId)/splitConfigurations#request-rules-splitLogic-acquiringFees): The aggregated amount of the interchange and scheme fees.  If you don&#39;t include at least one transaction fee type in the &#x60;splitLogic&#x60; object, Adyen updates the payment request with the &#x60;paymentFee&#x60; parameter, booking all transaction fees to your platform&#39;s liable balance account.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.</value>
        [JsonPropertyName("paymentFee")]
        public PaymentFeeEnum? PaymentFee { get { return this._PaymentFeeOption; } set { this._PaymentFeeOption = new(value); } }

        /// <summary>
        /// Specifies how and from which balance account(s) to deduct the refund amount.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**, **deductAccordingToSplitRatio**
        /// </summary>
        /// <value>Specifies how and from which balance account(s) to deduct the refund amount.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**, **deductAccordingToSplitRatio**</value>
        [JsonConverter(typeof(RefundEnumJsonConverter))]
        public class RefundEnum: IEnum
        {
            /// <summary>
            /// Returns the value of the RefundEnum.
            /// </summary>
            public string? Value { get; set; }

            /// <summary>
            /// RefundEnum.DeductFromLiableAccount - deductFromLiableAccount
            /// </summary>
            public static readonly RefundEnum DeductFromLiableAccount = new("deductFromLiableAccount");

            /// <summary>
            /// RefundEnum.DeductFromOneBalanceAccount - deductFromOneBalanceAccount
            /// </summary>
            public static readonly RefundEnum DeductFromOneBalanceAccount = new("deductFromOneBalanceAccount");

            /// <summary>
            /// RefundEnum.DeductAccordingToSplitRatio - deductAccordingToSplitRatio
            /// </summary>
            public static readonly RefundEnum DeductAccordingToSplitRatio = new("deductAccordingToSplitRatio");
        
            private RefundEnum(string? value)
            {
                Value = value;
            }

            /// <summary>
            /// Converts a string to a <see cref="RefundEnum"/> implicitly.
            /// </summary>
            /// <param name="value">The string value to convert. Defaults to null.</param>
            /// <returns>A new <see cref="RefundEnum"/> instance initialized with the string value.</returns>
            public static implicit operator RefundEnum?(string? value) => value == null ? null : new RefundEnum(value);
    
            /// <summary>
            /// Converts a <see cref="RefundEnum"/> instance to a string implicitly.
            /// </summary>
            /// <param name="option">The <see cref="RefundEnum"/> instance. Default to null.</param>
            /// <returns>String value of the <see cref="RefundEnum"/> instance./// </returns>
            public static implicit operator string?(RefundEnum? option) => option?.Value;
        
            public static bool operator ==(RefundEnum? left, RefundEnum? right) => string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);
    
            public static bool operator !=(RefundEnum? left, RefundEnum? right) => !string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);

            public override bool Equals(object? obj) => obj is RefundEnum other && string.Equals(Value, other.Value, StringComparison.OrdinalIgnoreCase);
    
            public override int GetHashCode() => Value?.GetHashCode() ?? 0;
        
            public override string ToString() => Value ?? string.Empty;
        
            /// <summary>
            /// Returns a <see cref="RefundEnum?"/>.
            /// </summary>
            /// <param name="value"></param>
            /// <returns><see cref="RefundEnum"/> or null.</returns>
            public static RefundEnum? FromStringOrDefault(string value)
            {
                return value switch {
                    "deductFromLiableAccount" => RefundEnum.DeductFromLiableAccount,
                    "deductFromOneBalanceAccount" => RefundEnum.DeductFromOneBalanceAccount,
                    "deductAccordingToSplitRatio" => RefundEnum.DeductAccordingToSplitRatio,
                    _ => null,
                };
            }
    
            /// <summary>
            /// Converts the <see cref="RefundEnum"/> to the json value.
            /// </summary>
            /// <param name="value"><see cref="RefundEnum"/></param>
            /// <returns>String value of the enum.</returns>
            /// <exception cref="NotImplementedException"></exception>
            public static string? ToJsonValue(RefundEnum? value)
            {
                if (value == null)
                    return null;
            
                if (value == RefundEnum.DeductFromLiableAccount)
                    return "deductFromLiableAccount";
                
                if (value == RefundEnum.DeductFromOneBalanceAccount)
                    return "deductFromOneBalanceAccount";
                
                if (value == RefundEnum.DeductAccordingToSplitRatio)
                    return "deductAccordingToSplitRatio";
                
                return null;
            }
            
            /// <summary>
            /// JsonConverter for writing RefundEnum.               
            /// </summary>
            public class RefundEnumJsonConverter : JsonConverter<RefundEnum>
            {
                public override RefundEnum? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions jsonOptions)
                {
                    string value = reader.GetString();
                    return value == null ? null : RefundEnum.FromStringOrDefault(value) ?? new RefundEnum(value);
                }

                public override void Write(Utf8JsonWriter writer, RefundEnum value, JsonSerializerOptions jsonOptions)
                {
                    writer.WriteStringValue(RefundEnum.ToJsonValue(value));
                }
            }
        }

        /// <summary>
        /// Used to track whether Refund is set or not.
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<RefundEnum?> _RefundOption { get; private set; }

        /// <summary>
        /// Specifies how and from which balance account(s) to deduct the refund amount.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**, **deductAccordingToSplitRatio**
        /// </summary>
        /// <value>Specifies how and from which balance account(s) to deduct the refund amount.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**, **deductAccordingToSplitRatio**</value>
        [JsonPropertyName("refund")]
        public RefundEnum? Refund { get { return this._RefundOption; } set { this._RefundOption = new(value); } }

        /// <summary>
        /// Deducts the refund costs from the specified balance account.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**
        /// </summary>
        /// <value>Deducts the refund costs from the specified balance account.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**</value>
        [JsonConverter(typeof(RefundCostAllocationEnumJsonConverter))]
        public class RefundCostAllocationEnum: IEnum
        {
            /// <summary>
            /// Returns the value of the RefundCostAllocationEnum.
            /// </summary>
            public string? Value { get; set; }

            /// <summary>
            /// RefundCostAllocationEnum.DeductFromLiableAccount - deductFromLiableAccount
            /// </summary>
            public static readonly RefundCostAllocationEnum DeductFromLiableAccount = new("deductFromLiableAccount");

            /// <summary>
            /// RefundCostAllocationEnum.DeductFromOneBalanceAccount - deductFromOneBalanceAccount
            /// </summary>
            public static readonly RefundCostAllocationEnum DeductFromOneBalanceAccount = new("deductFromOneBalanceAccount");
        
            private RefundCostAllocationEnum(string? value)
            {
                Value = value;
            }

            /// <summary>
            /// Converts a string to a <see cref="RefundCostAllocationEnum"/> implicitly.
            /// </summary>
            /// <param name="value">The string value to convert. Defaults to null.</param>
            /// <returns>A new <see cref="RefundCostAllocationEnum"/> instance initialized with the string value.</returns>
            public static implicit operator RefundCostAllocationEnum?(string? value) => value == null ? null : new RefundCostAllocationEnum(value);
    
            /// <summary>
            /// Converts a <see cref="RefundCostAllocationEnum"/> instance to a string implicitly.
            /// </summary>
            /// <param name="option">The <see cref="RefundCostAllocationEnum"/> instance. Default to null.</param>
            /// <returns>String value of the <see cref="RefundCostAllocationEnum"/> instance./// </returns>
            public static implicit operator string?(RefundCostAllocationEnum? option) => option?.Value;
        
            public static bool operator ==(RefundCostAllocationEnum? left, RefundCostAllocationEnum? right) => string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);
    
            public static bool operator !=(RefundCostAllocationEnum? left, RefundCostAllocationEnum? right) => !string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);

            public override bool Equals(object? obj) => obj is RefundCostAllocationEnum other && string.Equals(Value, other.Value, StringComparison.OrdinalIgnoreCase);
    
            public override int GetHashCode() => Value?.GetHashCode() ?? 0;
        
            public override string ToString() => Value ?? string.Empty;
        
            /// <summary>
            /// Returns a <see cref="RefundCostAllocationEnum?"/>.
            /// </summary>
            /// <param name="value"></param>
            /// <returns><see cref="RefundCostAllocationEnum"/> or null.</returns>
            public static RefundCostAllocationEnum? FromStringOrDefault(string value)
            {
                return value switch {
                    "deductFromLiableAccount" => RefundCostAllocationEnum.DeductFromLiableAccount,
                    "deductFromOneBalanceAccount" => RefundCostAllocationEnum.DeductFromOneBalanceAccount,
                    _ => null,
                };
            }
    
            /// <summary>
            /// Converts the <see cref="RefundCostAllocationEnum"/> to the json value.
            /// </summary>
            /// <param name="value"><see cref="RefundCostAllocationEnum"/></param>
            /// <returns>String value of the enum.</returns>
            /// <exception cref="NotImplementedException"></exception>
            public static string? ToJsonValue(RefundCostAllocationEnum? value)
            {
                if (value == null)
                    return null;
            
                if (value == RefundCostAllocationEnum.DeductFromLiableAccount)
                    return "deductFromLiableAccount";
                
                if (value == RefundCostAllocationEnum.DeductFromOneBalanceAccount)
                    return "deductFromOneBalanceAccount";
                
                return null;
            }
            
            /// <summary>
            /// JsonConverter for writing RefundCostAllocationEnum.               
            /// </summary>
            public class RefundCostAllocationEnumJsonConverter : JsonConverter<RefundCostAllocationEnum>
            {
                public override RefundCostAllocationEnum? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions jsonOptions)
                {
                    string value = reader.GetString();
                    return value == null ? null : RefundCostAllocationEnum.FromStringOrDefault(value) ?? new RefundCostAllocationEnum(value);
                }

                public override void Write(Utf8JsonWriter writer, RefundCostAllocationEnum value, JsonSerializerOptions jsonOptions)
                {
                    writer.WriteStringValue(RefundCostAllocationEnum.ToJsonValue(value));
                }
            }
        }

        /// <summary>
        /// Used to track whether RefundCostAllocation is set or not.
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<RefundCostAllocationEnum?> _RefundCostAllocationOption { get; private set; }

        /// <summary>
        /// Deducts the refund costs from the specified balance account.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**
        /// </summary>
        /// <value>Deducts the refund costs from the specified balance account.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**</value>
        [JsonPropertyName("refundCostAllocation")]
        public RefundCostAllocationEnum? RefundCostAllocation { get { return this._RefundCostAllocationOption; } set { this._RefundCostAllocationOption = new(value); } }

        /// <summary>
        /// Books the amount left over after currency conversion to the specified balance account.  Possible values: **addToLiableAccount**, **addToOneBalanceAccount**.
        /// </summary>
        /// <value>Books the amount left over after currency conversion to the specified balance account.  Possible values: **addToLiableAccount**, **addToOneBalanceAccount**.</value>
        [JsonConverter(typeof(RemainderEnumJsonConverter))]
        public class RemainderEnum: IEnum
        {
            /// <summary>
            /// Returns the value of the RemainderEnum.
            /// </summary>
            public string? Value { get; set; }

            /// <summary>
            /// RemainderEnum.AddToLiableAccount - addToLiableAccount
            /// </summary>
            public static readonly RemainderEnum AddToLiableAccount = new("addToLiableAccount");

            /// <summary>
            /// RemainderEnum.AddToOneBalanceAccount - addToOneBalanceAccount
            /// </summary>
            public static readonly RemainderEnum AddToOneBalanceAccount = new("addToOneBalanceAccount");
        
            private RemainderEnum(string? value)
            {
                Value = value;
            }

            /// <summary>
            /// Converts a string to a <see cref="RemainderEnum"/> implicitly.
            /// </summary>
            /// <param name="value">The string value to convert. Defaults to null.</param>
            /// <returns>A new <see cref="RemainderEnum"/> instance initialized with the string value.</returns>
            public static implicit operator RemainderEnum?(string? value) => value == null ? null : new RemainderEnum(value);
    
            /// <summary>
            /// Converts a <see cref="RemainderEnum"/> instance to a string implicitly.
            /// </summary>
            /// <param name="option">The <see cref="RemainderEnum"/> instance. Default to null.</param>
            /// <returns>String value of the <see cref="RemainderEnum"/> instance./// </returns>
            public static implicit operator string?(RemainderEnum? option) => option?.Value;
        
            public static bool operator ==(RemainderEnum? left, RemainderEnum? right) => string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);
    
            public static bool operator !=(RemainderEnum? left, RemainderEnum? right) => !string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);

            public override bool Equals(object? obj) => obj is RemainderEnum other && string.Equals(Value, other.Value, StringComparison.OrdinalIgnoreCase);
    
            public override int GetHashCode() => Value?.GetHashCode() ?? 0;
        
            public override string ToString() => Value ?? string.Empty;
        
            /// <summary>
            /// Returns a <see cref="RemainderEnum?"/>.
            /// </summary>
            /// <param name="value"></param>
            /// <returns><see cref="RemainderEnum"/> or null.</returns>
            public static RemainderEnum? FromStringOrDefault(string value)
            {
                return value switch {
                    "addToLiableAccount" => RemainderEnum.AddToLiableAccount,
                    "addToOneBalanceAccount" => RemainderEnum.AddToOneBalanceAccount,
                    _ => null,
                };
            }
    
            /// <summary>
            /// Converts the <see cref="RemainderEnum"/> to the json value.
            /// </summary>
            /// <param name="value"><see cref="RemainderEnum"/></param>
            /// <returns>String value of the enum.</returns>
            /// <exception cref="NotImplementedException"></exception>
            public static string? ToJsonValue(RemainderEnum? value)
            {
                if (value == null)
                    return null;
            
                if (value == RemainderEnum.AddToLiableAccount)
                    return "addToLiableAccount";
                
                if (value == RemainderEnum.AddToOneBalanceAccount)
                    return "addToOneBalanceAccount";
                
                return null;
            }
            
            /// <summary>
            /// JsonConverter for writing RemainderEnum.               
            /// </summary>
            public class RemainderEnumJsonConverter : JsonConverter<RemainderEnum>
            {
                public override RemainderEnum? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions jsonOptions)
                {
                    string value = reader.GetString();
                    return value == null ? null : RemainderEnum.FromStringOrDefault(value) ?? new RemainderEnum(value);
                }

                public override void Write(Utf8JsonWriter writer, RemainderEnum value, JsonSerializerOptions jsonOptions)
                {
                    writer.WriteStringValue(RemainderEnum.ToJsonValue(value));
                }
            }
        }

        /// <summary>
        /// Used to track whether Remainder is set or not.
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<RemainderEnum?> _RemainderOption { get; private set; }

        /// <summary>
        /// Books the amount left over after currency conversion to the specified balance account.  Possible values: **addToLiableAccount**, **addToOneBalanceAccount**.
        /// </summary>
        /// <value>Books the amount left over after currency conversion to the specified balance account.  Possible values: **addToLiableAccount**, **addToOneBalanceAccount**.</value>
        [JsonPropertyName("remainder")]
        public RemainderEnum? Remainder { get { return this._RemainderOption; } set { this._RemainderOption = new(value); } }

        /// <summary>
        /// Deducts the scheme fee from the specified balance account.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.
        /// </summary>
        /// <value>Deducts the scheme fee from the specified balance account.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.</value>
        [JsonConverter(typeof(SchemeFeeEnumJsonConverter))]
        public class SchemeFeeEnum: IEnum
        {
            /// <summary>
            /// Returns the value of the SchemeFeeEnum.
            /// </summary>
            public string? Value { get; set; }

            /// <summary>
            /// SchemeFeeEnum.DeductFromLiableAccount - deductFromLiableAccount
            /// </summary>
            public static readonly SchemeFeeEnum DeductFromLiableAccount = new("deductFromLiableAccount");

            /// <summary>
            /// SchemeFeeEnum.DeductFromOneBalanceAccount - deductFromOneBalanceAccount
            /// </summary>
            public static readonly SchemeFeeEnum DeductFromOneBalanceAccount = new("deductFromOneBalanceAccount");
        
            private SchemeFeeEnum(string? value)
            {
                Value = value;
            }

            /// <summary>
            /// Converts a string to a <see cref="SchemeFeeEnum"/> implicitly.
            /// </summary>
            /// <param name="value">The string value to convert. Defaults to null.</param>
            /// <returns>A new <see cref="SchemeFeeEnum"/> instance initialized with the string value.</returns>
            public static implicit operator SchemeFeeEnum?(string? value) => value == null ? null : new SchemeFeeEnum(value);
    
            /// <summary>
            /// Converts a <see cref="SchemeFeeEnum"/> instance to a string implicitly.
            /// </summary>
            /// <param name="option">The <see cref="SchemeFeeEnum"/> instance. Default to null.</param>
            /// <returns>String value of the <see cref="SchemeFeeEnum"/> instance./// </returns>
            public static implicit operator string?(SchemeFeeEnum? option) => option?.Value;
        
            public static bool operator ==(SchemeFeeEnum? left, SchemeFeeEnum? right) => string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);
    
            public static bool operator !=(SchemeFeeEnum? left, SchemeFeeEnum? right) => !string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);

            public override bool Equals(object? obj) => obj is SchemeFeeEnum other && string.Equals(Value, other.Value, StringComparison.OrdinalIgnoreCase);
    
            public override int GetHashCode() => Value?.GetHashCode() ?? 0;
        
            public override string ToString() => Value ?? string.Empty;
        
            /// <summary>
            /// Returns a <see cref="SchemeFeeEnum?"/>.
            /// </summary>
            /// <param name="value"></param>
            /// <returns><see cref="SchemeFeeEnum"/> or null.</returns>
            public static SchemeFeeEnum? FromStringOrDefault(string value)
            {
                return value switch {
                    "deductFromLiableAccount" => SchemeFeeEnum.DeductFromLiableAccount,
                    "deductFromOneBalanceAccount" => SchemeFeeEnum.DeductFromOneBalanceAccount,
                    _ => null,
                };
            }
    
            /// <summary>
            /// Converts the <see cref="SchemeFeeEnum"/> to the json value.
            /// </summary>
            /// <param name="value"><see cref="SchemeFeeEnum"/></param>
            /// <returns>String value of the enum.</returns>
            /// <exception cref="NotImplementedException"></exception>
            public static string? ToJsonValue(SchemeFeeEnum? value)
            {
                if (value == null)
                    return null;
            
                if (value == SchemeFeeEnum.DeductFromLiableAccount)
                    return "deductFromLiableAccount";
                
                if (value == SchemeFeeEnum.DeductFromOneBalanceAccount)
                    return "deductFromOneBalanceAccount";
                
                return null;
            }
            
            /// <summary>
            /// JsonConverter for writing SchemeFeeEnum.               
            /// </summary>
            public class SchemeFeeEnumJsonConverter : JsonConverter<SchemeFeeEnum>
            {
                public override SchemeFeeEnum? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions jsonOptions)
                {
                    string value = reader.GetString();
                    return value == null ? null : SchemeFeeEnum.FromStringOrDefault(value) ?? new SchemeFeeEnum(value);
                }

                public override void Write(Utf8JsonWriter writer, SchemeFeeEnum value, JsonSerializerOptions jsonOptions)
                {
                    writer.WriteStringValue(SchemeFeeEnum.ToJsonValue(value));
                }
            }
        }

        /// <summary>
        /// Used to track whether SchemeFee is set or not.
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<SchemeFeeEnum?> _SchemeFeeOption { get; private set; }

        /// <summary>
        /// Deducts the scheme fee from the specified balance account.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.
        /// </summary>
        /// <value>Deducts the scheme fee from the specified balance account.  Possible values: **deductFromLiableAccount**, **deductFromOneBalanceAccount**.</value>
        [JsonPropertyName("schemeFee")]
        public SchemeFeeEnum? SchemeFee { get { return this._SchemeFeeOption; } set { this._SchemeFeeOption = new(value); } }

        /// <summary>
        /// Books the surcharge amount to the specified balance account.  Possible values: **addToLiableAccount**, **addToOneBalanceAccount**
        /// </summary>
        /// <value>Books the surcharge amount to the specified balance account.  Possible values: **addToLiableAccount**, **addToOneBalanceAccount**</value>
        [JsonConverter(typeof(SurchargeEnumJsonConverter))]
        public class SurchargeEnum: IEnum
        {
            /// <summary>
            /// Returns the value of the SurchargeEnum.
            /// </summary>
            public string? Value { get; set; }

            /// <summary>
            /// SurchargeEnum.AddToLiableAccount - addToLiableAccount
            /// </summary>
            public static readonly SurchargeEnum AddToLiableAccount = new("addToLiableAccount");

            /// <summary>
            /// SurchargeEnum.AddToOneBalanceAccount - addToOneBalanceAccount
            /// </summary>
            public static readonly SurchargeEnum AddToOneBalanceAccount = new("addToOneBalanceAccount");
        
            private SurchargeEnum(string? value)
            {
                Value = value;
            }

            /// <summary>
            /// Converts a string to a <see cref="SurchargeEnum"/> implicitly.
            /// </summary>
            /// <param name="value">The string value to convert. Defaults to null.</param>
            /// <returns>A new <see cref="SurchargeEnum"/> instance initialized with the string value.</returns>
            public static implicit operator SurchargeEnum?(string? value) => value == null ? null : new SurchargeEnum(value);
    
            /// <summary>
            /// Converts a <see cref="SurchargeEnum"/> instance to a string implicitly.
            /// </summary>
            /// <param name="option">The <see cref="SurchargeEnum"/> instance. Default to null.</param>
            /// <returns>String value of the <see cref="SurchargeEnum"/> instance./// </returns>
            public static implicit operator string?(SurchargeEnum? option) => option?.Value;
        
            public static bool operator ==(SurchargeEnum? left, SurchargeEnum? right) => string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);
    
            public static bool operator !=(SurchargeEnum? left, SurchargeEnum? right) => !string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);

            public override bool Equals(object? obj) => obj is SurchargeEnum other && string.Equals(Value, other.Value, StringComparison.OrdinalIgnoreCase);
    
            public override int GetHashCode() => Value?.GetHashCode() ?? 0;
        
            public override string ToString() => Value ?? string.Empty;
        
            /// <summary>
            /// Returns a <see cref="SurchargeEnum?"/>.
            /// </summary>
            /// <param name="value"></param>
            /// <returns><see cref="SurchargeEnum"/> or null.</returns>
            public static SurchargeEnum? FromStringOrDefault(string value)
            {
                return value switch {
                    "addToLiableAccount" => SurchargeEnum.AddToLiableAccount,
                    "addToOneBalanceAccount" => SurchargeEnum.AddToOneBalanceAccount,
                    _ => null,
                };
            }
    
            /// <summary>
            /// Converts the <see cref="SurchargeEnum"/> to the json value.
            /// </summary>
            /// <param name="value"><see cref="SurchargeEnum"/></param>
            /// <returns>String value of the enum.</returns>
            /// <exception cref="NotImplementedException"></exception>
            public static string? ToJsonValue(SurchargeEnum? value)
            {
                if (value == null)
                    return null;
            
                if (value == SurchargeEnum.AddToLiableAccount)
                    return "addToLiableAccount";
                
                if (value == SurchargeEnum.AddToOneBalanceAccount)
                    return "addToOneBalanceAccount";
                
                return null;
            }
            
            /// <summary>
            /// JsonConverter for writing SurchargeEnum.               
            /// </summary>
            public class SurchargeEnumJsonConverter : JsonConverter<SurchargeEnum>
            {
                public override SurchargeEnum? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions jsonOptions)
                {
                    string value = reader.GetString();
                    return value == null ? null : SurchargeEnum.FromStringOrDefault(value) ?? new SurchargeEnum(value);
                }

                public override void Write(Utf8JsonWriter writer, SurchargeEnum value, JsonSerializerOptions jsonOptions)
                {
                    writer.WriteStringValue(SurchargeEnum.ToJsonValue(value));
                }
            }
        }

        /// <summary>
        /// Used to track whether Surcharge is set or not.
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<SurchargeEnum?> _SurchargeOption { get; private set; }

        /// <summary>
        /// Books the surcharge amount to the specified balance account.  Possible values: **addToLiableAccount**, **addToOneBalanceAccount**
        /// </summary>
        /// <value>Books the surcharge amount to the specified balance account.  Possible values: **addToLiableAccount**, **addToOneBalanceAccount**</value>
        [JsonPropertyName("surcharge")]
        public SurchargeEnum? Surcharge { get { return this._SurchargeOption; } set { this._SurchargeOption = new(value); } }

        /// <summary>
        /// Books the tips (gratuity) to the specified balance account.  Possible values: **addToLiableAccount**, **addToOneBalanceAccount**.
        /// </summary>
        /// <value>Books the tips (gratuity) to the specified balance account.  Possible values: **addToLiableAccount**, **addToOneBalanceAccount**.</value>
        [JsonConverter(typeof(TipEnumJsonConverter))]
        public class TipEnum: IEnum
        {
            /// <summary>
            /// Returns the value of the TipEnum.
            /// </summary>
            public string? Value { get; set; }

            /// <summary>
            /// TipEnum.AddToLiableAccount - addToLiableAccount
            /// </summary>
            public static readonly TipEnum AddToLiableAccount = new("addToLiableAccount");

            /// <summary>
            /// TipEnum.AddToOneBalanceAccount - addToOneBalanceAccount
            /// </summary>
            public static readonly TipEnum AddToOneBalanceAccount = new("addToOneBalanceAccount");
        
            private TipEnum(string? value)
            {
                Value = value;
            }

            /// <summary>
            /// Converts a string to a <see cref="TipEnum"/> implicitly.
            /// </summary>
            /// <param name="value">The string value to convert. Defaults to null.</param>
            /// <returns>A new <see cref="TipEnum"/> instance initialized with the string value.</returns>
            public static implicit operator TipEnum?(string? value) => value == null ? null : new TipEnum(value);
    
            /// <summary>
            /// Converts a <see cref="TipEnum"/> instance to a string implicitly.
            /// </summary>
            /// <param name="option">The <see cref="TipEnum"/> instance. Default to null.</param>
            /// <returns>String value of the <see cref="TipEnum"/> instance./// </returns>
            public static implicit operator string?(TipEnum? option) => option?.Value;
        
            public static bool operator ==(TipEnum? left, TipEnum? right) => string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);
    
            public static bool operator !=(TipEnum? left, TipEnum? right) => !string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);

            public override bool Equals(object? obj) => obj is TipEnum other && string.Equals(Value, other.Value, StringComparison.OrdinalIgnoreCase);
    
            public override int GetHashCode() => Value?.GetHashCode() ?? 0;
        
            public override string ToString() => Value ?? string.Empty;
        
            /// <summary>
            /// Returns a <see cref="TipEnum?"/>.
            /// </summary>
            /// <param name="value"></param>
            /// <returns><see cref="TipEnum"/> or null.</returns>
            public static TipEnum? FromStringOrDefault(string value)
            {
                return value switch {
                    "addToLiableAccount" => TipEnum.AddToLiableAccount,
                    "addToOneBalanceAccount" => TipEnum.AddToOneBalanceAccount,
                    _ => null,
                };
            }
    
            /// <summary>
            /// Converts the <see cref="TipEnum"/> to the json value.
            /// </summary>
            /// <param name="value"><see cref="TipEnum"/></param>
            /// <returns>String value of the enum.</returns>
            /// <exception cref="NotImplementedException"></exception>
            public static string? ToJsonValue(TipEnum? value)
            {
                if (value == null)
                    return null;
            
                if (value == TipEnum.AddToLiableAccount)
                    return "addToLiableAccount";
                
                if (value == TipEnum.AddToOneBalanceAccount)
                    return "addToOneBalanceAccount";
                
                return null;
            }
            
            /// <summary>
            /// JsonConverter for writing TipEnum.               
            /// </summary>
            public class TipEnumJsonConverter : JsonConverter<TipEnum>
            {
                public override TipEnum? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions jsonOptions)
                {
                    string value = reader.GetString();
                    return value == null ? null : TipEnum.FromStringOrDefault(value) ?? new TipEnum(value);
                }

                public override void Write(Utf8JsonWriter writer, TipEnum value, JsonSerializerOptions jsonOptions)
                {
                    writer.WriteStringValue(TipEnum.ToJsonValue(value));
                }
            }
        }

        /// <summary>
        /// Used to track whether Tip is set or not.
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<TipEnum?> _TipOption { get; private set; }

        /// <summary>
        /// Books the tips (gratuity) to the specified balance account.  Possible values: **addToLiableAccount**, **addToOneBalanceAccount**.
        /// </summary>
        /// <value>Books the tips (gratuity) to the specified balance account.  Possible values: **addToLiableAccount**, **addToOneBalanceAccount**.</value>
        [JsonPropertyName("tip")]
        public TipEnum? Tip { get { return this._TipOption; } set { this._TipOption = new(value); } }

        /// <summary>
        /// Gets or Sets Commission
        /// </summary>
        [JsonPropertyName("commission")]
        public Commission Commission { get; set; }

        /// <summary>
        /// Used to track the state of AdditionalCommission
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<AdditionalCommission?> _AdditionalCommissionOption { get; private set; }

        /// <summary>
        /// Gets or Sets AdditionalCommission
        /// </summary>
        [JsonPropertyName("additionalCommission")]
        public AdditionalCommission? AdditionalCommission { get { return this._AdditionalCommissionOption; } set { this._AdditionalCommissionOption = new(value); } }

        /// <summary>
        /// Used to track the state of SplitLogicId
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> _SplitLogicIdOption { get; }

        /// <summary>
        /// Unique identifier of the collection of split instructions that are applied when the rule conditions are met.
        /// </summary>
        /// <value>Unique identifier of the collection of split instructions that are applied when the rule conditions are met.</value>
        [JsonPropertyName("splitLogicId")]
        public string? SplitLogicId { get { return this._SplitLogicIdOption; } }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class UpdateSplitConfigurationLogicRequest {\n");
            sb.Append("  Commission: ").Append(Commission).Append("\n");
            sb.Append("  AcquiringFees: ").Append(AcquiringFees).Append("\n");
            sb.Append("  AdditionalCommission: ").Append(AdditionalCommission).Append("\n");
            sb.Append("  AdyenCommission: ").Append(AdyenCommission).Append("\n");
            sb.Append("  AdyenFees: ").Append(AdyenFees).Append("\n");
            sb.Append("  AdyenMarkup: ").Append(AdyenMarkup).Append("\n");
            sb.Append("  Chargeback: ").Append(Chargeback).Append("\n");
            sb.Append("  ChargebackCostAllocation: ").Append(ChargebackCostAllocation).Append("\n");
            sb.Append("  Interchange: ").Append(Interchange).Append("\n");
            sb.Append("  PaymentFee: ").Append(PaymentFee).Append("\n");
            sb.Append("  Refund: ").Append(Refund).Append("\n");
            sb.Append("  RefundCostAllocation: ").Append(RefundCostAllocation).Append("\n");
            sb.Append("  Remainder: ").Append(Remainder).Append("\n");
            sb.Append("  SchemeFee: ").Append(SchemeFee).Append("\n");
            sb.Append("  SplitLogicId: ").Append(SplitLogicId).Append("\n");
            sb.Append("  Surcharge: ").Append(Surcharge).Append("\n");
            sb.Append("  Tip: ").Append(Tip).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="UpdateSplitConfigurationLogicRequest" />
    /// </summary>
    public class UpdateSplitConfigurationLogicRequestJsonConverter : JsonConverter<UpdateSplitConfigurationLogicRequest>
    {
        /// <summary>
        /// Deserializes json to <see cref="UpdateSplitConfigurationLogicRequest"/>.
        /// </summary>
        /// <param name="utf8JsonReader"><see cref="Utf8JsonReader"/></param>
        /// <param name="typeToConvert"><see cref="Type"/></param>
        /// <param name="jsonSerializerOptions">The <see cref="JsonSerializerOptions"/>, initialized from <see cref="HostConfiguration"/>.</param>
        /// <returns><see cref="UpdateSplitConfigurationLogicRequest"/></returns>
        /// <exception cref="JsonException"></exception>
        public override UpdateSplitConfigurationLogicRequest Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<Commission?> commission = default;
            Option<UpdateSplitConfigurationLogicRequest.AcquiringFeesEnum?> acquiringFees = default;
            Option<AdditionalCommission?> additionalCommission = default;
            Option<UpdateSplitConfigurationLogicRequest.AdyenCommissionEnum?> adyenCommission = default;
            Option<UpdateSplitConfigurationLogicRequest.AdyenFeesEnum?> adyenFees = default;
            Option<UpdateSplitConfigurationLogicRequest.AdyenMarkupEnum?> adyenMarkup = default;
            Option<UpdateSplitConfigurationLogicRequest.ChargebackEnum?> chargeback = default;
            Option<UpdateSplitConfigurationLogicRequest.ChargebackCostAllocationEnum?> chargebackCostAllocation = default;
            Option<UpdateSplitConfigurationLogicRequest.InterchangeEnum?> interchange = default;
            Option<UpdateSplitConfigurationLogicRequest.PaymentFeeEnum?> paymentFee = default;
            Option<UpdateSplitConfigurationLogicRequest.RefundEnum?> refund = default;
            Option<UpdateSplitConfigurationLogicRequest.RefundCostAllocationEnum?> refundCostAllocation = default;
            Option<UpdateSplitConfigurationLogicRequest.RemainderEnum?> remainder = default;
            Option<UpdateSplitConfigurationLogicRequest.SchemeFeeEnum?> schemeFee = default;
            Option<string?> splitLogicId = default;
            Option<UpdateSplitConfigurationLogicRequest.SurchargeEnum?> surcharge = default;
            Option<UpdateSplitConfigurationLogicRequest.TipEnum?> tip = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? jsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (jsonPropertyName)
                    {
                        case "commission":
                            commission = new Option<Commission?>(JsonSerializer.Deserialize<Commission>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "acquiringFees":
                            string? acquiringFeesRawValue = utf8JsonReader.GetString();
                            acquiringFees = new Option<UpdateSplitConfigurationLogicRequest.AcquiringFeesEnum?>(UpdateSplitConfigurationLogicRequest.AcquiringFeesEnum.FromStringOrDefault(acquiringFeesRawValue));
                            break;
                        case "additionalCommission":
                            additionalCommission = new Option<AdditionalCommission?>(JsonSerializer.Deserialize<AdditionalCommission>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "adyenCommission":
                            string? adyenCommissionRawValue = utf8JsonReader.GetString();
                            adyenCommission = new Option<UpdateSplitConfigurationLogicRequest.AdyenCommissionEnum?>(UpdateSplitConfigurationLogicRequest.AdyenCommissionEnum.FromStringOrDefault(adyenCommissionRawValue));
                            break;
                        case "adyenFees":
                            string? adyenFeesRawValue = utf8JsonReader.GetString();
                            adyenFees = new Option<UpdateSplitConfigurationLogicRequest.AdyenFeesEnum?>(UpdateSplitConfigurationLogicRequest.AdyenFeesEnum.FromStringOrDefault(adyenFeesRawValue));
                            break;
                        case "adyenMarkup":
                            string? adyenMarkupRawValue = utf8JsonReader.GetString();
                            adyenMarkup = new Option<UpdateSplitConfigurationLogicRequest.AdyenMarkupEnum?>(UpdateSplitConfigurationLogicRequest.AdyenMarkupEnum.FromStringOrDefault(adyenMarkupRawValue));
                            break;
                        case "chargeback":
                            string? chargebackRawValue = utf8JsonReader.GetString();
                            chargeback = new Option<UpdateSplitConfigurationLogicRequest.ChargebackEnum?>(UpdateSplitConfigurationLogicRequest.ChargebackEnum.FromStringOrDefault(chargebackRawValue));
                            break;
                        case "chargebackCostAllocation":
                            string? chargebackCostAllocationRawValue = utf8JsonReader.GetString();
                            chargebackCostAllocation = new Option<UpdateSplitConfigurationLogicRequest.ChargebackCostAllocationEnum?>(UpdateSplitConfigurationLogicRequest.ChargebackCostAllocationEnum.FromStringOrDefault(chargebackCostAllocationRawValue));
                            break;
                        case "interchange":
                            string? interchangeRawValue = utf8JsonReader.GetString();
                            interchange = new Option<UpdateSplitConfigurationLogicRequest.InterchangeEnum?>(UpdateSplitConfigurationLogicRequest.InterchangeEnum.FromStringOrDefault(interchangeRawValue));
                            break;
                        case "paymentFee":
                            string? paymentFeeRawValue = utf8JsonReader.GetString();
                            paymentFee = new Option<UpdateSplitConfigurationLogicRequest.PaymentFeeEnum?>(UpdateSplitConfigurationLogicRequest.PaymentFeeEnum.FromStringOrDefault(paymentFeeRawValue));
                            break;
                        case "refund":
                            string? refundRawValue = utf8JsonReader.GetString();
                            refund = new Option<UpdateSplitConfigurationLogicRequest.RefundEnum?>(UpdateSplitConfigurationLogicRequest.RefundEnum.FromStringOrDefault(refundRawValue));
                            break;
                        case "refundCostAllocation":
                            string? refundCostAllocationRawValue = utf8JsonReader.GetString();
                            refundCostAllocation = new Option<UpdateSplitConfigurationLogicRequest.RefundCostAllocationEnum?>(UpdateSplitConfigurationLogicRequest.RefundCostAllocationEnum.FromStringOrDefault(refundCostAllocationRawValue));
                            break;
                        case "remainder":
                            string? remainderRawValue = utf8JsonReader.GetString();
                            remainder = new Option<UpdateSplitConfigurationLogicRequest.RemainderEnum?>(UpdateSplitConfigurationLogicRequest.RemainderEnum.FromStringOrDefault(remainderRawValue));
                            break;
                        case "schemeFee":
                            string? schemeFeeRawValue = utf8JsonReader.GetString();
                            schemeFee = new Option<UpdateSplitConfigurationLogicRequest.SchemeFeeEnum?>(UpdateSplitConfigurationLogicRequest.SchemeFeeEnum.FromStringOrDefault(schemeFeeRawValue));
                            break;
                        case "splitLogicId":
                            splitLogicId = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "surcharge":
                            string? surchargeRawValue = utf8JsonReader.GetString();
                            surcharge = new Option<UpdateSplitConfigurationLogicRequest.SurchargeEnum?>(UpdateSplitConfigurationLogicRequest.SurchargeEnum.FromStringOrDefault(surchargeRawValue));
                            break;
                        case "tip":
                            string? tipRawValue = utf8JsonReader.GetString();
                            tip = new Option<UpdateSplitConfigurationLogicRequest.TipEnum?>(UpdateSplitConfigurationLogicRequest.TipEnum.FromStringOrDefault(tipRawValue));
                            break;
                        default:
                            break;
                    }
                }
            }
            
            if (!commission.IsSet)
                throw new ArgumentException("Property is required for class UpdateSplitConfigurationLogicRequest.", nameof(commission));

            if (commission.IsSet && commission.Value == null)
                throw new ArgumentNullException(nameof(commission), "Property is not nullable for class UpdateSplitConfigurationLogicRequest.");

            if (acquiringFees.IsSet && acquiringFees.Value == null)
                throw new ArgumentNullException(nameof(acquiringFees), "Property is not nullable for class UpdateSplitConfigurationLogicRequest.");

            if (additionalCommission.IsSet && additionalCommission.Value == null)
                throw new ArgumentNullException(nameof(additionalCommission), "Property is not nullable for class UpdateSplitConfigurationLogicRequest.");

            if (adyenCommission.IsSet && adyenCommission.Value == null)
                throw new ArgumentNullException(nameof(adyenCommission), "Property is not nullable for class UpdateSplitConfigurationLogicRequest.");

            if (adyenFees.IsSet && adyenFees.Value == null)
                throw new ArgumentNullException(nameof(adyenFees), "Property is not nullable for class UpdateSplitConfigurationLogicRequest.");

            if (adyenMarkup.IsSet && adyenMarkup.Value == null)
                throw new ArgumentNullException(nameof(adyenMarkup), "Property is not nullable for class UpdateSplitConfigurationLogicRequest.");

            if (chargeback.IsSet && chargeback.Value == null)
                throw new ArgumentNullException(nameof(chargeback), "Property is not nullable for class UpdateSplitConfigurationLogicRequest.");

            if (chargebackCostAllocation.IsSet && chargebackCostAllocation.Value == null)
                throw new ArgumentNullException(nameof(chargebackCostAllocation), "Property is not nullable for class UpdateSplitConfigurationLogicRequest.");

            if (interchange.IsSet && interchange.Value == null)
                throw new ArgumentNullException(nameof(interchange), "Property is not nullable for class UpdateSplitConfigurationLogicRequest.");

            if (paymentFee.IsSet && paymentFee.Value == null)
                throw new ArgumentNullException(nameof(paymentFee), "Property is not nullable for class UpdateSplitConfigurationLogicRequest.");

            if (refund.IsSet && refund.Value == null)
                throw new ArgumentNullException(nameof(refund), "Property is not nullable for class UpdateSplitConfigurationLogicRequest.");

            if (refundCostAllocation.IsSet && refundCostAllocation.Value == null)
                throw new ArgumentNullException(nameof(refundCostAllocation), "Property is not nullable for class UpdateSplitConfigurationLogicRequest.");

            if (remainder.IsSet && remainder.Value == null)
                throw new ArgumentNullException(nameof(remainder), "Property is not nullable for class UpdateSplitConfigurationLogicRequest.");

            if (schemeFee.IsSet && schemeFee.Value == null)
                throw new ArgumentNullException(nameof(schemeFee), "Property is not nullable for class UpdateSplitConfigurationLogicRequest.");

            if (splitLogicId.IsSet && splitLogicId.Value == null)
                throw new ArgumentNullException(nameof(splitLogicId), "Property is not nullable for class UpdateSplitConfigurationLogicRequest.");

            if (surcharge.IsSet && surcharge.Value == null)
                throw new ArgumentNullException(nameof(surcharge), "Property is not nullable for class UpdateSplitConfigurationLogicRequest.");

            if (tip.IsSet && tip.Value == null)
                throw new ArgumentNullException(nameof(tip), "Property is not nullable for class UpdateSplitConfigurationLogicRequest.");

            return new UpdateSplitConfigurationLogicRequest(commission.Value!, acquiringFees, additionalCommission, adyenCommission, adyenFees, adyenMarkup, chargeback, chargebackCostAllocation, interchange, paymentFee, refund, refundCostAllocation, remainder, schemeFee, splitLogicId, surcharge, tip);
        }

        /// <summary>
        /// Serializes a <see cref="UpdateSplitConfigurationLogicRequest"/>.
        /// </summary>
        /// <param name="writer"><see cref="Utf8JsonWriter"/></param>
        /// <param name="updateSplitConfigurationLogicRequest"></param>
        /// <param name="jsonSerializerOptions"><see cref="JsonSerializerOptions"/></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, UpdateSplitConfigurationLogicRequest updateSplitConfigurationLogicRequest, JsonSerializerOptions jsonSerializerOptions)
        {
            
            writer.WriteStartObject();
            
            WriteProperties(writer, updateSplitConfigurationLogicRequest, jsonSerializerOptions);
            
            writer.WriteEndObject();
            
        }

        /// <summary>
        /// Serializes the properties of <see cref="UpdateSplitConfigurationLogicRequest"/>.
        /// </summary>
        /// <param name="writer"><see creft="Utf8JsonWriter"/></param>
        /// <param name="updateSplitConfigurationLogicRequest"></param>
        /// <param name="jsonSerializerOptions"><see cref="JsonSerializerOptions"/></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, UpdateSplitConfigurationLogicRequest updateSplitConfigurationLogicRequest, JsonSerializerOptions jsonSerializerOptions)
        {
            /*
            if (updateSplitConfigurationLogicRequest.Commission == null)
                throw new ArgumentNullException(nameof(updateSplitConfigurationLogicRequest.Commission), "Property is required for class UpdateSplitConfigurationLogicRequest.");

            if (updateSplitConfigurationLogicRequest._AdditionalCommissionOption.IsSet && updateSplitConfigurationLogicRequest.AdditionalCommission == null)
                throw new ArgumentNullException(nameof(updateSplitConfigurationLogicRequest.AdditionalCommission), "Property is required for class UpdateSplitConfigurationLogicRequest.");

            if (updateSplitConfigurationLogicRequest._SplitLogicIdOption.IsSet && updateSplitConfigurationLogicRequest.SplitLogicId == null)
                throw new ArgumentNullException(nameof(updateSplitConfigurationLogicRequest.SplitLogicId), "Property is required for class UpdateSplitConfigurationLogicRequest.");

            */
            
            writer.WritePropertyName("commission");
            JsonSerializer.Serialize(writer, updateSplitConfigurationLogicRequest.Commission, jsonSerializerOptions);
            if (updateSplitConfigurationLogicRequest._AcquiringFeesOption.IsSet && updateSplitConfigurationLogicRequest.AcquiringFees != null) 
            {
                string? acquiringFeesRawValue = UpdateSplitConfigurationLogicRequest.AcquiringFeesEnum.ToJsonValue(updateSplitConfigurationLogicRequest._AcquiringFeesOption.Value!.Value);
                writer.WriteString("acquiringFees", acquiringFeesRawValue);
            }
            
            if (updateSplitConfigurationLogicRequest._AdditionalCommissionOption.IsSet)
            {
                writer.WritePropertyName("additionalCommission");
                JsonSerializer.Serialize(writer, updateSplitConfigurationLogicRequest.AdditionalCommission, jsonSerializerOptions);
            }
            if (updateSplitConfigurationLogicRequest._AdyenCommissionOption.IsSet && updateSplitConfigurationLogicRequest.AdyenCommission != null) 
            {
                string? adyenCommissionRawValue = UpdateSplitConfigurationLogicRequest.AdyenCommissionEnum.ToJsonValue(updateSplitConfigurationLogicRequest._AdyenCommissionOption.Value!.Value);
                writer.WriteString("adyenCommission", adyenCommissionRawValue);
            }
            
            if (updateSplitConfigurationLogicRequest._AdyenFeesOption.IsSet && updateSplitConfigurationLogicRequest.AdyenFees != null) 
            {
                string? adyenFeesRawValue = UpdateSplitConfigurationLogicRequest.AdyenFeesEnum.ToJsonValue(updateSplitConfigurationLogicRequest._AdyenFeesOption.Value!.Value);
                writer.WriteString("adyenFees", adyenFeesRawValue);
            }
            
            if (updateSplitConfigurationLogicRequest._AdyenMarkupOption.IsSet && updateSplitConfigurationLogicRequest.AdyenMarkup != null) 
            {
                string? adyenMarkupRawValue = UpdateSplitConfigurationLogicRequest.AdyenMarkupEnum.ToJsonValue(updateSplitConfigurationLogicRequest._AdyenMarkupOption.Value!.Value);
                writer.WriteString("adyenMarkup", adyenMarkupRawValue);
            }
            
            if (updateSplitConfigurationLogicRequest._ChargebackOption.IsSet && updateSplitConfigurationLogicRequest.Chargeback != null) 
            {
                string? chargebackRawValue = UpdateSplitConfigurationLogicRequest.ChargebackEnum.ToJsonValue(updateSplitConfigurationLogicRequest._ChargebackOption.Value!.Value);
                writer.WriteString("chargeback", chargebackRawValue);
            }
            
            if (updateSplitConfigurationLogicRequest._ChargebackCostAllocationOption.IsSet && updateSplitConfigurationLogicRequest.ChargebackCostAllocation != null) 
            {
                string? chargebackCostAllocationRawValue = UpdateSplitConfigurationLogicRequest.ChargebackCostAllocationEnum.ToJsonValue(updateSplitConfigurationLogicRequest._ChargebackCostAllocationOption.Value!.Value);
                writer.WriteString("chargebackCostAllocation", chargebackCostAllocationRawValue);
            }
            
            if (updateSplitConfigurationLogicRequest._InterchangeOption.IsSet && updateSplitConfigurationLogicRequest.Interchange != null) 
            {
                string? interchangeRawValue = UpdateSplitConfigurationLogicRequest.InterchangeEnum.ToJsonValue(updateSplitConfigurationLogicRequest._InterchangeOption.Value!.Value);
                writer.WriteString("interchange", interchangeRawValue);
            }
            
            if (updateSplitConfigurationLogicRequest._PaymentFeeOption.IsSet && updateSplitConfigurationLogicRequest.PaymentFee != null) 
            {
                string? paymentFeeRawValue = UpdateSplitConfigurationLogicRequest.PaymentFeeEnum.ToJsonValue(updateSplitConfigurationLogicRequest._PaymentFeeOption.Value!.Value);
                writer.WriteString("paymentFee", paymentFeeRawValue);
            }
            
            if (updateSplitConfigurationLogicRequest._RefundOption.IsSet && updateSplitConfigurationLogicRequest.Refund != null) 
            {
                string? refundRawValue = UpdateSplitConfigurationLogicRequest.RefundEnum.ToJsonValue(updateSplitConfigurationLogicRequest._RefundOption.Value!.Value);
                writer.WriteString("refund", refundRawValue);
            }
            
            if (updateSplitConfigurationLogicRequest._RefundCostAllocationOption.IsSet && updateSplitConfigurationLogicRequest.RefundCostAllocation != null) 
            {
                string? refundCostAllocationRawValue = UpdateSplitConfigurationLogicRequest.RefundCostAllocationEnum.ToJsonValue(updateSplitConfigurationLogicRequest._RefundCostAllocationOption.Value!.Value);
                writer.WriteString("refundCostAllocation", refundCostAllocationRawValue);
            }
            
            if (updateSplitConfigurationLogicRequest._RemainderOption.IsSet && updateSplitConfigurationLogicRequest.Remainder != null) 
            {
                string? remainderRawValue = UpdateSplitConfigurationLogicRequest.RemainderEnum.ToJsonValue(updateSplitConfigurationLogicRequest._RemainderOption.Value!.Value);
                writer.WriteString("remainder", remainderRawValue);
            }
            
            if (updateSplitConfigurationLogicRequest._SchemeFeeOption.IsSet && updateSplitConfigurationLogicRequest.SchemeFee != null) 
            {
                string? schemeFeeRawValue = UpdateSplitConfigurationLogicRequest.SchemeFeeEnum.ToJsonValue(updateSplitConfigurationLogicRequest._SchemeFeeOption.Value!.Value);
                writer.WriteString("schemeFee", schemeFeeRawValue);
            }
            
            if (updateSplitConfigurationLogicRequest._SplitLogicIdOption.IsSet)
                writer.WriteString("splitLogicId", updateSplitConfigurationLogicRequest.SplitLogicId);

            if (updateSplitConfigurationLogicRequest._SurchargeOption.IsSet && updateSplitConfigurationLogicRequest.Surcharge != null) 
            {
                string? surchargeRawValue = UpdateSplitConfigurationLogicRequest.SurchargeEnum.ToJsonValue(updateSplitConfigurationLogicRequest._SurchargeOption.Value!.Value);
                writer.WriteString("surcharge", surchargeRawValue);
            }
            
            if (updateSplitConfigurationLogicRequest._TipOption.IsSet && updateSplitConfigurationLogicRequest.Tip != null) 
            {
                string? tipRawValue = UpdateSplitConfigurationLogicRequest.TipEnum.ToJsonValue(updateSplitConfigurationLogicRequest._TipOption.Value!.Value);
                writer.WriteString("tip", tipRawValue);
            }
        }
    }
}
