// <auto-generated>
/*
 * Management API
 *
 * Configure and manage your Adyen company and merchant accounts, stores, and payment terminals. ## Authentication Each request to the Management API must be signed with an API key. [Generate your API key](https://docs.adyen.com/development-resources/api-credentials#generate-api-key) in the Customer Area and then set this key to the `X-API-Key` header value.  To access the live endpoints, you need to generate a new API key in your live Customer Area. ## Versioning  Management API handles versioning as part of the endpoint URL. For example, to send a request to this version of the `/companies/{companyId}/webhooks` endpoint, use:  ```text https://management-test.adyen.com/v3/companies/{companyId}/webhooks ```  ## Going live  To access the live endpoints, you need an API key from your live Customer Area. Use this API key to make requests to:  ```text https://management-live.adyen.com/v3 ```  ## Release notes Have a look at the [release notes](https://docs.adyen.com/release-notes/management-api) to find out what changed in this version!
 *
 * The version of the OpenAPI document: 3
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using Adyen.Core;
using Adyen.Core.Auth;
using Adyen.Core.Client;
using Adyen.Core.Client.Extensions;
using Adyen.Core.Options;
using Adyen.Management.Client;
using Adyen.Management.Models;
using System.Diagnostics.CodeAnalysis;

namespace Adyen.Management.Services
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints.
    /// This class is registered as transient.
    /// </summary>
    public interface IWebhooksMerchantLevelService : IAdyenApiService
    {
        /// <summary>
        /// The class containing the events.
        /// </summary>
        WebhooksMerchantLevelServiceEvents? Events { get; }

        /// <summary>
        /// Generate an HMAC key
        /// </summary>
        /// <remarks>
        /// Returns an [HMAC key](https://en.wikipedia.org/wiki/HMAC) for the webhook identified in the path. This key allows you to check the integrity and the origin of the notifications you receive.By creating an HMAC key, you start receiving [HMAC-signed notifications](https://docs.adyen.com/development-resources/webhooks/verify-hmac-signatures#enable-hmac-signatures) from Adyen. Find out more about how to [verify HMAC signatures](https://docs.adyen.com/development-resources/webhooks/verify-hmac-signatures).  To make this request, your API credential must have the following [roles](https://docs.adyen.com/development-resources/api-credentials#api-permissions): * Management API—Webhooks read and write
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call.</exception>
        /// <param name="merchantId">The unique identifier of the merchant account.</param>
        /// <param name="webhookId"></param>
        /// <param name="requestOptions"><see cref="RequestOptions"/>.</param>
        /// <param name="cancellationToken"><see cref="CancellationToken"/>.</param>
        /// <returns><see cref="Task"/> of <see cref="IGenerateHmacKeyApiResponse"/>.</returns>
        Task<IGenerateHmacKeyApiResponse> GenerateHmacKeyAsync(string merchantId, string webhookId,  RequestOptions? requestOptions = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get a webhook
        /// </summary>
        /// <remarks>
        /// Returns the configuration for the webhook identified in the path.  To make this request, your API credential must have one of the following [roles](https://docs.adyen.com/development-resources/api-credentials#api-permissions): * Management API—Webhooks read * Management API—Webhooks read and write
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call.</exception>
        /// <param name="merchantId">The unique identifier of the merchant account.</param>
        /// <param name="webhookId">Unique identifier of the webhook configuration.</param>
        /// <param name="requestOptions"><see cref="RequestOptions"/>.</param>
        /// <param name="cancellationToken"><see cref="CancellationToken"/>.</param>
        /// <returns><see cref="Task"/> of <see cref="IGetWebhookApiResponse"/>.</returns>
        Task<IGetWebhookApiResponse> GetWebhookAsync(string merchantId, string webhookId,  RequestOptions? requestOptions = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List all webhooks
        /// </summary>
        /// <remarks>
        /// Lists all webhook configurations for the merchant account.  &gt; This call does not return webhook configurations for the company account to which the specified merchant account belongs. You can see these in your Customer Area under **Developers** &gt; **Webhooks**.  To make this request, your API credential must have one of the following [roles](https://docs.adyen.com/development-resources/api-credentials#api-permissions): * Management API—Webhooks read * Management API—Webhooks read and write
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call.</exception>
        /// <param name="merchantId">The unique identifier of the merchant account.</param>
        /// <param name="pageNumber">The number of the page to fetch.</param>
        /// <param name="pageSize">The number of items to have on a page, maximum 100. The default is 10 items on a page.</param>
        /// <param name="requestOptions"><see cref="RequestOptions"/>.</param>
        /// <param name="cancellationToken"><see cref="CancellationToken"/>.</param>
        /// <returns><see cref="Task"/> of <see cref="IListAllWebhooksApiResponse"/>.</returns>
        Task<IListAllWebhooksApiResponse> ListAllWebhooksAsync(string merchantId, Option<int> pageNumber = default, Option<int> pageSize = default,  RequestOptions? requestOptions = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Remove a webhook
        /// </summary>
        /// <remarks>
        /// Remove the configuration for the webhook identified in the path.  To make this request, your API credential must have the following [roles](https://docs.adyen.com/development-resources/api-credentials#api-permissions): * Management API—Webhooks read and write
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call.</exception>
        /// <param name="merchantId">The unique identifier of the merchant account.</param>
        /// <param name="webhookId">Unique identifier of the webhook configuration.</param>
        /// <param name="requestOptions"><see cref="RequestOptions"/>.</param>
        /// <param name="cancellationToken"><see cref="CancellationToken"/>.</param>
        /// <returns><see cref="Task"/> of <see cref="IRemoveWebhookApiResponse"/>.</returns>
        Task<IRemoveWebhookApiResponse> RemoveWebhookAsync(string merchantId, string webhookId,  RequestOptions? requestOptions = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Set up a webhook
        /// </summary>
        /// <remarks>
        /// Subscribe to receive webhook notifications about events related to your merchant account. You can add basic authentication to make sure the data is secure.  To make this request, your API credential must have the following [roles](https://docs.adyen.com/development-resources/api-credentials#api-permissions): * Management API—Webhooks read and write
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call.</exception>
        /// <param name="merchantId">The unique identifier of the merchant account.</param>
        /// <param name="createMerchantWebhookRequest"></param>
        /// <param name="requestOptions"><see cref="RequestOptions"/>.</param>
        /// <param name="cancellationToken"><see cref="CancellationToken"/>.</param>
        /// <returns><see cref="Task"/> of <see cref="ISetUpWebhookApiResponse"/>.</returns>
        Task<ISetUpWebhookApiResponse> SetUpWebhookAsync(string merchantId, CreateMerchantWebhookRequest createMerchantWebhookRequest,  RequestOptions? requestOptions = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Test a webhook
        /// </summary>
        /// <remarks>
        /// Sends sample notifications to test if the webhook is set up correctly.  We send four test notifications for each event code you choose. They cover success and failure scenarios for the hard-coded currencies EUR and GBP, regardless of the currencies configured in the merchant accounts. For custom notifications, we only send the specified custom notification.  The response describes the result of the test. The &#x60;status&#x60; field tells you if the test was successful or not. You can use the other fields to troubleshoot unsuccessful tests.  To make this request, your API credential must have the following [roles](https://docs.adyen.com/development-resources/api-credentials#api-permissions): * Management API—Webhooks read and write
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call.</exception>
        /// <param name="merchantId">The unique identifier of the merchant account.</param>
        /// <param name="webhookId">Unique identifier of the webhook configuration.</param>
        /// <param name="testWebhookRequest"></param>
        /// <param name="requestOptions"><see cref="RequestOptions"/>.</param>
        /// <param name="cancellationToken"><see cref="CancellationToken"/>.</param>
        /// <returns><see cref="Task"/> of <see cref="ITestWebhookApiResponse"/>.</returns>
        Task<ITestWebhookApiResponse> TestWebhookAsync(string merchantId, string webhookId, TestWebhookRequest testWebhookRequest,  RequestOptions? requestOptions = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update a webhook
        /// </summary>
        /// <remarks>
        /// Make changes to the configuration of the webhook identified in the path. The request contains the new values you want to have in the webhook configuration. The response contains the full configuration for the webhook, which includes the new values from the request.  To make this request, your API credential must have the following [roles](https://docs.adyen.com/development-resources/api-credentials#api-permissions): * Management API—Webhooks read and write
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call.</exception>
        /// <param name="merchantId">The unique identifier of the merchant account.</param>
        /// <param name="webhookId">Unique identifier of the webhook configuration.</param>
        /// <param name="updateMerchantWebhookRequest"></param>
        /// <param name="requestOptions"><see cref="RequestOptions"/>.</param>
        /// <param name="cancellationToken"><see cref="CancellationToken"/>.</param>
        /// <returns><see cref="Task"/> of <see cref="IUpdateWebhookApiResponse"/>.</returns>
        Task<IUpdateWebhookApiResponse> UpdateWebhookAsync(string merchantId, string webhookId, UpdateMerchantWebhookRequest updateMerchantWebhookRequest,  RequestOptions? requestOptions = default, System.Threading.CancellationToken cancellationToken = default);

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints.
    /// </summary>
    public class WebhooksMerchantLevelServiceEvents
    {
        /// <summary>
        /// The event raised after the server response.
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGenerateHmacKey;

        /// <summary>
        /// The event raised after an error querying the server.
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGenerateHmacKey;

        internal void ExecuteOnGenerateHmacKey(WebhooksCompanyLevelService.GenerateHmacKeyApiResponse apiResponse)
        {
            OnGenerateHmacKey?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGenerateHmacKey(Exception exception)
        {
            OnErrorGenerateHmacKey?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response.
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetWebhook;

        /// <summary>
        /// The event raised after an error querying the server.
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetWebhook;

        internal void ExecuteOnGetWebhook(WebhooksCompanyLevelService.GetWebhookApiResponse apiResponse)
        {
            OnGetWebhook?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetWebhook(Exception exception)
        {
            OnErrorGetWebhook?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response.
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnListAllWebhooks;

        /// <summary>
        /// The event raised after an error querying the server.
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorListAllWebhooks;

        internal void ExecuteOnListAllWebhooks(WebhooksCompanyLevelService.ListAllWebhooksApiResponse apiResponse)
        {
            OnListAllWebhooks?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorListAllWebhooks(Exception exception)
        {
            OnErrorListAllWebhooks?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response.
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnRemoveWebhook;

        /// <summary>
        /// The event raised after an error querying the server.
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorRemoveWebhook;

        internal void ExecuteOnRemoveWebhook(WebhooksCompanyLevelService.RemoveWebhookApiResponse apiResponse)
        {
            OnRemoveWebhook?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorRemoveWebhook(Exception exception)
        {
            OnErrorRemoveWebhook?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response.
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSetUpWebhook;

        /// <summary>
        /// The event raised after an error querying the server.
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSetUpWebhook;

        internal void ExecuteOnSetUpWebhook(WebhooksCompanyLevelService.SetUpWebhookApiResponse apiResponse)
        {
            OnSetUpWebhook?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSetUpWebhook(Exception exception)
        {
            OnErrorSetUpWebhook?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response.
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnTestWebhook;

        /// <summary>
        /// The event raised after an error querying the server.
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorTestWebhook;

        internal void ExecuteOnTestWebhook(WebhooksCompanyLevelService.TestWebhookApiResponse apiResponse)
        {
            OnTestWebhook?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorTestWebhook(Exception exception)
        {
            OnErrorTestWebhook?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response.
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnUpdateWebhook;

        /// <summary>
        /// The event raised after an error querying the server.
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorUpdateWebhook;

        internal void ExecuteOnUpdateWebhook(WebhooksCompanyLevelService.UpdateWebhookApiResponse apiResponse)
        {
            OnUpdateWebhook?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUpdateWebhook(Exception exception)
        {
            OnErrorUpdateWebhook?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints.
    /// </summary>
    public sealed partial class WebhooksMerchantLevelService : IWebhooksMerchantLevelService
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory.
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger.
        /// </summary>
        public ILogger<WebhooksMerchantLevelService> Logger { get; }

        /// <summary>
        /// The HttpClient.
        /// </summary>
        public System.Net.Http.HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events.
        /// </summary>
        public WebhooksMerchantLevelServiceEvents? Events { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>.
        /// </summary>
        public ITokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="WebhooksMerchantLevelService"/> class.
        /// </summary>
        public WebhooksMerchantLevelService(AdyenOptionsProvider adyenOptionsProvider, ILogger<WebhooksMerchantLevelService> logger, ILoggerFactory loggerFactory, System.Net.Http.HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, ITokenProvider<ApiKeyToken> apiKeyProvider, WebhooksMerchantLevelServiceEvents webhooksMerchantLevelServiceEvents = null)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = logger == null ? LoggerFactory.CreateLogger<WebhooksMerchantLevelService>() : logger;
            // Set BaseAddress if it's not set.
            if (httpClient.BaseAddress == null)
                httpClient.BaseAddress = new Uri(UrlBuilderExtensions.ConstructHostUrl(adyenOptionsProvider.Options, "https://management-test.adyen.com/v3"));
            HttpClient = httpClient;
            Events = webhooksMerchantLevelServiceEvents;
            ApiKeyProvider = apiKeyProvider;
        }
        
        /// <summary>
        /// Generate an HMAC key Returns an [HMAC key](https://en.wikipedia.org/wiki/HMAC) for the webhook identified in the path. This key allows you to check the integrity and the origin of the notifications you receive.By creating an HMAC key, you start receiving [HMAC-signed notifications](https://docs.adyen.com/development-resources/webhooks/verify-hmac-signatures#enable-hmac-signatures) from Adyen. Find out more about how to [verify HMAC signatures](https://docs.adyen.com/development-resources/webhooks/verify-hmac-signatures).  To make this request, your API credential must have the following [roles](https://docs.adyen.com/development-resources/api-credentials#api-permissions): * Management API—Webhooks read and write
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call.</exception>
        /// <param name="merchantId">The unique identifier of the merchant account.</param>
        /// <param name="webhookId"></param>
        /// <param name="requestOptions"><see cref="RequestOptions"/>.</param>
        /// <param name="cancellationToken"><see cref="CancellationToken"/>.</param>
        /// <returns><see cref="Task"/> of <see cref="IGenerateHmacKeyApiResponse"/> - If 200 OK response, wraps the <see cref="Adyen.Management.Models.GenerateHmacKeyResponse"/> when `TryDeserializeOk(...)` is called.</returns>
        public async Task<IGenerateHmacKeyApiResponse> GenerateHmacKeyAsync(string merchantId, string webhookId,  RequestOptions? requestOptions = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilder = new UriBuilder();

            try
            {
                using (HttpRequestMessage httpRequestMessage = new HttpRequestMessage())
                {
                    uriBuilder.Host = HttpClient.BaseAddress!.Host;
                    uriBuilder.Port = HttpClient.BaseAddress.Port;
                    uriBuilder.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilder.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/merchants/{merchantId}/webhooks/{webhookId}/generateHmac"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/merchants/{merchantId}/webhooks/{webhookId}/generateHmac");
                    uriBuilder.Path = uriBuilder.Path.Replace("%7BmerchantId%7D", Uri.EscapeDataString(merchantId.ToString()));
                    uriBuilder.Path = uriBuilder.Path.Replace("%7BwebhookId%7D", Uri.EscapeDataString(webhookId.ToString()));

                    // Adds headers to the HttpRequestMessage header, these can be set in the RequestOptions (Idempotency-Key etc.)
                    requestOptions?.AddHeadersToHttpRequestMessage(httpRequestMessage);

                    // Add authorization token to the HttpRequestMessage header
                    ApiKeyProvider.Get().AddTokenToHttpRequestMessageHeader(httpRequestMessage);
                    
                    httpRequestMessage.RequestUri = uriBuilder.Uri;

                    string[] accepts = new string[] {
                        "application/json"
                    };

                    string? accept = ClientUtils.SelectHeaderAccept(accepts);

                    if (accept != null)
                        httpRequestMessage.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(accept));
#if NET462 || NETSTANDARD2_0
                    httpRequestMessage.Method = new HttpMethod("POST");
#else
                    httpRequestMessage.Method = HttpMethod.Post;
#endif

                    DateTime requestedAt = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessage = await HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<WebhooksCompanyLevelService.GenerateHmacKeyApiResponse> apiResponseLogger = LoggerFactory.CreateLogger<WebhooksCompanyLevelService.GenerateHmacKeyApiResponse>();
                        WebhooksCompanyLevelService.GenerateHmacKeyApiResponse apiResponse;

                        switch ((int)httpResponseMessage.StatusCode) {
                            default: {
#if NET462 || NETSTANDARD2_0
                                // `HttpContent.ReadAsStringAsync(cancellationToken)` doesn't exist in .NET Standard 2.0. Instead, we cancel one-level above in `HttpClient.SendAsync(httpRequestMessage, cancellationToken)`.
                                string responseContent = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(false);
#else
                                string responseContent = await httpResponseMessage.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
#endif
                                apiResponse = new(apiResponseLogger, httpRequestMessage, httpResponseMessage, responseContent, "/merchants/{merchantId}/webhooks/{webhookId}/generateHmac", requestedAt, _jsonSerializerOptions);

                                break;
                            }
                        }
                        
                        Events?.ExecuteOnGenerateHmacKey(apiResponse);
                        return apiResponse;
                    }
                }
            }
            catch(Exception exception)
            {
                Events?.ExecuteOnErrorGenerateHmacKey(exception);
                throw;
            }
        }
        /// <summary>
        /// Get a webhook Returns the configuration for the webhook identified in the path.  To make this request, your API credential must have one of the following [roles](https://docs.adyen.com/development-resources/api-credentials#api-permissions): * Management API—Webhooks read * Management API—Webhooks read and write
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call.</exception>
        /// <param name="merchantId">The unique identifier of the merchant account.</param>
        /// <param name="webhookId">Unique identifier of the webhook configuration.</param>
        /// <param name="requestOptions"><see cref="RequestOptions"/>.</param>
        /// <param name="cancellationToken"><see cref="CancellationToken"/>.</param>
        /// <returns><see cref="Task"/> of <see cref="IGetWebhookApiResponse"/> - If 200 OK response, wraps the <see cref="Adyen.Management.Models.Webhook"/> when `TryDeserializeOk(...)` is called.</returns>
        public async Task<IGetWebhookApiResponse> GetWebhookAsync(string merchantId, string webhookId,  RequestOptions? requestOptions = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilder = new UriBuilder();

            try
            {
                using (HttpRequestMessage httpRequestMessage = new HttpRequestMessage())
                {
                    uriBuilder.Host = HttpClient.BaseAddress!.Host;
                    uriBuilder.Port = HttpClient.BaseAddress.Port;
                    uriBuilder.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilder.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/merchants/{merchantId}/webhooks/{webhookId}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/merchants/{merchantId}/webhooks/{webhookId}");
                    uriBuilder.Path = uriBuilder.Path.Replace("%7BmerchantId%7D", Uri.EscapeDataString(merchantId.ToString()));
                    uriBuilder.Path = uriBuilder.Path.Replace("%7BwebhookId%7D", Uri.EscapeDataString(webhookId.ToString()));

                    // Adds headers to the HttpRequestMessage header, these can be set in the RequestOptions (Idempotency-Key etc.)
                    requestOptions?.AddHeadersToHttpRequestMessage(httpRequestMessage);

                    // Add authorization token to the HttpRequestMessage header
                    ApiKeyProvider.Get().AddTokenToHttpRequestMessageHeader(httpRequestMessage);
                    
                    httpRequestMessage.RequestUri = uriBuilder.Uri;

                    string[] accepts = new string[] {
                        "application/json"
                    };

                    string? accept = ClientUtils.SelectHeaderAccept(accepts);

                    if (accept != null)
                        httpRequestMessage.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(accept));
#if NET462 || NETSTANDARD2_0
                    httpRequestMessage.Method = new HttpMethod("GET");
#else
                    httpRequestMessage.Method = HttpMethod.Get;
#endif

                    DateTime requestedAt = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessage = await HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<WebhooksCompanyLevelService.GetWebhookApiResponse> apiResponseLogger = LoggerFactory.CreateLogger<WebhooksCompanyLevelService.GetWebhookApiResponse>();
                        WebhooksCompanyLevelService.GetWebhookApiResponse apiResponse;

                        switch ((int)httpResponseMessage.StatusCode) {
                            default: {
#if NET462 || NETSTANDARD2_0
                                // `HttpContent.ReadAsStringAsync(cancellationToken)` doesn't exist in .NET Standard 2.0. Instead, we cancel one-level above in `HttpClient.SendAsync(httpRequestMessage, cancellationToken)`.
                                string responseContent = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(false);
#else
                                string responseContent = await httpResponseMessage.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
#endif
                                apiResponse = new(apiResponseLogger, httpRequestMessage, httpResponseMessage, responseContent, "/merchants/{merchantId}/webhooks/{webhookId}", requestedAt, _jsonSerializerOptions);

                                break;
                            }
                        }
                        
                        Events?.ExecuteOnGetWebhook(apiResponse);
                        return apiResponse;
                    }
                }
            }
            catch(Exception exception)
            {
                Events?.ExecuteOnErrorGetWebhook(exception);
                throw;
            }
        }
        /// <summary>
        /// List all webhooks Lists all webhook configurations for the merchant account.  &gt; This call does not return webhook configurations for the company account to which the specified merchant account belongs. You can see these in your Customer Area under **Developers** &gt; **Webhooks**.  To make this request, your API credential must have one of the following [roles](https://docs.adyen.com/development-resources/api-credentials#api-permissions): * Management API—Webhooks read * Management API—Webhooks read and write
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call.</exception>
        /// <param name="merchantId">The unique identifier of the merchant account.</param>
        /// <param name="pageNumber">The number of the page to fetch. ()</param>
        /// <param name="pageSize">The number of items to have on a page, maximum 100. The default is 10 items on a page. ()</param>
        /// <param name="requestOptions"><see cref="RequestOptions"/>.</param>
        /// <param name="cancellationToken"><see cref="CancellationToken"/>.</param>
        /// <returns><see cref="Task"/> of <see cref="IListAllWebhooksApiResponse"/> - If 200 OK response, wraps the <see cref="Adyen.Management.Models.ListWebhooksResponse"/> when `TryDeserializeOk(...)` is called.</returns>
        public async Task<IListAllWebhooksApiResponse> ListAllWebhooksAsync(string merchantId, Option<int> pageNumber = default, Option<int> pageSize = default,  RequestOptions? requestOptions = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilder = new UriBuilder();

            try
            {
                using (HttpRequestMessage httpRequestMessage = new HttpRequestMessage())
                {
                    uriBuilder.Host = HttpClient.BaseAddress!.Host;
                    uriBuilder.Port = HttpClient.BaseAddress.Port;
                    uriBuilder.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilder.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/merchants/{merchantId}/webhooks"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/merchants/{merchantId}/webhooks");
                    uriBuilder.Path = uriBuilder.Path.Replace("%7BmerchantId%7D", Uri.EscapeDataString(merchantId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryString = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (pageNumber.IsSet)
                        parseQueryString["pageNumber"] = ClientUtils.ParameterToString(pageNumber.Value);

                    if (pageSize.IsSet)
                        parseQueryString["pageSize"] = ClientUtils.ParameterToString(pageSize.Value);

                    uriBuilder.Query = parseQueryString.ToString();

                    // Adds headers to the HttpRequestMessage header, these can be set in the RequestOptions (Idempotency-Key etc.)
                    requestOptions?.AddHeadersToHttpRequestMessage(httpRequestMessage);

                    // Add authorization token to the HttpRequestMessage header
                    ApiKeyProvider.Get().AddTokenToHttpRequestMessageHeader(httpRequestMessage);
                    
                    httpRequestMessage.RequestUri = uriBuilder.Uri;

                    string[] accepts = new string[] {
                        "application/json"
                    };

                    string? accept = ClientUtils.SelectHeaderAccept(accepts);

                    if (accept != null)
                        httpRequestMessage.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(accept));
#if NET462 || NETSTANDARD2_0
                    httpRequestMessage.Method = new HttpMethod("GET");
#else
                    httpRequestMessage.Method = HttpMethod.Get;
#endif

                    DateTime requestedAt = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessage = await HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<WebhooksCompanyLevelService.ListAllWebhooksApiResponse> apiResponseLogger = LoggerFactory.CreateLogger<WebhooksCompanyLevelService.ListAllWebhooksApiResponse>();
                        WebhooksCompanyLevelService.ListAllWebhooksApiResponse apiResponse;

                        switch ((int)httpResponseMessage.StatusCode) {
                            default: {
#if NET462 || NETSTANDARD2_0
                                // `HttpContent.ReadAsStringAsync(cancellationToken)` doesn't exist in .NET Standard 2.0. Instead, we cancel one-level above in `HttpClient.SendAsync(httpRequestMessage, cancellationToken)`.
                                string responseContent = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(false);
#else
                                string responseContent = await httpResponseMessage.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
#endif
                                apiResponse = new(apiResponseLogger, httpRequestMessage, httpResponseMessage, responseContent, "/merchants/{merchantId}/webhooks", requestedAt, _jsonSerializerOptions);

                                break;
                            }
                        }
                        
                        Events?.ExecuteOnListAllWebhooks(apiResponse);
                        return apiResponse;
                    }
                }
            }
            catch(Exception exception)
            {
                Events?.ExecuteOnErrorListAllWebhooks(exception);
                throw;
            }
        }
        /// <summary>
        /// Remove a webhook Remove the configuration for the webhook identified in the path.  To make this request, your API credential must have the following [roles](https://docs.adyen.com/development-resources/api-credentials#api-permissions): * Management API—Webhooks read and write
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call.</exception>
        /// <param name="merchantId">The unique identifier of the merchant account.</param>
        /// <param name="webhookId">Unique identifier of the webhook configuration.</param>
        /// <param name="requestOptions"><see cref="RequestOptions"/>.</param>
        /// <param name="cancellationToken"><see cref="CancellationToken"/>.</param>
        /// <returns><see cref="Task"/> of <see cref="IRemoveWebhookApiResponse"/> - If 200 OK response, wraps the <see cref=""/> when `TryDeserializeOk(...)` is called.</returns>
        public async Task<IRemoveWebhookApiResponse> RemoveWebhookAsync(string merchantId, string webhookId,  RequestOptions? requestOptions = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilder = new UriBuilder();

            try
            {
                using (HttpRequestMessage httpRequestMessage = new HttpRequestMessage())
                {
                    uriBuilder.Host = HttpClient.BaseAddress!.Host;
                    uriBuilder.Port = HttpClient.BaseAddress.Port;
                    uriBuilder.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilder.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/merchants/{merchantId}/webhooks/{webhookId}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/merchants/{merchantId}/webhooks/{webhookId}");
                    uriBuilder.Path = uriBuilder.Path.Replace("%7BmerchantId%7D", Uri.EscapeDataString(merchantId.ToString()));
                    uriBuilder.Path = uriBuilder.Path.Replace("%7BwebhookId%7D", Uri.EscapeDataString(webhookId.ToString()));

                    // Adds headers to the HttpRequestMessage header, these can be set in the RequestOptions (Idempotency-Key etc.)
                    requestOptions?.AddHeadersToHttpRequestMessage(httpRequestMessage);

                    // Add authorization token to the HttpRequestMessage header
                    ApiKeyProvider.Get().AddTokenToHttpRequestMessageHeader(httpRequestMessage);
                    
                    httpRequestMessage.RequestUri = uriBuilder.Uri;

                    string[] accepts = new string[] {
                        "application/json"
                    };

                    string? accept = ClientUtils.SelectHeaderAccept(accepts);

                    if (accept != null)
                        httpRequestMessage.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(accept));
#if NET462 || NETSTANDARD2_0
                    httpRequestMessage.Method = new HttpMethod("DELETE");
#else
                    httpRequestMessage.Method = HttpMethod.Delete;
#endif

                    DateTime requestedAt = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessage = await HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<WebhooksCompanyLevelService.RemoveWebhookApiResponse> apiResponseLogger = LoggerFactory.CreateLogger<WebhooksCompanyLevelService.RemoveWebhookApiResponse>();
                        WebhooksCompanyLevelService.RemoveWebhookApiResponse apiResponse;

                        switch ((int)httpResponseMessage.StatusCode) {
                            default: {
#if NET462 || NETSTANDARD2_0
                                // `HttpContent.ReadAsStringAsync(cancellationToken)` doesn't exist in .NET Standard 2.0. Instead, we cancel one-level above in `HttpClient.SendAsync(httpRequestMessage, cancellationToken)`.
                                string responseContent = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(false);
#else
                                string responseContent = await httpResponseMessage.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
#endif
                                apiResponse = new(apiResponseLogger, httpRequestMessage, httpResponseMessage, responseContent, "/merchants/{merchantId}/webhooks/{webhookId}", requestedAt, _jsonSerializerOptions);

                                break;
                            }
                        }
                        
                        Events?.ExecuteOnRemoveWebhook(apiResponse);
                        return apiResponse;
                    }
                }
            }
            catch(Exception exception)
            {
                Events?.ExecuteOnErrorRemoveWebhook(exception);
                throw;
            }
        }
        /// <summary>
        /// Set up a webhook Subscribe to receive webhook notifications about events related to your merchant account. You can add basic authentication to make sure the data is secure.  To make this request, your API credential must have the following [roles](https://docs.adyen.com/development-resources/api-credentials#api-permissions): * Management API—Webhooks read and write
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call.</exception>
        /// <param name="merchantId">The unique identifier of the merchant account.</param>
        /// <param name="createMerchantWebhookRequest"><see cref="CreateMerchantWebhookRequest"/> ()</param>
        /// <param name="requestOptions"><see cref="RequestOptions"/>.</param>
        /// <param name="cancellationToken"><see cref="CancellationToken"/>.</param>
        /// <returns><see cref="Task"/> of <see cref="ISetUpWebhookApiResponse"/> - If 200 OK response, wraps the <see cref="Adyen.Management.Models.Webhook"/> when `TryDeserializeOk(...)` is called.</returns>
        public async Task<ISetUpWebhookApiResponse> SetUpWebhookAsync(string merchantId, CreateMerchantWebhookRequest createMerchantWebhookRequest,  RequestOptions? requestOptions = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilder = new UriBuilder();

            try
            {
                using (HttpRequestMessage httpRequestMessage = new HttpRequestMessage())
                {
                    uriBuilder.Host = HttpClient.BaseAddress!.Host;
                    uriBuilder.Port = HttpClient.BaseAddress.Port;
                    uriBuilder.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilder.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/merchants/{merchantId}/webhooks"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/merchants/{merchantId}/webhooks");
                    uriBuilder.Path = uriBuilder.Path.Replace("%7BmerchantId%7D", Uri.EscapeDataString(merchantId.ToString()));

                    // Adds headers to the HttpRequestMessage header, these can be set in the RequestOptions (Idempotency-Key etc.)
                    requestOptions?.AddHeadersToHttpRequestMessage(httpRequestMessage);
                    httpRequestMessage.Content = (createMerchantWebhookRequest as object) is System.IO.Stream stream
                        ? httpRequestMessage.Content = new StreamContent(stream)
                        : httpRequestMessage.Content = new StringContent(JsonSerializer.Serialize(createMerchantWebhookRequest, _jsonSerializerOptions));

                    // Add authorization token to the HttpRequestMessage header
                    ApiKeyProvider.Get().AddTokenToHttpRequestMessageHeader(httpRequestMessage);
                    
                    httpRequestMessage.RequestUri = uriBuilder.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    httpRequestMessage.AddUserAgentToHeaders();
                    httpRequestMessage.AddLibraryNameToHeader();
                    httpRequestMessage.AddLibraryVersionToHeader();
                    
                    string? contentType = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentType != null && httpRequestMessage.Content != null)
                        httpRequestMessage.Content.Headers.ContentType = new MediaTypeHeaderValue(contentType);

                    string[] accepts = new string[] {
                        "application/json"
                    };

                    string? accept = ClientUtils.SelectHeaderAccept(accepts);

                    if (accept != null)
                        httpRequestMessage.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(accept));
#if NET462 || NETSTANDARD2_0
                    httpRequestMessage.Method = new HttpMethod("POST");
#else
                    httpRequestMessage.Method = HttpMethod.Post;
#endif

                    DateTime requestedAt = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessage = await HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<WebhooksCompanyLevelService.SetUpWebhookApiResponse> apiResponseLogger = LoggerFactory.CreateLogger<WebhooksCompanyLevelService.SetUpWebhookApiResponse>();
                        WebhooksCompanyLevelService.SetUpWebhookApiResponse apiResponse;

                        switch ((int)httpResponseMessage.StatusCode) {
                            default: {
#if NET462 || NETSTANDARD2_0
                                // `HttpContent.ReadAsStringAsync(cancellationToken)` doesn't exist in .NET Standard 2.0. Instead, we cancel one-level above in `HttpClient.SendAsync(httpRequestMessage, cancellationToken)`.
                                string responseContent = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(false);
#else
                                string responseContent = await httpResponseMessage.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
#endif
                                apiResponse = new(apiResponseLogger, httpRequestMessage, httpResponseMessage, responseContent, "/merchants/{merchantId}/webhooks", requestedAt, _jsonSerializerOptions);

                                break;
                            }
                        }
                        
                        Events?.ExecuteOnSetUpWebhook(apiResponse);
                        return apiResponse;
                    }
                }
            }
            catch(Exception exception)
            {
                Events?.ExecuteOnErrorSetUpWebhook(exception);
                throw;
            }
        }
        /// <summary>
        /// Test a webhook Sends sample notifications to test if the webhook is set up correctly.  We send four test notifications for each event code you choose. They cover success and failure scenarios for the hard-coded currencies EUR and GBP, regardless of the currencies configured in the merchant accounts. For custom notifications, we only send the specified custom notification.  The response describes the result of the test. The &#x60;status&#x60; field tells you if the test was successful or not. You can use the other fields to troubleshoot unsuccessful tests.  To make this request, your API credential must have the following [roles](https://docs.adyen.com/development-resources/api-credentials#api-permissions): * Management API—Webhooks read and write
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call.</exception>
        /// <param name="merchantId">The unique identifier of the merchant account.</param>
        /// <param name="webhookId">Unique identifier of the webhook configuration.</param>
        /// <param name="testWebhookRequest"><see cref="TestWebhookRequest"/> ()</param>
        /// <param name="requestOptions"><see cref="RequestOptions"/>.</param>
        /// <param name="cancellationToken"><see cref="CancellationToken"/>.</param>
        /// <returns><see cref="Task"/> of <see cref="ITestWebhookApiResponse"/> - If 200 OK response, wraps the <see cref="Adyen.Management.Models.TestWebhookResponse"/> when `TryDeserializeOk(...)` is called.</returns>
        public async Task<ITestWebhookApiResponse> TestWebhookAsync(string merchantId, string webhookId, TestWebhookRequest testWebhookRequest,  RequestOptions? requestOptions = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilder = new UriBuilder();

            try
            {
                using (HttpRequestMessage httpRequestMessage = new HttpRequestMessage())
                {
                    uriBuilder.Host = HttpClient.BaseAddress!.Host;
                    uriBuilder.Port = HttpClient.BaseAddress.Port;
                    uriBuilder.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilder.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/merchants/{merchantId}/webhooks/{webhookId}/test"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/merchants/{merchantId}/webhooks/{webhookId}/test");
                    uriBuilder.Path = uriBuilder.Path.Replace("%7BmerchantId%7D", Uri.EscapeDataString(merchantId.ToString()));
                    uriBuilder.Path = uriBuilder.Path.Replace("%7BwebhookId%7D", Uri.EscapeDataString(webhookId.ToString()));

                    // Adds headers to the HttpRequestMessage header, these can be set in the RequestOptions (Idempotency-Key etc.)
                    requestOptions?.AddHeadersToHttpRequestMessage(httpRequestMessage);
                    httpRequestMessage.Content = (testWebhookRequest as object) is System.IO.Stream stream
                        ? httpRequestMessage.Content = new StreamContent(stream)
                        : httpRequestMessage.Content = new StringContent(JsonSerializer.Serialize(testWebhookRequest, _jsonSerializerOptions));

                    // Add authorization token to the HttpRequestMessage header
                    ApiKeyProvider.Get().AddTokenToHttpRequestMessageHeader(httpRequestMessage);
                    
                    httpRequestMessage.RequestUri = uriBuilder.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    httpRequestMessage.AddUserAgentToHeaders();
                    httpRequestMessage.AddLibraryNameToHeader();
                    httpRequestMessage.AddLibraryVersionToHeader();
                    
                    string? contentType = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentType != null && httpRequestMessage.Content != null)
                        httpRequestMessage.Content.Headers.ContentType = new MediaTypeHeaderValue(contentType);

                    string[] accepts = new string[] {
                        "application/json"
                    };

                    string? accept = ClientUtils.SelectHeaderAccept(accepts);

                    if (accept != null)
                        httpRequestMessage.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(accept));
#if NET462 || NETSTANDARD2_0
                    httpRequestMessage.Method = new HttpMethod("POST");
#else
                    httpRequestMessage.Method = HttpMethod.Post;
#endif

                    DateTime requestedAt = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessage = await HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<WebhooksCompanyLevelService.TestWebhookApiResponse> apiResponseLogger = LoggerFactory.CreateLogger<WebhooksCompanyLevelService.TestWebhookApiResponse>();
                        WebhooksCompanyLevelService.TestWebhookApiResponse apiResponse;

                        switch ((int)httpResponseMessage.StatusCode) {
                            default: {
#if NET462 || NETSTANDARD2_0
                                // `HttpContent.ReadAsStringAsync(cancellationToken)` doesn't exist in .NET Standard 2.0. Instead, we cancel one-level above in `HttpClient.SendAsync(httpRequestMessage, cancellationToken)`.
                                string responseContent = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(false);
#else
                                string responseContent = await httpResponseMessage.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
#endif
                                apiResponse = new(apiResponseLogger, httpRequestMessage, httpResponseMessage, responseContent, "/merchants/{merchantId}/webhooks/{webhookId}/test", requestedAt, _jsonSerializerOptions);

                                break;
                            }
                        }
                        
                        Events?.ExecuteOnTestWebhook(apiResponse);
                        return apiResponse;
                    }
                }
            }
            catch(Exception exception)
            {
                Events?.ExecuteOnErrorTestWebhook(exception);
                throw;
            }
        }
        /// <summary>
        /// Update a webhook Make changes to the configuration of the webhook identified in the path. The request contains the new values you want to have in the webhook configuration. The response contains the full configuration for the webhook, which includes the new values from the request.  To make this request, your API credential must have the following [roles](https://docs.adyen.com/development-resources/api-credentials#api-permissions): * Management API—Webhooks read and write
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call.</exception>
        /// <param name="merchantId">The unique identifier of the merchant account.</param>
        /// <param name="webhookId">Unique identifier of the webhook configuration.</param>
        /// <param name="updateMerchantWebhookRequest"><see cref="UpdateMerchantWebhookRequest"/> ()</param>
        /// <param name="requestOptions"><see cref="RequestOptions"/>.</param>
        /// <param name="cancellationToken"><see cref="CancellationToken"/>.</param>
        /// <returns><see cref="Task"/> of <see cref="IUpdateWebhookApiResponse"/> - If 200 OK response, wraps the <see cref="Adyen.Management.Models.Webhook"/> when `TryDeserializeOk(...)` is called.</returns>
        public async Task<IUpdateWebhookApiResponse> UpdateWebhookAsync(string merchantId, string webhookId, UpdateMerchantWebhookRequest updateMerchantWebhookRequest,  RequestOptions? requestOptions = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilder = new UriBuilder();

            try
            {
                using (HttpRequestMessage httpRequestMessage = new HttpRequestMessage())
                {
                    uriBuilder.Host = HttpClient.BaseAddress!.Host;
                    uriBuilder.Port = HttpClient.BaseAddress.Port;
                    uriBuilder.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilder.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/merchants/{merchantId}/webhooks/{webhookId}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/merchants/{merchantId}/webhooks/{webhookId}");
                    uriBuilder.Path = uriBuilder.Path.Replace("%7BmerchantId%7D", Uri.EscapeDataString(merchantId.ToString()));
                    uriBuilder.Path = uriBuilder.Path.Replace("%7BwebhookId%7D", Uri.EscapeDataString(webhookId.ToString()));

                    // Adds headers to the HttpRequestMessage header, these can be set in the RequestOptions (Idempotency-Key etc.)
                    requestOptions?.AddHeadersToHttpRequestMessage(httpRequestMessage);
                    httpRequestMessage.Content = (updateMerchantWebhookRequest as object) is System.IO.Stream stream
                        ? httpRequestMessage.Content = new StreamContent(stream)
                        : httpRequestMessage.Content = new StringContent(JsonSerializer.Serialize(updateMerchantWebhookRequest, _jsonSerializerOptions));

                    // Add authorization token to the HttpRequestMessage header
                    ApiKeyProvider.Get().AddTokenToHttpRequestMessageHeader(httpRequestMessage);
                    
                    httpRequestMessage.RequestUri = uriBuilder.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    httpRequestMessage.AddUserAgentToHeaders();
                    httpRequestMessage.AddLibraryNameToHeader();
                    httpRequestMessage.AddLibraryVersionToHeader();
                    
                    string? contentType = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentType != null && httpRequestMessage.Content != null)
                        httpRequestMessage.Content.Headers.ContentType = new MediaTypeHeaderValue(contentType);

                    string[] accepts = new string[] {
                        "application/json"
                    };

                    string? accept = ClientUtils.SelectHeaderAccept(accepts);

                    if (accept != null)
                        httpRequestMessage.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(accept));
#if NET462 || NETSTANDARD2_0
                    httpRequestMessage.Method = new HttpMethod("PATCH");
#else
                    httpRequestMessage.Method = HttpMethod.Patch;
#endif

                    DateTime requestedAt = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessage = await HttpClient.SendAsync(httpRequestMessage, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<WebhooksCompanyLevelService.UpdateWebhookApiResponse> apiResponseLogger = LoggerFactory.CreateLogger<WebhooksCompanyLevelService.UpdateWebhookApiResponse>();
                        WebhooksCompanyLevelService.UpdateWebhookApiResponse apiResponse;

                        switch ((int)httpResponseMessage.StatusCode) {
                            default: {
#if NET462 || NETSTANDARD2_0
                                // `HttpContent.ReadAsStringAsync(cancellationToken)` doesn't exist in .NET Standard 2.0. Instead, we cancel one-level above in `HttpClient.SendAsync(httpRequestMessage, cancellationToken)`.
                                string responseContent = await httpResponseMessage.Content.ReadAsStringAsync().ConfigureAwait(false);
#else
                                string responseContent = await httpResponseMessage.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
#endif
                                apiResponse = new(apiResponseLogger, httpRequestMessage, httpResponseMessage, responseContent, "/merchants/{merchantId}/webhooks/{webhookId}", requestedAt, _jsonSerializerOptions);

                                break;
                            }
                        }
                        
                        Events?.ExecuteOnUpdateWebhook(apiResponse);
                        return apiResponse;
                    }
                }
            }
            catch(Exception exception)
            {
                Events?.ExecuteOnErrorUpdateWebhook(exception);
                throw;
            }
        }
    }
}
