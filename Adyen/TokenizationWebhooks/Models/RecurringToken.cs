// <auto-generated>
/*
 * Tokenization webhooks
 *
 * With Adyen, you can securely store payment details of your shoppers with their consent. We refer to these saved payment details as tokens.   We use webhooks to inform you about token lifecycle events. For more information, refer to our [documentation](https://docs.adyen.com/online-payments/tokenization/).
 *
 * The version of the OpenAPI document: 1
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using Adyen.Core;
using Adyen.TokenizationWebhooks.Client;

namespace Adyen.TokenizationWebhooks.Models
{
    /// <summary>
    /// RecurringToken.
    /// </summary>
    public partial class RecurringToken : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RecurringToken" /> class.
        /// </summary>
        /// <param name="merchantAccount">The identifier of the merchant account related to the event that triggered the webhook.</param>
        /// <param name="shopperReference">Your unique shopper reference that is associated with the &#x60;storedPaymentMethodId&#x60;.</param>
        /// <param name="storedPaymentMethodId">The ID of the token.</param>
        /// <param name="type">The type of the payment method.</param>
        [JsonConstructor]
        public RecurringToken(string merchantAccount, string shopperReference, string storedPaymentMethodId, string type)
        {
            MerchantAccount = merchantAccount;
            ShopperReference = shopperReference;
            StoredPaymentMethodId = storedPaymentMethodId;
            Type = type;
            OnCreated();
        }
        
        /// <summary>
        /// Best practice: Use the constructor to initialize your objects to understand which parameters are required/optional.
        /// </summary>
        public RecurringToken()
        {
        }

        partial void OnCreated();

        /// <summary>
        /// The identifier of the merchant account related to the event that triggered the webhook.
        /// </summary>
        /// <value>The identifier of the merchant account related to the event that triggered the webhook.</value>
        [JsonPropertyName("merchantAccount")]
        public string MerchantAccount { get; set; }

        /// <summary>
        /// Your unique shopper reference that is associated with the &#x60;storedPaymentMethodId&#x60;.
        /// </summary>
        /// <value>Your unique shopper reference that is associated with the `storedPaymentMethodId`.</value>
        [JsonPropertyName("shopperReference")]
        public string ShopperReference { get; set; }

        /// <summary>
        /// The ID of the token.
        /// </summary>
        /// <value>The ID of the token.</value>
        [JsonPropertyName("storedPaymentMethodId")]
        public string StoredPaymentMethodId { get; set; }

        /// <summary>
        /// The type of the payment method.
        /// </summary>
        /// <value>The type of the payment method.</value>
        [JsonPropertyName("type")]
        public string Type { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class RecurringToken {\n");
            sb.Append("  MerchantAccount: ").Append(MerchantAccount).Append("\n");
            sb.Append("  ShopperReference: ").Append(ShopperReference).Append("\n");
            sb.Append("  StoredPaymentMethodId: ").Append(StoredPaymentMethodId).Append("\n");
            sb.Append("  Type: ").Append(Type).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="RecurringToken" />
    /// </summary>
    public class RecurringTokenJsonConverter : JsonConverter<RecurringToken>
    {
        /// <summary>
        /// Deserializes json to <see cref="RecurringToken"/>.
        /// </summary>
        /// <param name="utf8JsonReader"><see cref="Utf8JsonReader"/>.</param>
        /// <param name="typeToConvert"><see cref="Type"/>.</param>
        /// <param name="jsonSerializerOptions">The <see cref="JsonSerializerOptions"/>, initialized from <see cref="HostConfiguration"/>.</param>
        /// <returns><see cref="RecurringToken"/>.</returns>
        /// <exception cref="JsonException"></exception>
        public override RecurringToken Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<string?> merchantAccount = default;
            Option<string?> shopperReference = default;
            Option<string?> storedPaymentMethodId = default;
            Option<string?> type = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? jsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (jsonPropertyName)
                    {
                        case "merchantAccount":
                            merchantAccount = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "shopperReference":
                            shopperReference = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "storedPaymentMethodId":
                            storedPaymentMethodId = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "type":
                            type = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        default:
                            break;
                    }
                }
            }
            
            if (!merchantAccount.IsSet)
                throw new ArgumentException("Property is required for class RecurringToken.", nameof(merchantAccount));

            if (!shopperReference.IsSet)
                throw new ArgumentException("Property is required for class RecurringToken.", nameof(shopperReference));

            if (!storedPaymentMethodId.IsSet)
                throw new ArgumentException("Property is required for class RecurringToken.", nameof(storedPaymentMethodId));

            if (!type.IsSet)
                throw new ArgumentException("Property is required for class RecurringToken.", nameof(type));

            return new RecurringToken(merchantAccount.Value!, shopperReference.Value!, storedPaymentMethodId.Value!, type.Value!);
        }

        /// <summary>
        /// Serializes a <see cref="RecurringToken"/>.
        /// </summary>
        /// <param name="writer"><see cref="Utf8JsonWriter"/></param>
        /// <param name="recurringToken"></param>
        /// <param name="jsonSerializerOptions"><see cref="JsonSerializerOptions"/></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, RecurringToken recurringToken, JsonSerializerOptions jsonSerializerOptions)
        {
            
            writer.WriteStartObject();
            
            WriteProperties(writer, recurringToken, jsonSerializerOptions);
            
            writer.WriteEndObject();
            
        }

        /// <summary>
        /// Serializes the properties of <see cref="RecurringToken"/>.
        /// </summary>
        /// <param name="writer"><see cref="Utf8JsonWriter"/></param>
        /// <param name="recurringToken"></param>
        /// <param name="jsonSerializerOptions"><see cref="JsonSerializerOptions"/></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, RecurringToken recurringToken, JsonSerializerOptions jsonSerializerOptions)
        {
            
            if (recurringToken.MerchantAccount != null)
                writer.WriteString("merchantAccount", recurringToken.MerchantAccount);

            if (recurringToken.ShopperReference != null)
                writer.WriteString("shopperReference", recurringToken.ShopperReference);

            if (recurringToken.StoredPaymentMethodId != null)
                writer.WriteString("storedPaymentMethodId", recurringToken.StoredPaymentMethodId);

            if (recurringToken.Type != null)
                writer.WriteString("type", recurringToken.Type);
        }
    }
}
