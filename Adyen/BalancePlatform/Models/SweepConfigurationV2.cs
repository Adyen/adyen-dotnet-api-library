// <auto-generated>
/*
 * Configuration API
 *
 * The Configuration API allows you to manage your balance platform where you can create account holders, balance accounts, cards, and business accounts.  ## Authentication Each request to the Configuration API must be signed with an API key. Generate an API key in your Customer Area if you have a [platform setup](https://docs.adyen.com/platforms/manage-access/api-credentials-web-service/#generate-api-key) or [marketplace setup](https://docs.adyen.com/marketplaces/manage-access/api-credentials-web-service/#generate-api-key).   If you have an Adyen Issuing integration, [generate an API key](https://docs.adyen.com/issuing/manage-access/api-credentials-web-service/#generate-api-key) in your Balance Platform Customer Area.  To connect to the API, add an `X-API-Key` header with the API key as the value, for example:   ``` curl -H \"Content-Type: application/json\" \\ -H \"X-API-Key: YOUR_API_KEY\" \\ ... ```  ## Versioning The Configuration API supports [versioning](https://docs.adyen.com/development-resources/versioning) using a version suffix in the endpoint URL. This suffix has the following format: \"vXX\", where XX is the version number.  For example: ``` https://balanceplatform-api-test.adyen.com/bcl/v2/accountHolders ``` ## Going live When going live, generate an API key in your [live Customer Area](https://ca-live.adyen.com/ca/) if you have an Adyen for Platforms integration or [live Balance Platform Customer Area](https://balanceplatform-live.adyen.com/balanceplatform/) if you have an Adyen Issuing integration.You can then use the API key to send requests to `https://balanceplatform-api-live.adyen.com/bcl/v2`.
 *
 * The version of the OpenAPI document: 2
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using Adyen.Core;
using Adyen.BalancePlatform.Client;

namespace Adyen.BalancePlatform.Models
{
    /// <summary>
    /// SweepConfigurationV2.
    /// </summary>
    public partial class SweepConfigurationV2 : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SweepConfigurationV2" /> class.
        /// </summary>
        /// <param name="counterparty">counterparty</param>
        /// <param name="currency">The three-character [ISO currency code](https://docs.adyen.com/development-resources/currency-codes) in uppercase. For example, **EUR**.  The sweep currency must match any of the [balances currencies](https://docs.adyen.com/api-explorer/#/balanceplatform/latest/get/balanceAccounts/{id}__resParam_balances).</param>
        /// <param name="id">The unique identifier of the sweep.</param>
        /// <param name="schedule">schedule</param>
        /// <param name="category">The type of transfer that results from the sweep.  Possible values:   - **bank**: Sweep to a [transfer instrument](https://docs.adyen.com/api-explorer/#/legalentity/latest/post/transferInstruments__resParam_id).  - **internal**: Transfer to another [balance account](https://docs.adyen.com/api-explorer/#/balanceplatform/latest/post/balanceAccounts__resParam_id) within your platform.  Required when setting &#x60;priorities&#x60;.</param>
        /// <param name="description">The message that will be used in the sweep transfer&#39;s description body with a maximum length of 140 characters.  If the message is longer after replacing placeholders, the message will be cut off at 140 characters.</param>
        /// <param name="priorities">The list of priorities for the bank transfer. This sets the speed at which the transfer is sent and the fees that you have to pay. You can provide multiple priorities, ordered by your preference. Adyen will try to pay out using the priorities in the given order. If the first priority is not currently supported or enabled for your platform, the system will try the next one, and so on.  The request will be accepted as long as **at least one** of the provided priorities is valid (i.e., supported by Adyen and activated for your platform). For example, if you provide &#x60;[\&quot;wire\&quot;,\&quot;regular\&quot;]&#x60;, and &#x60;wire&#x60; is not supported but &#x60;regular&#x60; is, the request will still be accepted and processed.  Possible values:  * **regular**: for normal, low-value transactions.  * **fast**: a faster way to transfer funds, but the fees are higher. Recommended for high-priority, low-value transactions.  * **wire**: the fastest way to transfer funds, but this has the highest fees. Recommended for high-priority, high-value transactions.  * **instant**: for instant funds transfers within the United States and in [SEPA locations](https://www.ecb.europa.eu/paym/integration/retail/sepa/html/index.en.html).  * **crossBorder**: for high-value transfers to a recipient in a different country.  * **internal**: for transfers to an Adyen-issued business bank account (by bank account number/IBAN).  Set &#x60;category&#x60; to **bank**. For more details, see optional priorities setup for [marketplaces](https://docs.adyen.com/marketplaces/payout-to-users/scheduled-payouts#optional-priorities-setup) or [platforms](https://docs.adyen.com/platforms/payout-to-users/scheduled-payouts#optional-priorities-setup).</param>
        /// <param name="reason">The reason for disabling the sweep.</param>
        /// <param name="reasonDetail">The human readable reason for disabling the sweep.</param>
        /// <param name="reference">Your reference for the sweep configuration.</param>
        /// <param name="referenceForBeneficiary">The reference sent to or received from the counterparty. Only alphanumeric characters are allowed.</param>
        /// <param name="status">The status of the sweep. If not provided, by default, this is set to **active**.  Possible values:    * **active**:  the sweep is enabled and funds will be pulled in or pushed out based on the defined configuration.    * **inactive**: the sweep is disabled and cannot be triggered.   </param>
        /// <param name="sweepAmount">sweepAmount</param>
        /// <param name="targetAmount">targetAmount</param>
        /// <param name="triggerAmount">triggerAmount</param>
        /// <param name="type">The direction of sweep, whether pushing out or pulling in funds to the balance account. If not provided, by default, this is set to **push**.  Possible values:   * **push**: _push out funds_ to a destination balance account or transfer instrument.   * **pull**: _pull in funds_ from a source merchant account, transfer instrument, or balance account. (default to TypeEnum.Push)</param>
        [JsonConstructor]
        public SweepConfigurationV2(SweepCounterparty counterparty, string currency, string id, SweepSchedule schedule, Option<CategoryEnum?> category = default, Option<string?> description = default, Option<List<SweepConfigurationV2.PrioritiesEnum>?> priorities = default, Option<ReasonEnum?> reason = default, Option<string?> reasonDetail = default, Option<string?> reference = default, Option<string?> referenceForBeneficiary = default, Option<StatusEnum?> status = default, Option<Amount?> sweepAmount = default, Option<Amount?> targetAmount = default, Option<Amount?> triggerAmount = default, Option<TypeEnum?> type = default)
        {
            Counterparty = counterparty;
            Currency = currency;
            Id = id;
            Schedule = schedule;
            _CategoryOption = category;
            _DescriptionOption = description;
            _PrioritiesOption = priorities;
            _ReasonOption = reason;
            _ReasonDetailOption = reasonDetail;
            _ReferenceOption = reference;
            _ReferenceForBeneficiaryOption = referenceForBeneficiary;
            _StatusOption = status;
            _SweepAmountOption = sweepAmount;
            _TargetAmountOption = targetAmount;
            _TriggerAmountOption = triggerAmount;
            _TypeOption = type;
            OnCreated();
        }
        
        /// <summary>
        /// Best practice: Use the parameterized constructor above to initialize your objects to understand which parameters are required.
        /// </summary>
        public SweepConfigurationV2()
        {
        }

        partial void OnCreated();

        /// <summary>
        /// The type of transfer that results from the sweep.  Possible values:   - **bank**: Sweep to a [transfer instrument](https://docs.adyen.com/api-explorer/#/legalentity/latest/post/transferInstruments__resParam_id).  - **internal**: Transfer to another [balance account](https://docs.adyen.com/api-explorer/#/balanceplatform/latest/post/balanceAccounts__resParam_id) within your platform.  Required when setting &#x60;priorities&#x60;.
        /// </summary>
        /// <value>The type of transfer that results from the sweep.  Possible values:   - **bank**: Sweep to a [transfer instrument](https://docs.adyen.com/api-explorer/#/legalentity/latest/post/transferInstruments__resParam_id).  - **internal**: Transfer to another [balance account](https://docs.adyen.com/api-explorer/#/balanceplatform/latest/post/balanceAccounts__resParam_id) within your platform.  Required when setting &#x60;priorities&#x60;.</value>
        [JsonConverter(typeof(CategoryEnumJsonConverter))]
        public class CategoryEnum : IEnum
        {
            /// <summary>
            /// Returns the value of the CategoryEnum.
            /// </summary>
            public string? Value { get; set; }

            /// <summary>
            /// CategoryEnum.Bank - bank
            /// </summary>
            public static readonly CategoryEnum Bank = new("bank");

            /// <summary>
            /// CategoryEnum.Internal - internal
            /// </summary>
            public static readonly CategoryEnum Internal = new("internal");

            /// <summary>
            /// CategoryEnum.PlatformPayment - platformPayment
            /// </summary>
            public static readonly CategoryEnum PlatformPayment = new("platformPayment");
        
            private CategoryEnum(string? value)
            {
                Value = value;
            }

            /// <summary>
            /// Converts a string to a <see cref="CategoryEnum"/> implicitly.
            /// </summary>
            /// <param name="value">The string value to convert. Defaults to null.</param>
            /// <returns>A new <see cref="CategoryEnum"/> instance initialized with the string value.</returns>
            public static implicit operator CategoryEnum?(string? value) => value == null ? null : new CategoryEnum(value);
    
            /// <summary>
            /// Converts a <see cref="CategoryEnum"/> instance to a string implicitly.
            /// </summary>
            /// <param name="option">The <see cref="CategoryEnum"/> instance. Default to null.</param>
            /// <returns>String value of the <see cref="CategoryEnum"/> instance./// </returns>
            public static implicit operator string?(CategoryEnum? option) => option?.Value;
        
            public static bool operator ==(CategoryEnum? left, CategoryEnum? right) => string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);
    
            public static bool operator !=(CategoryEnum? left, CategoryEnum? right) => !string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);

            public override bool Equals(object? obj) => obj is CategoryEnum other && string.Equals(Value, other.Value, StringComparison.OrdinalIgnoreCase);
    
            public override int GetHashCode() => Value?.GetHashCode() ?? 0;
        
            public override string ToString() => Value ?? string.Empty;
        
            /// <summary>
            /// Returns a <see cref="CategoryEnum?"/>.
            /// </summary>
            /// <param name="value"></param>
            /// <returns><see cref="CategoryEnum"/> or null.</returns>
            public static CategoryEnum? FromStringOrDefault(string value)
            {
                return value switch {
                    "bank" => CategoryEnum.Bank,
                    "internal" => CategoryEnum.Internal,
                    "platformPayment" => CategoryEnum.PlatformPayment,
                    _ => null,
                };
            }
    
            /// <summary>
            /// Converts the <see cref="CategoryEnum"/> to the json value.
            /// </summary>
            /// <param name="value"><see cref="CategoryEnum"/></param>
            /// <returns>String value of the enum.</returns>
            /// <exception cref="NotImplementedException"></exception>
            public static string? ToJsonValue(CategoryEnum? value)
            {
                if (value == null)
                    return null;
            
                if (value == CategoryEnum.Bank)
                    return "bank";
                
                if (value == CategoryEnum.Internal)
                    return "internal";
                
                if (value == CategoryEnum.PlatformPayment)
                    return "platformPayment";
                
                return null;
            }
            
            /// <summary>
            /// JsonConverter for writing CategoryEnum.               
            /// </summary>
            public class CategoryEnumJsonConverter : JsonConverter<CategoryEnum>
            {
                public override CategoryEnum? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions jsonOptions)
                {
                    string value = reader.GetString();
                    return value == null ? null : CategoryEnum.FromStringOrDefault(value) ?? new CategoryEnum(value);
                }

                public override void Write(Utf8JsonWriter writer, CategoryEnum value, JsonSerializerOptions jsonOptions)
                {
                    writer.WriteStringValue(CategoryEnum.ToJsonValue(value));
                }
            }
        }

         /// <summary>
        /// Used to track if an optional field is set. If set, <see cref="Category"/> will be populated.
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<CategoryEnum?> _CategoryOption { get; private set; }

        /// <summary>
        /// The type of transfer that results from the sweep.  Possible values:   - **bank**: Sweep to a [transfer instrument](https://docs.adyen.com/api-explorer/#/legalentity/latest/post/transferInstruments__resParam_id).  - **internal**: Transfer to another [balance account](https://docs.adyen.com/api-explorer/#/balanceplatform/latest/post/balanceAccounts__resParam_id) within your platform.  Required when setting &#x60;priorities&#x60;.
        /// </summary>
        /// <value>The type of transfer that results from the sweep.  Possible values:   - **bank**: Sweep to a [transfer instrument](https://docs.adyen.com/api-explorer/#/legalentity/latest/post/transferInstruments__resParam_id).  - **internal**: Transfer to another [balance account](https://docs.adyen.com/api-explorer/#/balanceplatform/latest/post/balanceAccounts__resParam_id) within your platform.  Required when setting &#x60;priorities&#x60;.</value>
        [JsonPropertyName("category")]
        public CategoryEnum? Category { get { return this._CategoryOption; } set { this._CategoryOption = new(value); } }

        /// <summary>
        /// Defines Priorities
        /// </summary>
        [JsonConverter(typeof(PrioritiesEnumJsonConverter))]
        public class PrioritiesEnum : IEnum
        {
            /// <summary>
            /// Returns the value of the PrioritiesEnum.
            /// </summary>
            public string? Value { get; set; }

            /// <summary>
            /// PrioritiesEnum.CrossBorder - crossBorder
            /// </summary>
            public static readonly PrioritiesEnum CrossBorder = new("crossBorder");

            /// <summary>
            /// PrioritiesEnum.Fast - fast
            /// </summary>
            public static readonly PrioritiesEnum Fast = new("fast");

            /// <summary>
            /// PrioritiesEnum.Instant - instant
            /// </summary>
            public static readonly PrioritiesEnum Instant = new("instant");

            /// <summary>
            /// PrioritiesEnum.Internal - internal
            /// </summary>
            public static readonly PrioritiesEnum Internal = new("internal");

            /// <summary>
            /// PrioritiesEnum.Regular - regular
            /// </summary>
            public static readonly PrioritiesEnum Regular = new("regular");

            /// <summary>
            /// PrioritiesEnum.Wire - wire
            /// </summary>
            public static readonly PrioritiesEnum Wire = new("wire");
        
            private PrioritiesEnum(string? value)
            {
                Value = value;
            }

            /// <summary>
            /// Converts a string to a <see cref="PrioritiesEnum"/> implicitly.
            /// </summary>
            /// <param name="value">The string value to convert. Defaults to null.</param>
            /// <returns>A new <see cref="PrioritiesEnum"/> instance initialized with the string value.</returns>
            public static implicit operator PrioritiesEnum?(string? value) => value == null ? null : new PrioritiesEnum(value);
    
            /// <summary>
            /// Converts a <see cref="PrioritiesEnum"/> instance to a string implicitly.
            /// </summary>
            /// <param name="option">The <see cref="PrioritiesEnum"/> instance. Default to null.</param>
            /// <returns>String value of the <see cref="PrioritiesEnum"/> instance./// </returns>
            public static implicit operator string?(PrioritiesEnum? option) => option?.Value;
        
            public static bool operator ==(PrioritiesEnum? left, PrioritiesEnum? right) => string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);
    
            public static bool operator !=(PrioritiesEnum? left, PrioritiesEnum? right) => !string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);

            public override bool Equals(object? obj) => obj is PrioritiesEnum other && string.Equals(Value, other.Value, StringComparison.OrdinalIgnoreCase);
    
            public override int GetHashCode() => Value?.GetHashCode() ?? 0;
        
            public override string ToString() => Value ?? string.Empty;
        
            /// <summary>
            /// Returns a <see cref="PrioritiesEnum?"/>.
            /// </summary>
            /// <param name="value"></param>
            /// <returns><see cref="PrioritiesEnum"/> or null.</returns>
            public static PrioritiesEnum? FromStringOrDefault(string value)
            {
                return value switch {
                    "crossBorder" => PrioritiesEnum.CrossBorder,
                    "fast" => PrioritiesEnum.Fast,
                    "instant" => PrioritiesEnum.Instant,
                    "internal" => PrioritiesEnum.Internal,
                    "regular" => PrioritiesEnum.Regular,
                    "wire" => PrioritiesEnum.Wire,
                    _ => null,
                };
            }
    
            /// <summary>
            /// Converts the <see cref="PrioritiesEnum"/> to the json value.
            /// </summary>
            /// <param name="value"><see cref="PrioritiesEnum"/></param>
            /// <returns>String value of the enum.</returns>
            /// <exception cref="NotImplementedException"></exception>
            public static string? ToJsonValue(PrioritiesEnum? value)
            {
                if (value == null)
                    return null;
            
                if (value == PrioritiesEnum.CrossBorder)
                    return "crossBorder";
                
                if (value == PrioritiesEnum.Fast)
                    return "fast";
                
                if (value == PrioritiesEnum.Instant)
                    return "instant";
                
                if (value == PrioritiesEnum.Internal)
                    return "internal";
                
                if (value == PrioritiesEnum.Regular)
                    return "regular";
                
                if (value == PrioritiesEnum.Wire)
                    return "wire";
                
                return null;
            }
            
            /// <summary>
            /// JsonConverter for writing PrioritiesEnum.               
            /// </summary>
            public class PrioritiesEnumJsonConverter : JsonConverter<PrioritiesEnum>
            {
                public override PrioritiesEnum? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions jsonOptions)
                {
                    string value = reader.GetString();
                    return value == null ? null : PrioritiesEnum.FromStringOrDefault(value) ?? new PrioritiesEnum(value);
                }

                public override void Write(Utf8JsonWriter writer, PrioritiesEnum value, JsonSerializerOptions jsonOptions)
                {
                    writer.WriteStringValue(PrioritiesEnum.ToJsonValue(value));
                }
            }
        }

        /// <summary>
        /// The reason for disabling the sweep.
        /// </summary>
        /// <value>The reason for disabling the sweep.</value>
        [JsonConverter(typeof(ReasonEnumJsonConverter))]
        public class ReasonEnum : IEnum
        {
            /// <summary>
            /// Returns the value of the ReasonEnum.
            /// </summary>
            public string? Value { get; set; }

            /// <summary>
            /// ReasonEnum.AccountHierarchyNotActive - accountHierarchyNotActive
            /// </summary>
            public static readonly ReasonEnum AccountHierarchyNotActive = new("accountHierarchyNotActive");

            /// <summary>
            /// ReasonEnum.AmountLimitExceeded - amountLimitExceeded
            /// </summary>
            public static readonly ReasonEnum AmountLimitExceeded = new("amountLimitExceeded");

            /// <summary>
            /// ReasonEnum.ApprovalExpired - approvalExpired
            /// </summary>
            public static readonly ReasonEnum ApprovalExpired = new("approvalExpired");

            /// <summary>
            /// ReasonEnum.Approved - approved
            /// </summary>
            public static readonly ReasonEnum Approved = new("approved");

            /// <summary>
            /// ReasonEnum.BalanceAccountTemporarilyBlockedByTransactionRule - balanceAccountTemporarilyBlockedByTransactionRule
            /// </summary>
            public static readonly ReasonEnum BalanceAccountTemporarilyBlockedByTransactionRule = new("balanceAccountTemporarilyBlockedByTransactionRule");

            /// <summary>
            /// ReasonEnum.CounterpartyAccountBlocked - counterpartyAccountBlocked
            /// </summary>
            public static readonly ReasonEnum CounterpartyAccountBlocked = new("counterpartyAccountBlocked");

            /// <summary>
            /// ReasonEnum.CounterpartyAccountClosed - counterpartyAccountClosed
            /// </summary>
            public static readonly ReasonEnum CounterpartyAccountClosed = new("counterpartyAccountClosed");

            /// <summary>
            /// ReasonEnum.CounterpartyAccountNotFound - counterpartyAccountNotFound
            /// </summary>
            public static readonly ReasonEnum CounterpartyAccountNotFound = new("counterpartyAccountNotFound");

            /// <summary>
            /// ReasonEnum.CounterpartyAddressRequired - counterpartyAddressRequired
            /// </summary>
            public static readonly ReasonEnum CounterpartyAddressRequired = new("counterpartyAddressRequired");

            /// <summary>
            /// ReasonEnum.CounterpartyBankTimedOut - counterpartyBankTimedOut
            /// </summary>
            public static readonly ReasonEnum CounterpartyBankTimedOut = new("counterpartyBankTimedOut");

            /// <summary>
            /// ReasonEnum.CounterpartyBankUnavailable - counterpartyBankUnavailable
            /// </summary>
            public static readonly ReasonEnum CounterpartyBankUnavailable = new("counterpartyBankUnavailable");

            /// <summary>
            /// ReasonEnum.Declined - declined
            /// </summary>
            public static readonly ReasonEnum Declined = new("declined");

            /// <summary>
            /// ReasonEnum.DeclinedByTransactionRule - declinedByTransactionRule
            /// </summary>
            public static readonly ReasonEnum DeclinedByTransactionRule = new("declinedByTransactionRule");

            /// <summary>
            /// ReasonEnum.DirectDebitNotSupported - directDebitNotSupported
            /// </summary>
            public static readonly ReasonEnum DirectDebitNotSupported = new("directDebitNotSupported");

            /// <summary>
            /// ReasonEnum.Error - error
            /// </summary>
            public static readonly ReasonEnum Error = new("error");

            /// <summary>
            /// ReasonEnum.NotEnoughBalance - notEnoughBalance
            /// </summary>
            public static readonly ReasonEnum NotEnoughBalance = new("notEnoughBalance");

            /// <summary>
            /// ReasonEnum.Pending - pending
            /// </summary>
            public static readonly ReasonEnum Pending = new("pending");

            /// <summary>
            /// ReasonEnum.PendingApproval - pendingApproval
            /// </summary>
            public static readonly ReasonEnum PendingApproval = new("pendingApproval");

            /// <summary>
            /// ReasonEnum.PendingExecution - pendingExecution
            /// </summary>
            public static readonly ReasonEnum PendingExecution = new("pendingExecution");

            /// <summary>
            /// ReasonEnum.RefusedByCounterpartyBank - refusedByCounterpartyBank
            /// </summary>
            public static readonly ReasonEnum RefusedByCounterpartyBank = new("refusedByCounterpartyBank");

            /// <summary>
            /// ReasonEnum.RefusedByCustomer - refusedByCustomer
            /// </summary>
            public static readonly ReasonEnum RefusedByCustomer = new("refusedByCustomer");

            /// <summary>
            /// ReasonEnum.RouteNotFound - routeNotFound
            /// </summary>
            public static readonly ReasonEnum RouteNotFound = new("routeNotFound");

            /// <summary>
            /// ReasonEnum.ScaFailed - scaFailed
            /// </summary>
            public static readonly ReasonEnum ScaFailed = new("scaFailed");

            /// <summary>
            /// ReasonEnum.TransferInstrumentDoesNotExist - transferInstrumentDoesNotExist
            /// </summary>
            public static readonly ReasonEnum TransferInstrumentDoesNotExist = new("transferInstrumentDoesNotExist");

            /// <summary>
            /// ReasonEnum.Unknown - unknown
            /// </summary>
            public static readonly ReasonEnum Unknown = new("unknown");
        
            private ReasonEnum(string? value)
            {
                Value = value;
            }

            /// <summary>
            /// Converts a string to a <see cref="ReasonEnum"/> implicitly.
            /// </summary>
            /// <param name="value">The string value to convert. Defaults to null.</param>
            /// <returns>A new <see cref="ReasonEnum"/> instance initialized with the string value.</returns>
            public static implicit operator ReasonEnum?(string? value) => value == null ? null : new ReasonEnum(value);
    
            /// <summary>
            /// Converts a <see cref="ReasonEnum"/> instance to a string implicitly.
            /// </summary>
            /// <param name="option">The <see cref="ReasonEnum"/> instance. Default to null.</param>
            /// <returns>String value of the <see cref="ReasonEnum"/> instance./// </returns>
            public static implicit operator string?(ReasonEnum? option) => option?.Value;
        
            public static bool operator ==(ReasonEnum? left, ReasonEnum? right) => string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);
    
            public static bool operator !=(ReasonEnum? left, ReasonEnum? right) => !string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);

            public override bool Equals(object? obj) => obj is ReasonEnum other && string.Equals(Value, other.Value, StringComparison.OrdinalIgnoreCase);
    
            public override int GetHashCode() => Value?.GetHashCode() ?? 0;
        
            public override string ToString() => Value ?? string.Empty;
        
            /// <summary>
            /// Returns a <see cref="ReasonEnum?"/>.
            /// </summary>
            /// <param name="value"></param>
            /// <returns><see cref="ReasonEnum"/> or null.</returns>
            public static ReasonEnum? FromStringOrDefault(string value)
            {
                return value switch {
                    "accountHierarchyNotActive" => ReasonEnum.AccountHierarchyNotActive,
                    "amountLimitExceeded" => ReasonEnum.AmountLimitExceeded,
                    "approvalExpired" => ReasonEnum.ApprovalExpired,
                    "approved" => ReasonEnum.Approved,
                    "balanceAccountTemporarilyBlockedByTransactionRule" => ReasonEnum.BalanceAccountTemporarilyBlockedByTransactionRule,
                    "counterpartyAccountBlocked" => ReasonEnum.CounterpartyAccountBlocked,
                    "counterpartyAccountClosed" => ReasonEnum.CounterpartyAccountClosed,
                    "counterpartyAccountNotFound" => ReasonEnum.CounterpartyAccountNotFound,
                    "counterpartyAddressRequired" => ReasonEnum.CounterpartyAddressRequired,
                    "counterpartyBankTimedOut" => ReasonEnum.CounterpartyBankTimedOut,
                    "counterpartyBankUnavailable" => ReasonEnum.CounterpartyBankUnavailable,
                    "declined" => ReasonEnum.Declined,
                    "declinedByTransactionRule" => ReasonEnum.DeclinedByTransactionRule,
                    "directDebitNotSupported" => ReasonEnum.DirectDebitNotSupported,
                    "error" => ReasonEnum.Error,
                    "notEnoughBalance" => ReasonEnum.NotEnoughBalance,
                    "pending" => ReasonEnum.Pending,
                    "pendingApproval" => ReasonEnum.PendingApproval,
                    "pendingExecution" => ReasonEnum.PendingExecution,
                    "refusedByCounterpartyBank" => ReasonEnum.RefusedByCounterpartyBank,
                    "refusedByCustomer" => ReasonEnum.RefusedByCustomer,
                    "routeNotFound" => ReasonEnum.RouteNotFound,
                    "scaFailed" => ReasonEnum.ScaFailed,
                    "transferInstrumentDoesNotExist" => ReasonEnum.TransferInstrumentDoesNotExist,
                    "unknown" => ReasonEnum.Unknown,
                    _ => null,
                };
            }
    
            /// <summary>
            /// Converts the <see cref="ReasonEnum"/> to the json value.
            /// </summary>
            /// <param name="value"><see cref="ReasonEnum"/></param>
            /// <returns>String value of the enum.</returns>
            /// <exception cref="NotImplementedException"></exception>
            public static string? ToJsonValue(ReasonEnum? value)
            {
                if (value == null)
                    return null;
            
                if (value == ReasonEnum.AccountHierarchyNotActive)
                    return "accountHierarchyNotActive";
                
                if (value == ReasonEnum.AmountLimitExceeded)
                    return "amountLimitExceeded";
                
                if (value == ReasonEnum.ApprovalExpired)
                    return "approvalExpired";
                
                if (value == ReasonEnum.Approved)
                    return "approved";
                
                if (value == ReasonEnum.BalanceAccountTemporarilyBlockedByTransactionRule)
                    return "balanceAccountTemporarilyBlockedByTransactionRule";
                
                if (value == ReasonEnum.CounterpartyAccountBlocked)
                    return "counterpartyAccountBlocked";
                
                if (value == ReasonEnum.CounterpartyAccountClosed)
                    return "counterpartyAccountClosed";
                
                if (value == ReasonEnum.CounterpartyAccountNotFound)
                    return "counterpartyAccountNotFound";
                
                if (value == ReasonEnum.CounterpartyAddressRequired)
                    return "counterpartyAddressRequired";
                
                if (value == ReasonEnum.CounterpartyBankTimedOut)
                    return "counterpartyBankTimedOut";
                
                if (value == ReasonEnum.CounterpartyBankUnavailable)
                    return "counterpartyBankUnavailable";
                
                if (value == ReasonEnum.Declined)
                    return "declined";
                
                if (value == ReasonEnum.DeclinedByTransactionRule)
                    return "declinedByTransactionRule";
                
                if (value == ReasonEnum.DirectDebitNotSupported)
                    return "directDebitNotSupported";
                
                if (value == ReasonEnum.Error)
                    return "error";
                
                if (value == ReasonEnum.NotEnoughBalance)
                    return "notEnoughBalance";
                
                if (value == ReasonEnum.Pending)
                    return "pending";
                
                if (value == ReasonEnum.PendingApproval)
                    return "pendingApproval";
                
                if (value == ReasonEnum.PendingExecution)
                    return "pendingExecution";
                
                if (value == ReasonEnum.RefusedByCounterpartyBank)
                    return "refusedByCounterpartyBank";
                
                if (value == ReasonEnum.RefusedByCustomer)
                    return "refusedByCustomer";
                
                if (value == ReasonEnum.RouteNotFound)
                    return "routeNotFound";
                
                if (value == ReasonEnum.ScaFailed)
                    return "scaFailed";
                
                if (value == ReasonEnum.TransferInstrumentDoesNotExist)
                    return "transferInstrumentDoesNotExist";
                
                if (value == ReasonEnum.Unknown)
                    return "unknown";
                
                return null;
            }
            
            /// <summary>
            /// JsonConverter for writing ReasonEnum.               
            /// </summary>
            public class ReasonEnumJsonConverter : JsonConverter<ReasonEnum>
            {
                public override ReasonEnum? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions jsonOptions)
                {
                    string value = reader.GetString();
                    return value == null ? null : ReasonEnum.FromStringOrDefault(value) ?? new ReasonEnum(value);
                }

                public override void Write(Utf8JsonWriter writer, ReasonEnum value, JsonSerializerOptions jsonOptions)
                {
                    writer.WriteStringValue(ReasonEnum.ToJsonValue(value));
                }
            }
        }

         /// <summary>
        /// Used to track if an optional field is set. If set, <see cref="Reason"/> will be populated.
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<ReasonEnum?> _ReasonOption { get; }

        /// <summary>
        /// The reason for disabling the sweep.
        /// </summary>
        /// <value>The reason for disabling the sweep.</value>
        [JsonPropertyName("reason")]
        public ReasonEnum? Reason { get { return this._ReasonOption; } }

        /// <summary>
        /// The status of the sweep. If not provided, by default, this is set to **active**.  Possible values:    * **active**:  the sweep is enabled and funds will be pulled in or pushed out based on the defined configuration.    * **inactive**: the sweep is disabled and cannot be triggered.   
        /// </summary>
        /// <value>The status of the sweep. If not provided, by default, this is set to **active**.  Possible values:    * **active**:  the sweep is enabled and funds will be pulled in or pushed out based on the defined configuration.    * **inactive**: the sweep is disabled and cannot be triggered.   </value>
        [JsonConverter(typeof(StatusEnumJsonConverter))]
        public class StatusEnum : IEnum
        {
            /// <summary>
            /// Returns the value of the StatusEnum.
            /// </summary>
            public string? Value { get; set; }

            /// <summary>
            /// StatusEnum.Active - active
            /// </summary>
            public static readonly StatusEnum Active = new("active");

            /// <summary>
            /// StatusEnum.Inactive - inactive
            /// </summary>
            public static readonly StatusEnum Inactive = new("inactive");
        
            private StatusEnum(string? value)
            {
                Value = value;
            }

            /// <summary>
            /// Converts a string to a <see cref="StatusEnum"/> implicitly.
            /// </summary>
            /// <param name="value">The string value to convert. Defaults to null.</param>
            /// <returns>A new <see cref="StatusEnum"/> instance initialized with the string value.</returns>
            public static implicit operator StatusEnum?(string? value) => value == null ? null : new StatusEnum(value);
    
            /// <summary>
            /// Converts a <see cref="StatusEnum"/> instance to a string implicitly.
            /// </summary>
            /// <param name="option">The <see cref="StatusEnum"/> instance. Default to null.</param>
            /// <returns>String value of the <see cref="StatusEnum"/> instance./// </returns>
            public static implicit operator string?(StatusEnum? option) => option?.Value;
        
            public static bool operator ==(StatusEnum? left, StatusEnum? right) => string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);
    
            public static bool operator !=(StatusEnum? left, StatusEnum? right) => !string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);

            public override bool Equals(object? obj) => obj is StatusEnum other && string.Equals(Value, other.Value, StringComparison.OrdinalIgnoreCase);
    
            public override int GetHashCode() => Value?.GetHashCode() ?? 0;
        
            public override string ToString() => Value ?? string.Empty;
        
            /// <summary>
            /// Returns a <see cref="StatusEnum?"/>.
            /// </summary>
            /// <param name="value"></param>
            /// <returns><see cref="StatusEnum"/> or null.</returns>
            public static StatusEnum? FromStringOrDefault(string value)
            {
                return value switch {
                    "active" => StatusEnum.Active,
                    "inactive" => StatusEnum.Inactive,
                    _ => null,
                };
            }
    
            /// <summary>
            /// Converts the <see cref="StatusEnum"/> to the json value.
            /// </summary>
            /// <param name="value"><see cref="StatusEnum"/></param>
            /// <returns>String value of the enum.</returns>
            /// <exception cref="NotImplementedException"></exception>
            public static string? ToJsonValue(StatusEnum? value)
            {
                if (value == null)
                    return null;
            
                if (value == StatusEnum.Active)
                    return "active";
                
                if (value == StatusEnum.Inactive)
                    return "inactive";
                
                return null;
            }
            
            /// <summary>
            /// JsonConverter for writing StatusEnum.               
            /// </summary>
            public class StatusEnumJsonConverter : JsonConverter<StatusEnum>
            {
                public override StatusEnum? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions jsonOptions)
                {
                    string value = reader.GetString();
                    return value == null ? null : StatusEnum.FromStringOrDefault(value) ?? new StatusEnum(value);
                }

                public override void Write(Utf8JsonWriter writer, StatusEnum value, JsonSerializerOptions jsonOptions)
                {
                    writer.WriteStringValue(StatusEnum.ToJsonValue(value));
                }
            }
        }

         /// <summary>
        /// Used to track if an optional field is set. If set, <see cref="Status"/> will be populated.
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<StatusEnum?> _StatusOption { get; private set; }

        /// <summary>
        /// The status of the sweep. If not provided, by default, this is set to **active**.  Possible values:    * **active**:  the sweep is enabled and funds will be pulled in or pushed out based on the defined configuration.    * **inactive**: the sweep is disabled and cannot be triggered.   
        /// </summary>
        /// <value>The status of the sweep. If not provided, by default, this is set to **active**.  Possible values:    * **active**:  the sweep is enabled and funds will be pulled in or pushed out based on the defined configuration.    * **inactive**: the sweep is disabled and cannot be triggered.   </value>
        [JsonPropertyName("status")]
        public StatusEnum? Status { get { return this._StatusOption; } set { this._StatusOption = new(value); } }

        /// <summary>
        /// The direction of sweep, whether pushing out or pulling in funds to the balance account. If not provided, by default, this is set to **push**.  Possible values:   * **push**: _push out funds_ to a destination balance account or transfer instrument.   * **pull**: _pull in funds_ from a source merchant account, transfer instrument, or balance account.
        /// </summary>
        /// <value>The direction of sweep, whether pushing out or pulling in funds to the balance account. If not provided, by default, this is set to **push**.  Possible values:   * **push**: _push out funds_ to a destination balance account or transfer instrument.   * **pull**: _pull in funds_ from a source merchant account, transfer instrument, or balance account.</value>
        [JsonConverter(typeof(TypeEnumJsonConverter))]
        public class TypeEnum : IEnum
        {
            /// <summary>
            /// Returns the value of the TypeEnum.
            /// </summary>
            public string? Value { get; set; }

            /// <summary>
            /// TypeEnum.Pull - pull
            /// </summary>
            public static readonly TypeEnum Pull = new("pull");

            /// <summary>
            /// TypeEnum.Push - push
            /// </summary>
            public static readonly TypeEnum Push = new("push");
        
            private TypeEnum(string? value)
            {
                Value = value;
            }

            /// <summary>
            /// Converts a string to a <see cref="TypeEnum"/> implicitly.
            /// </summary>
            /// <param name="value">The string value to convert. Defaults to null.</param>
            /// <returns>A new <see cref="TypeEnum"/> instance initialized with the string value.</returns>
            public static implicit operator TypeEnum?(string? value) => value == null ? null : new TypeEnum(value);
    
            /// <summary>
            /// Converts a <see cref="TypeEnum"/> instance to a string implicitly.
            /// </summary>
            /// <param name="option">The <see cref="TypeEnum"/> instance. Default to null.</param>
            /// <returns>String value of the <see cref="TypeEnum"/> instance./// </returns>
            public static implicit operator string?(TypeEnum? option) => option?.Value;
        
            public static bool operator ==(TypeEnum? left, TypeEnum? right) => string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);
    
            public static bool operator !=(TypeEnum? left, TypeEnum? right) => !string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);

            public override bool Equals(object? obj) => obj is TypeEnum other && string.Equals(Value, other.Value, StringComparison.OrdinalIgnoreCase);
    
            public override int GetHashCode() => Value?.GetHashCode() ?? 0;
        
            public override string ToString() => Value ?? string.Empty;
        
            /// <summary>
            /// Returns a <see cref="TypeEnum?"/>.
            /// </summary>
            /// <param name="value"></param>
            /// <returns><see cref="TypeEnum"/> or null.</returns>
            public static TypeEnum? FromStringOrDefault(string value)
            {
                return value switch {
                    "pull" => TypeEnum.Pull,
                    "push" => TypeEnum.Push,
                    _ => null,
                };
            }
    
            /// <summary>
            /// Converts the <see cref="TypeEnum"/> to the json value.
            /// </summary>
            /// <param name="value"><see cref="TypeEnum"/></param>
            /// <returns>String value of the enum.</returns>
            /// <exception cref="NotImplementedException"></exception>
            public static string? ToJsonValue(TypeEnum? value)
            {
                if (value == null)
                    return null;
            
                if (value == TypeEnum.Pull)
                    return "pull";
                
                if (value == TypeEnum.Push)
                    return "push";
                
                return null;
            }
            
            /// <summary>
            /// JsonConverter for writing TypeEnum.               
            /// </summary>
            public class TypeEnumJsonConverter : JsonConverter<TypeEnum>
            {
                public override TypeEnum? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions jsonOptions)
                {
                    string value = reader.GetString();
                    return value == null ? null : TypeEnum.FromStringOrDefault(value) ?? new TypeEnum(value);
                }

                public override void Write(Utf8JsonWriter writer, TypeEnum value, JsonSerializerOptions jsonOptions)
                {
                    writer.WriteStringValue(TypeEnum.ToJsonValue(value));
                }
            }
        }

         /// <summary>
        /// Used to track if an optional field is set. If set, <see cref="Type"/> will be populated.
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<TypeEnum?> _TypeOption { get; private set; }

        /// <summary>
        /// The direction of sweep, whether pushing out or pulling in funds to the balance account. If not provided, by default, this is set to **push**.  Possible values:   * **push**: _push out funds_ to a destination balance account or transfer instrument.   * **pull**: _pull in funds_ from a source merchant account, transfer instrument, or balance account.
        /// </summary>
        /// <value>The direction of sweep, whether pushing out or pulling in funds to the balance account. If not provided, by default, this is set to **push**.  Possible values:   * **push**: _push out funds_ to a destination balance account or transfer instrument.   * **pull**: _pull in funds_ from a source merchant account, transfer instrument, or balance account.</value>
        [JsonPropertyName("type")]
        public TypeEnum? Type { get { return this._TypeOption; } set { this._TypeOption = new(value); } }

        /// <summary>
        /// Gets or Sets Counterparty
        /// </summary>
        [JsonPropertyName("counterparty")]
        public SweepCounterparty Counterparty { get; set; }

        /// <summary>
        /// The three-character [ISO currency code](https://docs.adyen.com/development-resources/currency-codes) in uppercase. For example, **EUR**.  The sweep currency must match any of the [balances currencies](https://docs.adyen.com/api-explorer/#/balanceplatform/latest/get/balanceAccounts/{id}__resParam_balances).
        /// </summary>
        /// <value>The three-character [ISO currency code](https://docs.adyen.com/development-resources/currency-codes) in uppercase. For example, **EUR**.  The sweep currency must match any of the [balances currencies](https://docs.adyen.com/api-explorer/#/balanceplatform/latest/get/balanceAccounts/{id}__resParam_balances).</value>
        [JsonPropertyName("currency")]
        public string Currency { get; set; }

        /// <summary>
        /// The unique identifier of the sweep.
        /// </summary>
        /// <value>The unique identifier of the sweep.</value>
        [JsonPropertyName("id")]
        public string Id { get; }

        /// <summary>
        /// Gets or Sets Schedule
        /// </summary>
        [JsonPropertyName("schedule")]
        public SweepSchedule Schedule { get; set; }

        /// <summary>
        /// Used to track the state of Description
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> _DescriptionOption { get; private set; }

        /// <summary>
        /// The message that will be used in the sweep transfer&#39;s description body with a maximum length of 140 characters.  If the message is longer after replacing placeholders, the message will be cut off at 140 characters.
        /// </summary>
        /// <value>The message that will be used in the sweep transfer&#39;s description body with a maximum length of 140 characters.  If the message is longer after replacing placeholders, the message will be cut off at 140 characters.</value>
        [JsonPropertyName("description")]
        public string? Description { get { return this._DescriptionOption; } set { this._DescriptionOption = new(value); } }

        /// <summary>
        /// Used to track the state of Priorities
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<SweepConfigurationV2.PrioritiesEnum>?> _PrioritiesOption { get; private set; }

        /// <summary>
        /// The list of priorities for the bank transfer. This sets the speed at which the transfer is sent and the fees that you have to pay. You can provide multiple priorities, ordered by your preference. Adyen will try to pay out using the priorities in the given order. If the first priority is not currently supported or enabled for your platform, the system will try the next one, and so on.  The request will be accepted as long as **at least one** of the provided priorities is valid (i.e., supported by Adyen and activated for your platform). For example, if you provide &#x60;[\&quot;wire\&quot;,\&quot;regular\&quot;]&#x60;, and &#x60;wire&#x60; is not supported but &#x60;regular&#x60; is, the request will still be accepted and processed.  Possible values:  * **regular**: for normal, low-value transactions.  * **fast**: a faster way to transfer funds, but the fees are higher. Recommended for high-priority, low-value transactions.  * **wire**: the fastest way to transfer funds, but this has the highest fees. Recommended for high-priority, high-value transactions.  * **instant**: for instant funds transfers within the United States and in [SEPA locations](https://www.ecb.europa.eu/paym/integration/retail/sepa/html/index.en.html).  * **crossBorder**: for high-value transfers to a recipient in a different country.  * **internal**: for transfers to an Adyen-issued business bank account (by bank account number/IBAN).  Set &#x60;category&#x60; to **bank**. For more details, see optional priorities setup for [marketplaces](https://docs.adyen.com/marketplaces/payout-to-users/scheduled-payouts#optional-priorities-setup) or [platforms](https://docs.adyen.com/platforms/payout-to-users/scheduled-payouts#optional-priorities-setup).
        /// </summary>
        /// <value>The list of priorities for the bank transfer. This sets the speed at which the transfer is sent and the fees that you have to pay. You can provide multiple priorities, ordered by your preference. Adyen will try to pay out using the priorities in the given order. If the first priority is not currently supported or enabled for your platform, the system will try the next one, and so on.  The request will be accepted as long as **at least one** of the provided priorities is valid (i.e., supported by Adyen and activated for your platform). For example, if you provide &#x60;[\&quot;wire\&quot;,\&quot;regular\&quot;]&#x60;, and &#x60;wire&#x60; is not supported but &#x60;regular&#x60; is, the request will still be accepted and processed.  Possible values:  * **regular**: for normal, low-value transactions.  * **fast**: a faster way to transfer funds, but the fees are higher. Recommended for high-priority, low-value transactions.  * **wire**: the fastest way to transfer funds, but this has the highest fees. Recommended for high-priority, high-value transactions.  * **instant**: for instant funds transfers within the United States and in [SEPA locations](https://www.ecb.europa.eu/paym/integration/retail/sepa/html/index.en.html).  * **crossBorder**: for high-value transfers to a recipient in a different country.  * **internal**: for transfers to an Adyen-issued business bank account (by bank account number/IBAN).  Set &#x60;category&#x60; to **bank**. For more details, see optional priorities setup for [marketplaces](https://docs.adyen.com/marketplaces/payout-to-users/scheduled-payouts#optional-priorities-setup) or [platforms](https://docs.adyen.com/platforms/payout-to-users/scheduled-payouts#optional-priorities-setup).</value>
        [JsonPropertyName("priorities")]
        public List<SweepConfigurationV2.PrioritiesEnum>? Priorities { get { return this._PrioritiesOption; } set { this._PrioritiesOption = new(value); } }

        /// <summary>
        /// Used to track the state of ReasonDetail
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> _ReasonDetailOption { get; }

        /// <summary>
        /// The human readable reason for disabling the sweep.
        /// </summary>
        /// <value>The human readable reason for disabling the sweep.</value>
        [JsonPropertyName("reasonDetail")]
        public string? ReasonDetail { get { return this._ReasonDetailOption; } }

        /// <summary>
        /// Used to track the state of Reference
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> _ReferenceOption { get; private set; }

        /// <summary>
        /// Your reference for the sweep configuration.
        /// </summary>
        /// <value>Your reference for the sweep configuration.</value>
        [JsonPropertyName("reference")]
        public string? Reference { get { return this._ReferenceOption; } set { this._ReferenceOption = new(value); } }

        /// <summary>
        /// Used to track the state of ReferenceForBeneficiary
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> _ReferenceForBeneficiaryOption { get; private set; }

        /// <summary>
        /// The reference sent to or received from the counterparty. Only alphanumeric characters are allowed.
        /// </summary>
        /// <value>The reference sent to or received from the counterparty. Only alphanumeric characters are allowed.</value>
        [JsonPropertyName("referenceForBeneficiary")]
        public string? ReferenceForBeneficiary { get { return this._ReferenceForBeneficiaryOption; } set { this._ReferenceForBeneficiaryOption = new(value); } }

        /// <summary>
        /// Used to track the state of SweepAmount
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<Amount?> _SweepAmountOption { get; private set; }

        /// <summary>
        /// Gets or Sets SweepAmount
        /// </summary>
        [JsonPropertyName("sweepAmount")]
        public Amount? SweepAmount { get { return this._SweepAmountOption; } set { this._SweepAmountOption = new(value); } }

        /// <summary>
        /// Used to track the state of TargetAmount
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<Amount?> _TargetAmountOption { get; private set; }

        /// <summary>
        /// Gets or Sets TargetAmount
        /// </summary>
        [JsonPropertyName("targetAmount")]
        public Amount? TargetAmount { get { return this._TargetAmountOption; } set { this._TargetAmountOption = new(value); } }

        /// <summary>
        /// Used to track the state of TriggerAmount
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<Amount?> _TriggerAmountOption { get; private set; }

        /// <summary>
        /// Gets or Sets TriggerAmount
        /// </summary>
        [JsonPropertyName("triggerAmount")]
        public Amount? TriggerAmount { get { return this._TriggerAmountOption; } set { this._TriggerAmountOption = new(value); } }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class SweepConfigurationV2 {\n");
            sb.Append("  Counterparty: ").Append(Counterparty).Append("\n");
            sb.Append("  Currency: ").Append(Currency).Append("\n");
            sb.Append("  Id: ").Append(Id).Append("\n");
            sb.Append("  Schedule: ").Append(Schedule).Append("\n");
            sb.Append("  Category: ").Append(Category).Append("\n");
            sb.Append("  Description: ").Append(Description).Append("\n");
            sb.Append("  Priorities: ").Append(Priorities).Append("\n");
            sb.Append("  Reason: ").Append(Reason).Append("\n");
            sb.Append("  ReasonDetail: ").Append(ReasonDetail).Append("\n");
            sb.Append("  Reference: ").Append(Reference).Append("\n");
            sb.Append("  ReferenceForBeneficiary: ").Append(ReferenceForBeneficiary).Append("\n");
            sb.Append("  Status: ").Append(Status).Append("\n");
            sb.Append("  SweepAmount: ").Append(SweepAmount).Append("\n");
            sb.Append("  TargetAmount: ").Append(TargetAmount).Append("\n");
            sb.Append("  TriggerAmount: ").Append(TriggerAmount).Append("\n");
            sb.Append("  Type: ").Append(Type).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // Reference (string) maxLength
            if (this.Reference != null && this.Reference.Length > 80)
            {
                yield return new ValidationResult("Invalid value for Reference, length must be less than 80.", new [] { "Reference" });
            }

            // ReferenceForBeneficiary (string) maxLength
            if (this.ReferenceForBeneficiary != null && this.ReferenceForBeneficiary.Length > 80)
            {
                yield return new ValidationResult("Invalid value for ReferenceForBeneficiary, length must be less than 80.", new [] { "ReferenceForBeneficiary" });
            }

            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="SweepConfigurationV2" />
    /// </summary>
    public class SweepConfigurationV2JsonConverter : JsonConverter<SweepConfigurationV2>
    {
        /// <summary>
        /// Deserializes json to <see cref="SweepConfigurationV2"/>.
        /// </summary>
        /// <param name="utf8JsonReader"><see cref="Utf8JsonReader"/>.</param>
        /// <param name="typeToConvert"><see cref="Type"/>.</param>
        /// <param name="jsonSerializerOptions">The <see cref="JsonSerializerOptions"/>, initialized from <see cref="HostConfiguration"/>.</param>
        /// <returns><see cref="SweepConfigurationV2"/>.</returns>
        /// <exception cref="JsonException"></exception>
        public override SweepConfigurationV2 Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<SweepCounterparty?> counterparty = default;
            Option<string?> currency = default;
            Option<string?> id = default;
            Option<SweepSchedule?> schedule = default;
            Option<SweepConfigurationV2.CategoryEnum?> category = default;
            Option<string?> description = default;
            Option<List<SweepConfigurationV2.PrioritiesEnum>?> priorities = default;
            Option<SweepConfigurationV2.ReasonEnum?> reason = default;
            Option<string?> reasonDetail = default;
            Option<string?> reference = default;
            Option<string?> referenceForBeneficiary = default;
            Option<SweepConfigurationV2.StatusEnum?> status = default;
            Option<Amount?> sweepAmount = default;
            Option<Amount?> targetAmount = default;
            Option<Amount?> triggerAmount = default;
            Option<SweepConfigurationV2.TypeEnum?> type = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? jsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (jsonPropertyName)
                    {
                        case "counterparty":
                            counterparty = new Option<SweepCounterparty?>(JsonSerializer.Deserialize<SweepCounterparty>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "currency":
                            currency = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "id":
                            id = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "schedule":
                            schedule = new Option<SweepSchedule?>(JsonSerializer.Deserialize<SweepSchedule>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "category":
                            string? categoryRawValue = utf8JsonReader.GetString();
                            category = new Option<SweepConfigurationV2.CategoryEnum?>(SweepConfigurationV2.CategoryEnum.FromStringOrDefault(categoryRawValue));
                            break;
                        case "description":
                            description = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "priorities":
                            priorities = new Option<List<SweepConfigurationV2.PrioritiesEnum>?>(JsonSerializer.Deserialize<List<SweepConfigurationV2.PrioritiesEnum>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "reason":
                            string? reasonRawValue = utf8JsonReader.GetString();
                            reason = new Option<SweepConfigurationV2.ReasonEnum?>(SweepConfigurationV2.ReasonEnum.FromStringOrDefault(reasonRawValue));
                            break;
                        case "reasonDetail":
                            reasonDetail = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "reference":
                            reference = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "referenceForBeneficiary":
                            referenceForBeneficiary = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "status":
                            string? statusRawValue = utf8JsonReader.GetString();
                            status = new Option<SweepConfigurationV2.StatusEnum?>(SweepConfigurationV2.StatusEnum.FromStringOrDefault(statusRawValue));
                            break;
                        case "sweepAmount":
                            sweepAmount = new Option<Amount?>(JsonSerializer.Deserialize<Amount>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "targetAmount":
                            targetAmount = new Option<Amount?>(JsonSerializer.Deserialize<Amount>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "triggerAmount":
                            triggerAmount = new Option<Amount?>(JsonSerializer.Deserialize<Amount>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "type":
                            string? typeRawValue = utf8JsonReader.GetString();
                            type = new Option<SweepConfigurationV2.TypeEnum?>(SweepConfigurationV2.TypeEnum.FromStringOrDefault(typeRawValue));
                            break;
                        default:
                            break;
                    }
                }
            }
            
            if (!counterparty.IsSet)
                throw new ArgumentException("Property is required for class SweepConfigurationV2.", nameof(counterparty));

            if (!currency.IsSet)
                throw new ArgumentException("Property is required for class SweepConfigurationV2.", nameof(currency));

            if (!id.IsSet)
                throw new ArgumentException("Property is required for class SweepConfigurationV2.", nameof(id));

            if (!schedule.IsSet)
                throw new ArgumentException("Property is required for class SweepConfigurationV2.", nameof(schedule));

            return new SweepConfigurationV2(counterparty.Value!, currency.Value!, id.Value!, schedule.Value!, category, description, priorities, reason, reasonDetail, reference, referenceForBeneficiary, status, sweepAmount, targetAmount, triggerAmount, type);
        }

        /// <summary>
        /// Serializes a <see cref="SweepConfigurationV2"/>.
        /// </summary>
        /// <param name="writer"><see cref="Utf8JsonWriter"/></param>
        /// <param name="sweepConfigurationV2"></param>
        /// <param name="jsonSerializerOptions"><see cref="JsonSerializerOptions"/></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, SweepConfigurationV2 sweepConfigurationV2, JsonSerializerOptions jsonSerializerOptions)
        {
            
            writer.WriteStartObject();
            
            WriteProperties(writer, sweepConfigurationV2, jsonSerializerOptions);
            
            writer.WriteEndObject();
            
        }

        /// <summary>
        /// Serializes the properties of <see cref="SweepConfigurationV2"/>.
        /// </summary>
        /// <param name="writer"><see creft="Utf8JsonWriter"/></param>
        /// <param name="sweepConfigurationV2"></param>
        /// <param name="jsonSerializerOptions"><see cref="JsonSerializerOptions"/></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, SweepConfigurationV2 sweepConfigurationV2, JsonSerializerOptions jsonSerializerOptions)
        {
            
            writer.WritePropertyName("counterparty");
            JsonSerializer.Serialize(writer, sweepConfigurationV2.Counterparty, jsonSerializerOptions);
            if (sweepConfigurationV2.Currency != null)
                writer.WriteString("currency", sweepConfigurationV2.Currency);

            if (sweepConfigurationV2.Id != null)
                writer.WriteString("id", sweepConfigurationV2.Id);

            writer.WritePropertyName("schedule");
            JsonSerializer.Serialize(writer, sweepConfigurationV2.Schedule, jsonSerializerOptions);
            if (sweepConfigurationV2._CategoryOption.IsSet && sweepConfigurationV2.Category != null) 
            {
                string? categoryRawValue = SweepConfigurationV2.CategoryEnum.ToJsonValue(sweepConfigurationV2._CategoryOption.Value!.Value);
                writer.WriteString("category", categoryRawValue);
            }
            
            if (sweepConfigurationV2._DescriptionOption.IsSet)
                if (sweepConfigurationV2.Description != null)
                    writer.WriteString("description", sweepConfigurationV2.Description);

            if (sweepConfigurationV2._PrioritiesOption.IsSet)
            {
                writer.WritePropertyName("priorities");
                JsonSerializer.Serialize(writer, sweepConfigurationV2.Priorities, jsonSerializerOptions);
            }
            if (sweepConfigurationV2._ReasonOption.IsSet && sweepConfigurationV2.Reason != null) 
            {
                string? reasonRawValue = SweepConfigurationV2.ReasonEnum.ToJsonValue(sweepConfigurationV2._ReasonOption.Value!.Value);
                writer.WriteString("reason", reasonRawValue);
            }
            
            if (sweepConfigurationV2._ReasonDetailOption.IsSet)
                if (sweepConfigurationV2.ReasonDetail != null)
                    writer.WriteString("reasonDetail", sweepConfigurationV2.ReasonDetail);

            if (sweepConfigurationV2._ReferenceOption.IsSet)
                if (sweepConfigurationV2.Reference != null)
                    writer.WriteString("reference", sweepConfigurationV2.Reference);

            if (sweepConfigurationV2._ReferenceForBeneficiaryOption.IsSet)
                if (sweepConfigurationV2.ReferenceForBeneficiary != null)
                    writer.WriteString("referenceForBeneficiary", sweepConfigurationV2.ReferenceForBeneficiary);

            if (sweepConfigurationV2._StatusOption.IsSet && sweepConfigurationV2.Status != null) 
            {
                string? statusRawValue = SweepConfigurationV2.StatusEnum.ToJsonValue(sweepConfigurationV2._StatusOption.Value!.Value);
                writer.WriteString("status", statusRawValue);
            }
            
            if (sweepConfigurationV2._SweepAmountOption.IsSet)
            {
                writer.WritePropertyName("sweepAmount");
                JsonSerializer.Serialize(writer, sweepConfigurationV2.SweepAmount, jsonSerializerOptions);
            }
            if (sweepConfigurationV2._TargetAmountOption.IsSet)
            {
                writer.WritePropertyName("targetAmount");
                JsonSerializer.Serialize(writer, sweepConfigurationV2.TargetAmount, jsonSerializerOptions);
            }
            if (sweepConfigurationV2._TriggerAmountOption.IsSet)
            {
                writer.WritePropertyName("triggerAmount");
                JsonSerializer.Serialize(writer, sweepConfigurationV2.TriggerAmount, jsonSerializerOptions);
            }
            if (sweepConfigurationV2._TypeOption.IsSet && sweepConfigurationV2.Type != null) 
            {
                string? typeRawValue = SweepConfigurationV2.TypeEnum.ToJsonValue(sweepConfigurationV2._TypeOption.Value!.Value);
                writer.WriteString("type", typeRawValue);
            }
        }
    }
}
