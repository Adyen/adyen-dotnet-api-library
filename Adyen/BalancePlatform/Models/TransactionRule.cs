// <auto-generated>
/*
 * Configuration API
 *
 * The Configuration API allows you to manage your balance platform where you can create account holders, balance accounts, cards, and business accounts.  ## Authentication Each request to the Configuration API must be signed with an API key. Generate an API key in your Customer Area if you have a [platform setup](https://docs.adyen.com/platforms/manage-access/api-credentials-web-service/#generate-api-key) or [marketplace setup](https://docs.adyen.com/marketplaces/manage-access/api-credentials-web-service/#generate-api-key).   If you have an Adyen Issuing integration, [generate an API key](https://docs.adyen.com/issuing/manage-access/api-credentials-web-service/#generate-api-key) in your Balance Platform Customer Area.  To connect to the API, add an `X-API-Key` header with the API key as the value, for example:   ``` curl -H \"Content-Type: application/json\" \\ -H \"X-API-Key: YOUR_API_KEY\" \\ ... ```  ## Versioning The Configuration API supports [versioning](https://docs.adyen.com/development-resources/versioning) using a version suffix in the endpoint URL. This suffix has the following format: \"vXX\", where XX is the version number.  For example: ``` https://balanceplatform-api-test.adyen.com/bcl/v2/accountHolders ``` ## Going live When going live, generate an API key in your [live Customer Area](https://ca-live.adyen.com/ca/) if you have an Adyen for Platforms integration or [live Balance Platform Customer Area](https://balanceplatform-live.adyen.com/balanceplatform/) if you have an Adyen Issuing integration.You can then use the API key to send requests to `https://balanceplatform-api-live.adyen.com/bcl/v2`.
 *
 * The version of the OpenAPI document: 2
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using Adyen.Core;
using Adyen.BalancePlatform.Client;

namespace Adyen.BalancePlatform.Models
{
    /// <summary>
    /// TransactionRule.
    /// </summary>
    public partial class TransactionRule : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TransactionRule" /> class.
        /// </summary>
        /// <param name="description">Your description for the transaction rule.</param>
        /// <param name="entityKey">entityKey</param>
        /// <param name="interval">interval</param>
        /// <param name="reference">Your reference for the transaction rule.</param>
        /// <param name="ruleRestrictions">ruleRestrictions</param>
        /// <param name="type">The [type of rule](https://docs.adyen.com/issuing/transaction-rules#rule-types), which defines if a rule blocks transactions based on individual characteristics or accumulates data.  Possible values:  * **blockList**: decline a transaction when the conditions are met.  * **maxUsage**: add the amount or number of transactions for the lifetime of a payment instrument, and then decline a transaction when the specified limits are met.  * **velocity**: add the amount or number of transactions based on a specified time interval, and then decline a transaction when the specified limits are met. </param>
        /// <param name="aggregationLevel">The level at which data must be accumulated, used in rules with &#x60;type&#x60; **velocity** or **maxUsage**. The level must be the [same or lower in hierarchy](https://docs.adyen.com/issuing/transaction-rules#accumulate-data) than the &#x60;entityKey&#x60;.  If not provided, by default, the rule will accumulate data at the **paymentInstrument** level.  Possible values: **paymentInstrument**, **paymentInstrumentGroup**, **balanceAccount**, **accountHolder**, **balancePlatform**.</param>
        /// <param name="endDate">The date when the rule will stop being evaluated, in ISO 8601 extended offset date-time format. For example, **2025-03-19T10:15:30+01:00**.  If not provided, the rule will be evaluated until the rule status is set to **inactive**.</param>
        /// <param name="id">The unique identifier of the transaction rule.</param>
        /// <param name="outcomeType">The [outcome](https://docs.adyen.com/issuing/transaction-rules#outcome) that will be applied when a transaction meets the conditions of the rule.  Possible values: * **hardBlock** (default): the transaction is declined. * **scoreBased**: the transaction is assigned the &#x60;score&#x60; you specified. Adyen calculates the total score and if it exceeds 100, the transaction is declined. This value is not allowed when &#x60;requestType&#x60; is **bankTransfer**.  * **enforceSCA**: your user is prompted to verify their identity using [3D Secure authentication](https://docs.adyen.com/issuing/3d-secure/). If the authentication fails or times out, the transaction is declined. This value is only allowed when &#x60;requestType&#x60; is **authentication**.</param>
        /// <param name="requestType">Indicates the type of request to which the rule applies. If not provided, by default, this is set to **authorization**.  Possible values: **authorization**, **authentication**, **tokenization**, **bankTransfer**.</param>
        /// <param name="score">A positive or negative score applied to the transaction if it meets the conditions of the rule. Required when &#x60;outcomeType&#x60; is **scoreBased**.  The value must be between **-100** and **100**.</param>
        /// <param name="startDate">The date when the rule will start to be evaluated, in ISO 8601 extended offset date-time format. For example, **2025-03-19T10:15:30+01:00**.  If not provided when creating a transaction rule, the &#x60;startDate&#x60; is set to the date when the rule status is set to **active**.   </param>
        /// <param name="status">The status of the transaction rule. If you provide a &#x60;startDate&#x60; in the request, the rule is automatically created  with an **active** status.   Possible values: **active**, **inactive**.</param>
        [JsonConstructor]
        public TransactionRule(string description, TransactionRuleEntityKey entityKey, TransactionRuleInterval interval, string reference, TransactionRuleRestrictions ruleRestrictions, TypeEnum type, Option<string?> aggregationLevel = default, Option<string?> endDate = default, Option<string?> id = default, Option<OutcomeTypeEnum?> outcomeType = default, Option<RequestTypeEnum?> requestType = default, Option<int?> score = default, Option<string?> startDate = default, Option<StatusEnum?> status = default)
        {
            Description = description;
            EntityKey = entityKey;
            Interval = interval;
            Reference = reference;
            RuleRestrictions = ruleRestrictions;
            Type = type;
            _AggregationLevelOption = aggregationLevel;
            _EndDateOption = endDate;
            _IdOption = id;
            _OutcomeTypeOption = outcomeType;
            _RequestTypeOption = requestType;
            _ScoreOption = score;
            _StartDateOption = startDate;
            _StatusOption = status;
            OnCreated();
        }
        
        /// <summary>
        /// Best practice: Use the constructor to initialize your objects to understand which parameters are required/optional.
        /// </summary>
        public TransactionRule()
        {
        }

        partial void OnCreated();

        /// <summary>
        /// The [type of rule](https://docs.adyen.com/issuing/transaction-rules#rule-types), which defines if a rule blocks transactions based on individual characteristics or accumulates data.  Possible values:  * **blockList**: decline a transaction when the conditions are met.  * **maxUsage**: add the amount or number of transactions for the lifetime of a payment instrument, and then decline a transaction when the specified limits are met.  * **velocity**: add the amount or number of transactions based on a specified time interval, and then decline a transaction when the specified limits are met. 
        /// </summary>
        /// <value>The [type of rule](https://docs.adyen.com/issuing/transaction-rules#rule-types), which defines if a rule blocks transactions based on individual characteristics or accumulates data.  Possible values:  * **blockList**: decline a transaction when the conditions are met.  * **maxUsage**: add the amount or number of transactions for the lifetime of a payment instrument, and then decline a transaction when the specified limits are met.  * **velocity**: add the amount or number of transactions based on a specified time interval, and then decline a transaction when the specified limits are met. </value>
        [JsonConverter(typeof(TypeEnumJsonConverter))]
        public class TypeEnum : IEnum
        {
            /// <summary>
            /// Returns the value of the TypeEnum.
            /// </summary>
            public string? Value { get; set; }

            /// <summary>
            /// TypeEnum.AllowList - allowList
            /// </summary>
            public static readonly TypeEnum AllowList = new("allowList");

            /// <summary>
            /// TypeEnum.BlockList - blockList
            /// </summary>
            public static readonly TypeEnum BlockList = new("blockList");

            /// <summary>
            /// TypeEnum.MaxUsage - maxUsage
            /// </summary>
            public static readonly TypeEnum MaxUsage = new("maxUsage");

            /// <summary>
            /// TypeEnum.Velocity - velocity
            /// </summary>
            public static readonly TypeEnum Velocity = new("velocity");
        
            private TypeEnum(string? value)
            {
                Value = value;
            }

            /// <summary>
            /// Converts a string to a <see cref="TypeEnum"/> implicitly.
            /// </summary>
            /// <param name="value">The string value to convert. Defaults to null.</param>
            /// <returns>A new <see cref="TypeEnum"/> instance initialized with the string value.</returns>
            public static implicit operator TypeEnum?(string? value) => value == null ? null : new TypeEnum(value);
    
            /// <summary>
            /// Converts a <see cref="TypeEnum"/> instance to a string implicitly.
            /// </summary>
            /// <param name="option">The <see cref="TypeEnum"/> instance. Default to null.</param>
            /// <returns>String value of the <see cref="TypeEnum"/> instance./// </returns>
            public static implicit operator string?(TypeEnum? option) => option?.Value;
        
            public static bool operator ==(TypeEnum? left, TypeEnum? right) => string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);
    
            public static bool operator !=(TypeEnum? left, TypeEnum? right) => !string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);

            public override bool Equals(object? obj) => obj is TypeEnum other && string.Equals(Value, other.Value, StringComparison.OrdinalIgnoreCase);
    
            public override int GetHashCode() => Value?.GetHashCode() ?? 0;
        
            public override string ToString() => Value ?? string.Empty;
        
            /// <summary>
            /// Returns a <see cref="TypeEnum?"/>.
            /// </summary>
            /// <param name="value"></param>
            /// <returns><see cref="TypeEnum"/> or null.</returns>
            public static TypeEnum? FromStringOrDefault(string value)
            {
                return value switch {
                    "allowList" => TypeEnum.AllowList,
                    "blockList" => TypeEnum.BlockList,
                    "maxUsage" => TypeEnum.MaxUsage,
                    "velocity" => TypeEnum.Velocity,
                    _ => null,
                };
            }
    
            /// <summary>
            /// Converts the <see cref="TypeEnum"/> to the json value.
            /// </summary>
            /// <param name="value"><see cref="TypeEnum"/></param>
            /// <returns>String value of the enum.</returns>
            /// <exception cref="NotImplementedException"></exception>
            public static string? ToJsonValue(TypeEnum? value)
            {
                if (value == null)
                    return null;
            
                if (value == TypeEnum.AllowList)
                    return "allowList";
                
                if (value == TypeEnum.BlockList)
                    return "blockList";
                
                if (value == TypeEnum.MaxUsage)
                    return "maxUsage";
                
                if (value == TypeEnum.Velocity)
                    return "velocity";
                
                return null;
            }
            
            /// <summary>
            /// JsonConverter for writing TypeEnum.               
            /// </summary>
            public class TypeEnumJsonConverter : JsonConverter<TypeEnum>
            {
                public override TypeEnum? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions jsonOptions)
                {
                    string value = reader.GetString();
                    return value == null ? null : TypeEnum.FromStringOrDefault(value) ?? new TypeEnum(value);
                }

                public override void Write(Utf8JsonWriter writer, TypeEnum value, JsonSerializerOptions jsonOptions)
                {
                    writer.WriteStringValue(TypeEnum.ToJsonValue(value));
                }
            }
        }

        /// <summary>
        /// The [type of rule](https://docs.adyen.com/issuing/transaction-rules#rule-types), which defines if a rule blocks transactions based on individual characteristics or accumulates data.  Possible values:  * **blockList**: decline a transaction when the conditions are met.  * **maxUsage**: add the amount or number of transactions for the lifetime of a payment instrument, and then decline a transaction when the specified limits are met.  * **velocity**: add the amount or number of transactions based on a specified time interval, and then decline a transaction when the specified limits are met. 
        /// </summary>
        /// <value>The [type of rule](https://docs.adyen.com/issuing/transaction-rules#rule-types), which defines if a rule blocks transactions based on individual characteristics or accumulates data.  Possible values:  * **blockList**: decline a transaction when the conditions are met.  * **maxUsage**: add the amount or number of transactions for the lifetime of a payment instrument, and then decline a transaction when the specified limits are met.  * **velocity**: add the amount or number of transactions based on a specified time interval, and then decline a transaction when the specified limits are met. </value>
        [JsonPropertyName("type")]
        public TypeEnum Type { get; set; }

        /// <summary>
        /// The [outcome](https://docs.adyen.com/issuing/transaction-rules#outcome) that will be applied when a transaction meets the conditions of the rule.  Possible values: * **hardBlock** (default): the transaction is declined. * **scoreBased**: the transaction is assigned the `score` you specified. Adyen calculates the total score and if it exceeds 100, the transaction is declined. This value is not allowed when `requestType` is **bankTransfer**.  * **enforceSCA**: your user is prompted to verify their identity using [3D Secure authentication](https://docs.adyen.com/issuing/3d-secure/). If the authentication fails or times out, the transaction is declined. This value is only allowed when `requestType` is **authentication**.
        /// </summary>
        /// <value>The [outcome](https://docs.adyen.com/issuing/transaction-rules#outcome) that will be applied when a transaction meets the conditions of the rule.  Possible values: * **hardBlock** (default): the transaction is declined. * **scoreBased**: the transaction is assigned the &#x60;score&#x60; you specified. Adyen calculates the total score and if it exceeds 100, the transaction is declined. This value is not allowed when &#x60;requestType&#x60; is **bankTransfer**.  * **enforceSCA**: your user is prompted to verify their identity using [3D Secure authentication](https://docs.adyen.com/issuing/3d-secure/). If the authentication fails or times out, the transaction is declined. This value is only allowed when &#x60;requestType&#x60; is **authentication**.</value>
        [JsonConverter(typeof(OutcomeTypeEnumJsonConverter))]
        public class OutcomeTypeEnum : IEnum
        {
            /// <summary>
            /// Returns the value of the OutcomeTypeEnum.
            /// </summary>
            public string? Value { get; set; }

            /// <summary>
            /// OutcomeTypeEnum.EnforceSCA - enforceSCA
            /// </summary>
            public static readonly OutcomeTypeEnum EnforceSCA = new("enforceSCA");

            /// <summary>
            /// OutcomeTypeEnum.HardBlock - hardBlock
            /// </summary>
            public static readonly OutcomeTypeEnum HardBlock = new("hardBlock");

            /// <summary>
            /// OutcomeTypeEnum.ScoreBased - scoreBased
            /// </summary>
            public static readonly OutcomeTypeEnum ScoreBased = new("scoreBased");

            /// <summary>
            /// OutcomeTypeEnum.TimedBlock - timedBlock
            /// </summary>
            public static readonly OutcomeTypeEnum TimedBlock = new("timedBlock");
        
            private OutcomeTypeEnum(string? value)
            {
                Value = value;
            }

            /// <summary>
            /// Converts a string to a <see cref="OutcomeTypeEnum"/> implicitly.
            /// </summary>
            /// <param name="value">The string value to convert. Defaults to null.</param>
            /// <returns>A new <see cref="OutcomeTypeEnum"/> instance initialized with the string value.</returns>
            public static implicit operator OutcomeTypeEnum?(string? value) => value == null ? null : new OutcomeTypeEnum(value);
    
            /// <summary>
            /// Converts a <see cref="OutcomeTypeEnum"/> instance to a string implicitly.
            /// </summary>
            /// <param name="option">The <see cref="OutcomeTypeEnum"/> instance. Default to null.</param>
            /// <returns>String value of the <see cref="OutcomeTypeEnum"/> instance./// </returns>
            public static implicit operator string?(OutcomeTypeEnum? option) => option?.Value;
        
            public static bool operator ==(OutcomeTypeEnum? left, OutcomeTypeEnum? right) => string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);
    
            public static bool operator !=(OutcomeTypeEnum? left, OutcomeTypeEnum? right) => !string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);

            public override bool Equals(object? obj) => obj is OutcomeTypeEnum other && string.Equals(Value, other.Value, StringComparison.OrdinalIgnoreCase);
    
            public override int GetHashCode() => Value?.GetHashCode() ?? 0;
        
            public override string ToString() => Value ?? string.Empty;
        
            /// <summary>
            /// Returns a <see cref="OutcomeTypeEnum?"/>.
            /// </summary>
            /// <param name="value"></param>
            /// <returns><see cref="OutcomeTypeEnum"/> or null.</returns>
            public static OutcomeTypeEnum? FromStringOrDefault(string value)
            {
                return value switch {
                    "enforceSCA" => OutcomeTypeEnum.EnforceSCA,
                    "hardBlock" => OutcomeTypeEnum.HardBlock,
                    "scoreBased" => OutcomeTypeEnum.ScoreBased,
                    "timedBlock" => OutcomeTypeEnum.TimedBlock,
                    _ => null,
                };
            }
    
            /// <summary>
            /// Converts the <see cref="OutcomeTypeEnum"/> to the json value.
            /// </summary>
            /// <param name="value"><see cref="OutcomeTypeEnum"/></param>
            /// <returns>String value of the enum.</returns>
            /// <exception cref="NotImplementedException"></exception>
            public static string? ToJsonValue(OutcomeTypeEnum? value)
            {
                if (value == null)
                    return null;
            
                if (value == OutcomeTypeEnum.EnforceSCA)
                    return "enforceSCA";
                
                if (value == OutcomeTypeEnum.HardBlock)
                    return "hardBlock";
                
                if (value == OutcomeTypeEnum.ScoreBased)
                    return "scoreBased";
                
                if (value == OutcomeTypeEnum.TimedBlock)
                    return "timedBlock";
                
                return null;
            }
            
            /// <summary>
            /// JsonConverter for writing OutcomeTypeEnum.               
            /// </summary>
            public class OutcomeTypeEnumJsonConverter : JsonConverter<OutcomeTypeEnum>
            {
                public override OutcomeTypeEnum? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions jsonOptions)
                {
                    string value = reader.GetString();
                    return value == null ? null : OutcomeTypeEnum.FromStringOrDefault(value) ?? new OutcomeTypeEnum(value);
                }

                public override void Write(Utf8JsonWriter writer, OutcomeTypeEnum value, JsonSerializerOptions jsonOptions)
                {
                    writer.WriteStringValue(OutcomeTypeEnum.ToJsonValue(value));
                }
            }
        }

        /// <summary>
        /// This is used to track if an optional field is set. If set, <see cref="OutcomeType"/> will be populated.
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<OutcomeTypeEnum?> _OutcomeTypeOption { get; private set; }

        /// <summary>
        /// The [outcome](https://docs.adyen.com/issuing/transaction-rules#outcome) that will be applied when a transaction meets the conditions of the rule.  Possible values: * **hardBlock** (default): the transaction is declined. * **scoreBased**: the transaction is assigned the `score` you specified. Adyen calculates the total score and if it exceeds 100, the transaction is declined. This value is not allowed when `requestType` is **bankTransfer**.  * **enforceSCA**: your user is prompted to verify their identity using [3D Secure authentication](https://docs.adyen.com/issuing/3d-secure/). If the authentication fails or times out, the transaction is declined. This value is only allowed when `requestType` is **authentication**.
        /// </summary>
        /// <value>The [outcome](https://docs.adyen.com/issuing/transaction-rules#outcome) that will be applied when a transaction meets the conditions of the rule.  Possible values: * **hardBlock** (default): the transaction is declined. * **scoreBased**: the transaction is assigned the &#x60;score&#x60; you specified. Adyen calculates the total score and if it exceeds 100, the transaction is declined. This value is not allowed when &#x60;requestType&#x60; is **bankTransfer**.  * **enforceSCA**: your user is prompted to verify their identity using [3D Secure authentication](https://docs.adyen.com/issuing/3d-secure/). If the authentication fails or times out, the transaction is declined. This value is only allowed when &#x60;requestType&#x60; is **authentication**.</value>
        [JsonPropertyName("outcomeType")]
        public OutcomeTypeEnum? OutcomeType { get { return this._OutcomeTypeOption; } set { this._OutcomeTypeOption = new(value); } }

        /// <summary>
        /// Indicates the type of request to which the rule applies. If not provided, by default, this is set to **authorization**.  Possible values: **authorization**, **authentication**, **tokenization**, **bankTransfer**.
        /// </summary>
        /// <value>Indicates the type of request to which the rule applies. If not provided, by default, this is set to **authorization**.  Possible values: **authorization**, **authentication**, **tokenization**, **bankTransfer**.</value>
        [JsonConverter(typeof(RequestTypeEnumJsonConverter))]
        public class RequestTypeEnum : IEnum
        {
            /// <summary>
            /// Returns the value of the RequestTypeEnum.
            /// </summary>
            public string? Value { get; set; }

            /// <summary>
            /// RequestTypeEnum.Authentication - authentication
            /// </summary>
            public static readonly RequestTypeEnum Authentication = new("authentication");

            /// <summary>
            /// RequestTypeEnum.Authorization - authorization
            /// </summary>
            public static readonly RequestTypeEnum Authorization = new("authorization");

            /// <summary>
            /// RequestTypeEnum.BankTransfer - bankTransfer
            /// </summary>
            public static readonly RequestTypeEnum BankTransfer = new("bankTransfer");

            /// <summary>
            /// RequestTypeEnum.Tokenization - tokenization
            /// </summary>
            public static readonly RequestTypeEnum Tokenization = new("tokenization");
        
            private RequestTypeEnum(string? value)
            {
                Value = value;
            }

            /// <summary>
            /// Converts a string to a <see cref="RequestTypeEnum"/> implicitly.
            /// </summary>
            /// <param name="value">The string value to convert. Defaults to null.</param>
            /// <returns>A new <see cref="RequestTypeEnum"/> instance initialized with the string value.</returns>
            public static implicit operator RequestTypeEnum?(string? value) => value == null ? null : new RequestTypeEnum(value);
    
            /// <summary>
            /// Converts a <see cref="RequestTypeEnum"/> instance to a string implicitly.
            /// </summary>
            /// <param name="option">The <see cref="RequestTypeEnum"/> instance. Default to null.</param>
            /// <returns>String value of the <see cref="RequestTypeEnum"/> instance./// </returns>
            public static implicit operator string?(RequestTypeEnum? option) => option?.Value;
        
            public static bool operator ==(RequestTypeEnum? left, RequestTypeEnum? right) => string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);
    
            public static bool operator !=(RequestTypeEnum? left, RequestTypeEnum? right) => !string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);

            public override bool Equals(object? obj) => obj is RequestTypeEnum other && string.Equals(Value, other.Value, StringComparison.OrdinalIgnoreCase);
    
            public override int GetHashCode() => Value?.GetHashCode() ?? 0;
        
            public override string ToString() => Value ?? string.Empty;
        
            /// <summary>
            /// Returns a <see cref="RequestTypeEnum?"/>.
            /// </summary>
            /// <param name="value"></param>
            /// <returns><see cref="RequestTypeEnum"/> or null.</returns>
            public static RequestTypeEnum? FromStringOrDefault(string value)
            {
                return value switch {
                    "authentication" => RequestTypeEnum.Authentication,
                    "authorization" => RequestTypeEnum.Authorization,
                    "bankTransfer" => RequestTypeEnum.BankTransfer,
                    "tokenization" => RequestTypeEnum.Tokenization,
                    _ => null,
                };
            }
    
            /// <summary>
            /// Converts the <see cref="RequestTypeEnum"/> to the json value.
            /// </summary>
            /// <param name="value"><see cref="RequestTypeEnum"/></param>
            /// <returns>String value of the enum.</returns>
            /// <exception cref="NotImplementedException"></exception>
            public static string? ToJsonValue(RequestTypeEnum? value)
            {
                if (value == null)
                    return null;
            
                if (value == RequestTypeEnum.Authentication)
                    return "authentication";
                
                if (value == RequestTypeEnum.Authorization)
                    return "authorization";
                
                if (value == RequestTypeEnum.BankTransfer)
                    return "bankTransfer";
                
                if (value == RequestTypeEnum.Tokenization)
                    return "tokenization";
                
                return null;
            }
            
            /// <summary>
            /// JsonConverter for writing RequestTypeEnum.               
            /// </summary>
            public class RequestTypeEnumJsonConverter : JsonConverter<RequestTypeEnum>
            {
                public override RequestTypeEnum? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions jsonOptions)
                {
                    string value = reader.GetString();
                    return value == null ? null : RequestTypeEnum.FromStringOrDefault(value) ?? new RequestTypeEnum(value);
                }

                public override void Write(Utf8JsonWriter writer, RequestTypeEnum value, JsonSerializerOptions jsonOptions)
                {
                    writer.WriteStringValue(RequestTypeEnum.ToJsonValue(value));
                }
            }
        }

        /// <summary>
        /// This is used to track if an optional field is set. If set, <see cref="RequestType"/> will be populated.
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<RequestTypeEnum?> _RequestTypeOption { get; private set; }

        /// <summary>
        /// Indicates the type of request to which the rule applies. If not provided, by default, this is set to **authorization**.  Possible values: **authorization**, **authentication**, **tokenization**, **bankTransfer**.
        /// </summary>
        /// <value>Indicates the type of request to which the rule applies. If not provided, by default, this is set to **authorization**.  Possible values: **authorization**, **authentication**, **tokenization**, **bankTransfer**.</value>
        [JsonPropertyName("requestType")]
        public RequestTypeEnum? RequestType { get { return this._RequestTypeOption; } set { this._RequestTypeOption = new(value); } }

        /// <summary>
        /// The status of the transaction rule. If you provide a `startDate` in the request, the rule is automatically created  with an **active** status.   Possible values: **active**, **inactive**.
        /// </summary>
        /// <value>The status of the transaction rule. If you provide a &#x60;startDate&#x60; in the request, the rule is automatically created  with an **active** status.   Possible values: **active**, **inactive**.</value>
        [JsonConverter(typeof(StatusEnumJsonConverter))]
        public class StatusEnum : IEnum
        {
            /// <summary>
            /// Returns the value of the StatusEnum.
            /// </summary>
            public string? Value { get; set; }

            /// <summary>
            /// StatusEnum.Active - active
            /// </summary>
            public static readonly StatusEnum Active = new("active");

            /// <summary>
            /// StatusEnum.Inactive - inactive
            /// </summary>
            public static readonly StatusEnum Inactive = new("inactive");
        
            private StatusEnum(string? value)
            {
                Value = value;
            }

            /// <summary>
            /// Converts a string to a <see cref="StatusEnum"/> implicitly.
            /// </summary>
            /// <param name="value">The string value to convert. Defaults to null.</param>
            /// <returns>A new <see cref="StatusEnum"/> instance initialized with the string value.</returns>
            public static implicit operator StatusEnum?(string? value) => value == null ? null : new StatusEnum(value);
    
            /// <summary>
            /// Converts a <see cref="StatusEnum"/> instance to a string implicitly.
            /// </summary>
            /// <param name="option">The <see cref="StatusEnum"/> instance. Default to null.</param>
            /// <returns>String value of the <see cref="StatusEnum"/> instance./// </returns>
            public static implicit operator string?(StatusEnum? option) => option?.Value;
        
            public static bool operator ==(StatusEnum? left, StatusEnum? right) => string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);
    
            public static bool operator !=(StatusEnum? left, StatusEnum? right) => !string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);

            public override bool Equals(object? obj) => obj is StatusEnum other && string.Equals(Value, other.Value, StringComparison.OrdinalIgnoreCase);
    
            public override int GetHashCode() => Value?.GetHashCode() ?? 0;
        
            public override string ToString() => Value ?? string.Empty;
        
            /// <summary>
            /// Returns a <see cref="StatusEnum?"/>.
            /// </summary>
            /// <param name="value"></param>
            /// <returns><see cref="StatusEnum"/> or null.</returns>
            public static StatusEnum? FromStringOrDefault(string value)
            {
                return value switch {
                    "active" => StatusEnum.Active,
                    "inactive" => StatusEnum.Inactive,
                    _ => null,
                };
            }
    
            /// <summary>
            /// Converts the <see cref="StatusEnum"/> to the json value.
            /// </summary>
            /// <param name="value"><see cref="StatusEnum"/></param>
            /// <returns>String value of the enum.</returns>
            /// <exception cref="NotImplementedException"></exception>
            public static string? ToJsonValue(StatusEnum? value)
            {
                if (value == null)
                    return null;
            
                if (value == StatusEnum.Active)
                    return "active";
                
                if (value == StatusEnum.Inactive)
                    return "inactive";
                
                return null;
            }
            
            /// <summary>
            /// JsonConverter for writing StatusEnum.               
            /// </summary>
            public class StatusEnumJsonConverter : JsonConverter<StatusEnum>
            {
                public override StatusEnum? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions jsonOptions)
                {
                    string value = reader.GetString();
                    return value == null ? null : StatusEnum.FromStringOrDefault(value) ?? new StatusEnum(value);
                }

                public override void Write(Utf8JsonWriter writer, StatusEnum value, JsonSerializerOptions jsonOptions)
                {
                    writer.WriteStringValue(StatusEnum.ToJsonValue(value));
                }
            }
        }

        /// <summary>
        /// This is used to track if an optional field is set. If set, <see cref="Status"/> will be populated.
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<StatusEnum?> _StatusOption { get; private set; }

        /// <summary>
        /// The status of the transaction rule. If you provide a `startDate` in the request, the rule is automatically created  with an **active** status.   Possible values: **active**, **inactive**.
        /// </summary>
        /// <value>The status of the transaction rule. If you provide a &#x60;startDate&#x60; in the request, the rule is automatically created  with an **active** status.   Possible values: **active**, **inactive**.</value>
        [JsonPropertyName("status")]
        public StatusEnum? Status { get { return this._StatusOption; } set { this._StatusOption = new(value); } }

        /// <summary>
        /// Your description for the transaction rule.
        /// </summary>
        /// <value>Your description for the transaction rule.</value>
        [JsonPropertyName("description")]
        public string Description { get; set; }

        /// <summary>
        /// <see cref="EntityKey"/>.
        /// </summary>
        [JsonPropertyName("entityKey")]
        public TransactionRuleEntityKey EntityKey { get; set; }

        /// <summary>
        /// <see cref="Interval"/>.
        /// </summary>
        [JsonPropertyName("interval")]
        public TransactionRuleInterval Interval { get; set; }

        /// <summary>
        /// Your reference for the transaction rule.
        /// </summary>
        /// <value>Your reference for the transaction rule.</value>
        [JsonPropertyName("reference")]
        public string Reference { get; set; }

        /// <summary>
        /// <see cref="RuleRestrictions"/>.
        /// </summary>
        [JsonPropertyName("ruleRestrictions")]
        public TransactionRuleRestrictions RuleRestrictions { get; set; }

        /// <summary>
        /// This is used to track if an optional field is set. If set, <see cref="AggregationLevel"/> will be populated.
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> _AggregationLevelOption { get; private set; }

        /// <summary>
        /// The level at which data must be accumulated, used in rules with &#x60;type&#x60; **velocity** or **maxUsage**. The level must be the [same or lower in hierarchy](https://docs.adyen.com/issuing/transaction-rules#accumulate-data) than the &#x60;entityKey&#x60;.  If not provided, by default, the rule will accumulate data at the **paymentInstrument** level.  Possible values: **paymentInstrument**, **paymentInstrumentGroup**, **balanceAccount**, **accountHolder**, **balancePlatform**.
        /// </summary>
        /// <value>The level at which data must be accumulated, used in rules with `type` **velocity** or **maxUsage**. The level must be the [same or lower in hierarchy](https://docs.adyen.com/issuing/transaction-rules#accumulate-data) than the `entityKey`.  If not provided, by default, the rule will accumulate data at the **paymentInstrument** level.  Possible values: **paymentInstrument**, **paymentInstrumentGroup**, **balanceAccount**, **accountHolder**, **balancePlatform**.</value>
        [JsonPropertyName("aggregationLevel")]
        public string? AggregationLevel { get { return this._AggregationLevelOption; } set { this._AggregationLevelOption = new(value); } }

        /// <summary>
        /// This is used to track if an optional field is set. If set, <see cref="EndDate"/> will be populated.
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> _EndDateOption { get; private set; }

        /// <summary>
        /// The date when the rule will stop being evaluated, in ISO 8601 extended offset date-time format. For example, **2025-03-19T10:15:30+01:00**.  If not provided, the rule will be evaluated until the rule status is set to **inactive**.
        /// </summary>
        /// <value>The date when the rule will stop being evaluated, in ISO 8601 extended offset date-time format. For example, **2025-03-19T10:15:30+01:00**.  If not provided, the rule will be evaluated until the rule status is set to **inactive**.</value>
        [JsonPropertyName("endDate")]
        public string? EndDate { get { return this._EndDateOption; } set { this._EndDateOption = new(value); } }

        /// <summary>
        /// This is used to track if an optional field is set. If set, <see cref="Id"/> will be populated.
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> _IdOption { get; private set; }

        /// <summary>
        /// The unique identifier of the transaction rule.
        /// </summary>
        /// <value>The unique identifier of the transaction rule.</value>
        [JsonPropertyName("id")]
        public string? Id { get { return this._IdOption; } set { this._IdOption = new(value); } }

        /// <summary>
        /// This is used to track if an optional field is set. If set, <see cref="Score"/> will be populated.
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> _ScoreOption { get; private set; }

        /// <summary>
        /// A positive or negative score applied to the transaction if it meets the conditions of the rule. Required when &#x60;outcomeType&#x60; is **scoreBased**.  The value must be between **-100** and **100**.
        /// </summary>
        /// <value>A positive or negative score applied to the transaction if it meets the conditions of the rule. Required when `outcomeType` is **scoreBased**.  The value must be between **-100** and **100**.</value>
        [JsonPropertyName("score")]
        public int? Score { get { return this._ScoreOption; } set { this._ScoreOption = new(value); } }

        /// <summary>
        /// This is used to track if an optional field is set. If set, <see cref="StartDate"/> will be populated.
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> _StartDateOption { get; private set; }

        /// <summary>
        /// The date when the rule will start to be evaluated, in ISO 8601 extended offset date-time format. For example, **2025-03-19T10:15:30+01:00**.  If not provided when creating a transaction rule, the &#x60;startDate&#x60; is set to the date when the rule status is set to **active**.   
        /// </summary>
        /// <value>The date when the rule will start to be evaluated, in ISO 8601 extended offset date-time format. For example, **2025-03-19T10:15:30+01:00**.  If not provided when creating a transaction rule, the `startDate` is set to the date when the rule status is set to **active**.   </value>
        [JsonPropertyName("startDate")]
        public string? StartDate { get { return this._StartDateOption; } set { this._StartDateOption = new(value); } }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class TransactionRule {\n");
            sb.Append("  Description: ").Append(Description).Append("\n");
            sb.Append("  EntityKey: ").Append(EntityKey).Append("\n");
            sb.Append("  Interval: ").Append(Interval).Append("\n");
            sb.Append("  Reference: ").Append(Reference).Append("\n");
            sb.Append("  RuleRestrictions: ").Append(RuleRestrictions).Append("\n");
            sb.Append("  Type: ").Append(Type).Append("\n");
            sb.Append("  AggregationLevel: ").Append(AggregationLevel).Append("\n");
            sb.Append("  EndDate: ").Append(EndDate).Append("\n");
            sb.Append("  Id: ").Append(Id).Append("\n");
            sb.Append("  OutcomeType: ").Append(OutcomeType).Append("\n");
            sb.Append("  RequestType: ").Append(RequestType).Append("\n");
            sb.Append("  Score: ").Append(Score).Append("\n");
            sb.Append("  StartDate: ").Append(StartDate).Append("\n");
            sb.Append("  Status: ").Append(Status).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // Description (string) maxLength
            if (this.Description != null && this.Description.Length > 300)
            {
                yield return new ValidationResult("Invalid value for Description, length must be less than 300.", new [] { "Description" });
            }

            // Reference (string) maxLength
            if (this.Reference != null && this.Reference.Length > 150)
            {
                yield return new ValidationResult("Invalid value for Reference, length must be less than 150.", new [] { "Reference" });
            }

            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="TransactionRule" />
    /// </summary>
    public class TransactionRuleJsonConverter : JsonConverter<TransactionRule>
    {
        /// <summary>
        /// Deserializes json to <see cref="TransactionRule"/>.
        /// </summary>
        /// <param name="utf8JsonReader"><see cref="Utf8JsonReader"/>.</param>
        /// <param name="typeToConvert"><see cref="Type"/>.</param>
        /// <param name="jsonSerializerOptions">The <see cref="JsonSerializerOptions"/>, initialized from <see cref="HostConfiguration"/>.</param>
        /// <returns><see cref="TransactionRule"/>.</returns>
        /// <exception cref="JsonException"></exception>
        public override TransactionRule Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<string?> description = default;
            Option<TransactionRuleEntityKey?> entityKey = default;
            Option<TransactionRuleInterval?> interval = default;
            Option<string?> reference = default;
            Option<TransactionRuleRestrictions?> ruleRestrictions = default;
            Option<TransactionRule.TypeEnum?> type = default;
            Option<string?> aggregationLevel = default;
            Option<string?> endDate = default;
            Option<string?> id = default;
            Option<TransactionRule.OutcomeTypeEnum?> outcomeType = default;
            Option<TransactionRule.RequestTypeEnum?> requestType = default;
            Option<int?> score = default;
            Option<string?> startDate = default;
            Option<TransactionRule.StatusEnum?> status = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? jsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (jsonPropertyName)
                    {
                        case "description":
                            description = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "entityKey":
                            entityKey = new Option<TransactionRuleEntityKey?>(JsonSerializer.Deserialize<TransactionRuleEntityKey>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "interval":
                            interval = new Option<TransactionRuleInterval?>(JsonSerializer.Deserialize<TransactionRuleInterval>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "reference":
                            reference = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "ruleRestrictions":
                            ruleRestrictions = new Option<TransactionRuleRestrictions?>(JsonSerializer.Deserialize<TransactionRuleRestrictions>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "type":
                            string? typeRawValue = utf8JsonReader.GetString();
                            type = new Option<TransactionRule.TypeEnum?>(TransactionRule.TypeEnum.FromStringOrDefault(typeRawValue));
                            break;
                        case "aggregationLevel":
                            aggregationLevel = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "endDate":
                            endDate = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "id":
                            id = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "outcomeType":
                            string? outcomeTypeRawValue = utf8JsonReader.GetString();
                            outcomeType = new Option<TransactionRule.OutcomeTypeEnum?>(TransactionRule.OutcomeTypeEnum.FromStringOrDefault(outcomeTypeRawValue));
                            break;
                        case "requestType":
                            string? requestTypeRawValue = utf8JsonReader.GetString();
                            requestType = new Option<TransactionRule.RequestTypeEnum?>(TransactionRule.RequestTypeEnum.FromStringOrDefault(requestTypeRawValue));
                            break;
                        case "score":
                            score = new Option<int?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (int?)null : utf8JsonReader.GetInt32());
                            break;
                        case "startDate":
                            startDate = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "status":
                            string? statusRawValue = utf8JsonReader.GetString();
                            status = new Option<TransactionRule.StatusEnum?>(TransactionRule.StatusEnum.FromStringOrDefault(statusRawValue));
                            break;
                        default:
                            break;
                    }
                }
            }
            
            if (!description.IsSet)
                throw new ArgumentException("Property is required for class TransactionRule.", nameof(description));

            if (!entityKey.IsSet)
                throw new ArgumentException("Property is required for class TransactionRule.", nameof(entityKey));

            if (!interval.IsSet)
                throw new ArgumentException("Property is required for class TransactionRule.", nameof(interval));

            if (!reference.IsSet)
                throw new ArgumentException("Property is required for class TransactionRule.", nameof(reference));

            if (!ruleRestrictions.IsSet)
                throw new ArgumentException("Property is required for class TransactionRule.", nameof(ruleRestrictions));

            if (!type.IsSet)
                throw new ArgumentException("Property is required for class TransactionRule.", nameof(type));

            return new TransactionRule(description.Value!, entityKey.Value!, interval.Value!, reference.Value!, ruleRestrictions.Value!, type.Value!.Value!, aggregationLevel, endDate, id, outcomeType, requestType, score, startDate, status);
        }

        /// <summary>
        /// Serializes a <see cref="TransactionRule"/>.
        /// </summary>
        /// <param name="writer"><see cref="Utf8JsonWriter"/></param>
        /// <param name="transactionRule"></param>
        /// <param name="jsonSerializerOptions"><see cref="JsonSerializerOptions"/></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, TransactionRule transactionRule, JsonSerializerOptions jsonSerializerOptions)
        {
            
            writer.WriteStartObject();
            
            WriteProperties(writer, transactionRule, jsonSerializerOptions);
            
            writer.WriteEndObject();
            
        }

        /// <summary>
        /// Serializes the properties of <see cref="TransactionRule"/>.
        /// </summary>
        /// <param name="writer"><see creft="Utf8JsonWriter"/></param>
        /// <param name="transactionRule"></param>
        /// <param name="jsonSerializerOptions"><see cref="JsonSerializerOptions"/></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, TransactionRule transactionRule, JsonSerializerOptions jsonSerializerOptions)
        {
            
            if (transactionRule.Description != null)
                writer.WriteString("description", transactionRule.Description);

            writer.WritePropertyName("entityKey");
            JsonSerializer.Serialize(writer, transactionRule.EntityKey, jsonSerializerOptions);
            writer.WritePropertyName("interval");
            JsonSerializer.Serialize(writer, transactionRule.Interval, jsonSerializerOptions);
            if (transactionRule.Reference != null)
                writer.WriteString("reference", transactionRule.Reference);

            writer.WritePropertyName("ruleRestrictions");
            JsonSerializer.Serialize(writer, transactionRule.RuleRestrictions, jsonSerializerOptions);
            if (transactionRule.Type != null) 
            {
                string? typeRawValue = TransactionRule.TypeEnum.ToJsonValue(transactionRule.Type);
                writer.WriteString("type", typeRawValue);
            }
            
            if (transactionRule._AggregationLevelOption.IsSet)
                if (transactionRule.AggregationLevel != null)
                    writer.WriteString("aggregationLevel", transactionRule.AggregationLevel);

            if (transactionRule._EndDateOption.IsSet)
                if (transactionRule.EndDate != null)
                    writer.WriteString("endDate", transactionRule.EndDate);

            if (transactionRule._IdOption.IsSet)
                if (transactionRule.Id != null)
                    writer.WriteString("id", transactionRule.Id);

            if (transactionRule._OutcomeTypeOption.IsSet && transactionRule.OutcomeType != null) 
            {
                string? outcomeTypeRawValue = TransactionRule.OutcomeTypeEnum.ToJsonValue(transactionRule._OutcomeTypeOption.Value!.Value);
                writer.WriteString("outcomeType", outcomeTypeRawValue);
            }
            
            if (transactionRule._RequestTypeOption.IsSet && transactionRule.RequestType != null) 
            {
                string? requestTypeRawValue = TransactionRule.RequestTypeEnum.ToJsonValue(transactionRule._RequestTypeOption.Value!.Value);
                writer.WriteString("requestType", requestTypeRawValue);
            }
            
            if (transactionRule._ScoreOption.IsSet)
                writer.WriteNumber("score", transactionRule._ScoreOption.Value!.Value);

            if (transactionRule._StartDateOption.IsSet)
                if (transactionRule.StartDate != null)
                    writer.WriteString("startDate", transactionRule.StartDate);

            if (transactionRule._StatusOption.IsSet && transactionRule.Status != null) 
            {
                string? statusRawValue = TransactionRule.StatusEnum.ToJsonValue(transactionRule._StatusOption.Value!.Value);
                writer.WriteString("status", statusRawValue);
            }
        }
    }
}
