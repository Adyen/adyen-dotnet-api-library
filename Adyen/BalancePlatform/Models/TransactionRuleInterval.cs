// <auto-generated>
/*
 * Configuration API
 *
 * The Configuration API allows you to manage your balance platform where you can create account holders, balance accounts, cards, and business accounts.  ## Authentication Each request to the Configuration API must be signed with an API key. Generate an API key in your Customer Area if you have a [platform setup](https://docs.adyen.com/platforms/manage-access/api-credentials-web-service/#generate-api-key) or [marketplace setup](https://docs.adyen.com/marketplaces/manage-access/api-credentials-web-service/#generate-api-key).   If you have an Adyen Issuing integration, [generate an API key](https://docs.adyen.com/issuing/manage-access/api-credentials-web-service/#generate-api-key) in your Balance Platform Customer Area.  To connect to the API, add an `X-API-Key` header with the API key as the value, for example:   ``` curl -H \"Content-Type: application/json\" \\ -H \"X-API-Key: YOUR_API_KEY\" \\ ... ```  ## Versioning The Configuration API supports [versioning](https://docs.adyen.com/development-resources/versioning) using a version suffix in the endpoint URL. This suffix has the following format: \"vXX\", where XX is the version number.  For example: ``` https://balanceplatform-api-test.adyen.com/bcl/v2/accountHolders ``` ## Going live When going live, generate an API key in your [live Customer Area](https://ca-live.adyen.com/ca/) if you have an Adyen for Platforms integration or [live Balance Platform Customer Area](https://balanceplatform-live.adyen.com/balanceplatform/) if you have an Adyen Issuing integration.You can then use the API key to send requests to `https://balanceplatform-api-live.adyen.com/bcl/v2`.
 *
 * The version of the OpenAPI document: 2
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using Adyen.Core;
using Adyen.BalancePlatform.Client;

namespace Adyen.BalancePlatform.Models
{
    /// <summary>
    /// TransactionRuleInterval.
    /// </summary>
    public partial class TransactionRuleInterval : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TransactionRuleInterval" /> class.
        /// </summary>
        /// <param name="type">The [type of interval](https://docs.adyen.com/issuing/transaction-rules#time-intervals) during which the rule conditions and limits apply, and how often counters are reset.  Possible values:   * **perTransaction**: conditions are evaluated and the counters are reset for every transaction.  * **daily**: the counters are reset daily at 00:00:00 CET.  * **weekly**: the counters are reset every Monday at 00:00:00 CET.   * **monthly**: the counters reset every first day of the month at 00:00:00 CET.   * **lifetime**: conditions are applied to the lifetime of the payment instrument.  * **rolling**: conditions are applied and the counters are reset based on a &#x60;duration&#x60;. If the reset date and time are not provided, Adyen applies the default reset time similar to fixed intervals. For example, if the duration is every two weeks, the counter resets every third Monday at 00:00:00 CET.  * **sliding**: conditions are applied and the counters are reset based on the current time and a &#x60;duration&#x60; that you specify.</param>
        /// <param name="dayOfMonth">The day of month, used when the &#x60;duration.unit&#x60; is **months**. If not provided, by default, this is set to **1**, the first day of the month.</param>
        /// <param name="dayOfWeek">The day of week, used when the &#x60;duration.unit&#x60; is **weeks**. If not provided, by default, this is set to **monday**.  Possible values: **sunday**, **monday**, **tuesday**, **wednesday**, **thursday**, **friday**.</param>
        /// <param name="duration">duration</param>
        /// <param name="timeOfDay">The time of day, in **hh:mm:ss** format, used when the &#x60;duration.unit&#x60; is **hours**. If not provided, by default, this is set to **00:00:00**.</param>
        /// <param name="timeZone">The [time zone](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones). For example, **Europe/Amsterdam**. By default, this is set to **UTC**.</param>
        [JsonConstructor]
        public TransactionRuleInterval(TypeEnum type, Option<int?> dayOfMonth = default, Option<DayOfWeekEnum?> dayOfWeek = default, Option<Duration?> duration = default, Option<string?> timeOfDay = default, Option<string?> timeZone = default)
        {
            Type = type;
            _DayOfMonthOption = dayOfMonth;
            _DayOfWeekOption = dayOfWeek;
            _DurationOption = duration;
            _TimeOfDayOption = timeOfDay;
            _TimeZoneOption = timeZone;
            OnCreated();
        }
        
        /// <summary>
        /// Best practice: Use the constructor to initialize your objects to understand which parameters are required/optional.
        /// </summary>
        public TransactionRuleInterval()
        {
        }

        partial void OnCreated();

        /// <summary>
        /// The [type of interval](https://docs.adyen.com/issuing/transaction-rules#time-intervals) during which the rule conditions and limits apply, and how often counters are reset.  Possible values:   * **perTransaction**: conditions are evaluated and the counters are reset for every transaction.  * **daily**: the counters are reset daily at 00:00:00 CET.  * **weekly**: the counters are reset every Monday at 00:00:00 CET.   * **monthly**: the counters reset every first day of the month at 00:00:00 CET.   * **lifetime**: conditions are applied to the lifetime of the payment instrument.  * **rolling**: conditions are applied and the counters are reset based on a `duration`. If the reset date and time are not provided, Adyen applies the default reset time similar to fixed intervals. For example, if the duration is every two weeks, the counter resets every third Monday at 00:00:00 CET.  * **sliding**: conditions are applied and the counters are reset based on the current time and a `duration` that you specify.
        /// </summary>
        /// <value>The [type of interval](https://docs.adyen.com/issuing/transaction-rules#time-intervals) during which the rule conditions and limits apply, and how often counters are reset.  Possible values:   * **perTransaction**: conditions are evaluated and the counters are reset for every transaction.  * **daily**: the counters are reset daily at 00:00:00 CET.  * **weekly**: the counters are reset every Monday at 00:00:00 CET.   * **monthly**: the counters reset every first day of the month at 00:00:00 CET.   * **lifetime**: conditions are applied to the lifetime of the payment instrument.  * **rolling**: conditions are applied and the counters are reset based on a &#x60;duration&#x60;. If the reset date and time are not provided, Adyen applies the default reset time similar to fixed intervals. For example, if the duration is every two weeks, the counter resets every third Monday at 00:00:00 CET.  * **sliding**: conditions are applied and the counters are reset based on the current time and a &#x60;duration&#x60; that you specify.</value>
        [JsonConverter(typeof(TypeEnumJsonConverter))]
        public class TypeEnum : IEnum
        {
            /// <summary>
            /// Returns the value of the TypeEnum.
            /// </summary>
            public string? Value { get; set; }

            /// <summary>
            /// TypeEnum.Daily - daily
            /// </summary>
            public static readonly TypeEnum Daily = new("daily");

            /// <summary>
            /// TypeEnum.Lifetime - lifetime
            /// </summary>
            public static readonly TypeEnum Lifetime = new("lifetime");

            /// <summary>
            /// TypeEnum.Monthly - monthly
            /// </summary>
            public static readonly TypeEnum Monthly = new("monthly");

            /// <summary>
            /// TypeEnum.PerTransaction - perTransaction
            /// </summary>
            public static readonly TypeEnum PerTransaction = new("perTransaction");

            /// <summary>
            /// TypeEnum.Rolling - rolling
            /// </summary>
            public static readonly TypeEnum Rolling = new("rolling");

            /// <summary>
            /// TypeEnum.Sliding - sliding
            /// </summary>
            public static readonly TypeEnum Sliding = new("sliding");

            /// <summary>
            /// TypeEnum.Weekly - weekly
            /// </summary>
            public static readonly TypeEnum Weekly = new("weekly");
        
            private TypeEnum(string? value)
            {
                Value = value;
            }

            /// <summary>
            /// Converts a string to a <see cref="TypeEnum"/> implicitly.
            /// </summary>
            /// <param name="value">The string value to convert. Defaults to null.</param>
            /// <returns>A new <see cref="TypeEnum"/> instance initialized with the string value.</returns>
            public static implicit operator TypeEnum?(string? value) => value == null ? null : new TypeEnum(value);
    
            /// <summary>
            /// Converts a <see cref="TypeEnum"/> instance to a string implicitly.
            /// </summary>
            /// <param name="option">The <see cref="TypeEnum"/> instance. Default to null.</param>
            /// <returns>String value of the <see cref="TypeEnum"/> instance./// </returns>
            public static implicit operator string?(TypeEnum? option) => option?.Value;
        
            public static bool operator ==(TypeEnum? left, TypeEnum? right) => string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);
    
            public static bool operator !=(TypeEnum? left, TypeEnum? right) => !string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);

            public override bool Equals(object? obj) => obj is TypeEnum other && string.Equals(Value, other.Value, StringComparison.OrdinalIgnoreCase);
    
            public override int GetHashCode() => Value?.GetHashCode() ?? 0;
        
            public override string ToString() => Value ?? string.Empty;
        
            /// <summary>
            /// Returns a <see cref="TypeEnum?"/>.
            /// </summary>
            /// <param name="value"></param>
            /// <returns><see cref="TypeEnum"/> or null.</returns>
            public static TypeEnum? FromStringOrDefault(string value)
            {
                return value switch {
                    "daily" => TypeEnum.Daily,
                    "lifetime" => TypeEnum.Lifetime,
                    "monthly" => TypeEnum.Monthly,
                    "perTransaction" => TypeEnum.PerTransaction,
                    "rolling" => TypeEnum.Rolling,
                    "sliding" => TypeEnum.Sliding,
                    "weekly" => TypeEnum.Weekly,
                    _ => null,
                };
            }
    
            /// <summary>
            /// Converts the <see cref="TypeEnum"/> to the json value.
            /// </summary>
            /// <param name="value"><see cref="TypeEnum"/></param>
            /// <returns>String value of the enum.</returns>
            /// <exception cref="NotImplementedException"></exception>
            public static string? ToJsonValue(TypeEnum? value)
            {
                if (value == null)
                    return null;
            
                if (value == TypeEnum.Daily)
                    return "daily";
                
                if (value == TypeEnum.Lifetime)
                    return "lifetime";
                
                if (value == TypeEnum.Monthly)
                    return "monthly";
                
                if (value == TypeEnum.PerTransaction)
                    return "perTransaction";
                
                if (value == TypeEnum.Rolling)
                    return "rolling";
                
                if (value == TypeEnum.Sliding)
                    return "sliding";
                
                if (value == TypeEnum.Weekly)
                    return "weekly";
                
                return null;
            }
            
            /// <summary>
            /// JsonConverter for writing TypeEnum.               
            /// </summary>
            public class TypeEnumJsonConverter : JsonConverter<TypeEnum>
            {
                public override TypeEnum? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions jsonOptions)
                {
                    string value = reader.GetString();
                    return value == null ? null : TypeEnum.FromStringOrDefault(value) ?? new TypeEnum(value);
                }

                public override void Write(Utf8JsonWriter writer, TypeEnum value, JsonSerializerOptions jsonOptions)
                {
                    writer.WriteStringValue(TypeEnum.ToJsonValue(value));
                }
            }
        }

        /// <summary>
        /// The [type of interval](https://docs.adyen.com/issuing/transaction-rules#time-intervals) during which the rule conditions and limits apply, and how often counters are reset.  Possible values:   * **perTransaction**: conditions are evaluated and the counters are reset for every transaction.  * **daily**: the counters are reset daily at 00:00:00 CET.  * **weekly**: the counters are reset every Monday at 00:00:00 CET.   * **monthly**: the counters reset every first day of the month at 00:00:00 CET.   * **lifetime**: conditions are applied to the lifetime of the payment instrument.  * **rolling**: conditions are applied and the counters are reset based on a `duration`. If the reset date and time are not provided, Adyen applies the default reset time similar to fixed intervals. For example, if the duration is every two weeks, the counter resets every third Monday at 00:00:00 CET.  * **sliding**: conditions are applied and the counters are reset based on the current time and a `duration` that you specify.
        /// </summary>
        /// <value>The [type of interval](https://docs.adyen.com/issuing/transaction-rules#time-intervals) during which the rule conditions and limits apply, and how often counters are reset.  Possible values:   * **perTransaction**: conditions are evaluated and the counters are reset for every transaction.  * **daily**: the counters are reset daily at 00:00:00 CET.  * **weekly**: the counters are reset every Monday at 00:00:00 CET.   * **monthly**: the counters reset every first day of the month at 00:00:00 CET.   * **lifetime**: conditions are applied to the lifetime of the payment instrument.  * **rolling**: conditions are applied and the counters are reset based on a &#x60;duration&#x60;. If the reset date and time are not provided, Adyen applies the default reset time similar to fixed intervals. For example, if the duration is every two weeks, the counter resets every third Monday at 00:00:00 CET.  * **sliding**: conditions are applied and the counters are reset based on the current time and a &#x60;duration&#x60; that you specify.</value>
        [JsonPropertyName("type")]
        public TypeEnum Type { get; set; }

        /// <summary>
        /// The day of week, used when the `duration.unit` is **weeks**. If not provided, by default, this is set to **monday**.  Possible values: **sunday**, **monday**, **tuesday**, **wednesday**, **thursday**, **friday**.
        /// </summary>
        /// <value>The day of week, used when the &#x60;duration.unit&#x60; is **weeks**. If not provided, by default, this is set to **monday**.  Possible values: **sunday**, **monday**, **tuesday**, **wednesday**, **thursday**, **friday**.</value>
        [JsonConverter(typeof(DayOfWeekEnumJsonConverter))]
        public class DayOfWeekEnum : IEnum
        {
            /// <summary>
            /// Returns the value of the DayOfWeekEnum.
            /// </summary>
            public string? Value { get; set; }

            /// <summary>
            /// DayOfWeekEnum.Friday - friday
            /// </summary>
            public static readonly DayOfWeekEnum Friday = new("friday");

            /// <summary>
            /// DayOfWeekEnum.Monday - monday
            /// </summary>
            public static readonly DayOfWeekEnum Monday = new("monday");

            /// <summary>
            /// DayOfWeekEnum.Saturday - saturday
            /// </summary>
            public static readonly DayOfWeekEnum Saturday = new("saturday");

            /// <summary>
            /// DayOfWeekEnum.Sunday - sunday
            /// </summary>
            public static readonly DayOfWeekEnum Sunday = new("sunday");

            /// <summary>
            /// DayOfWeekEnum.Thursday - thursday
            /// </summary>
            public static readonly DayOfWeekEnum Thursday = new("thursday");

            /// <summary>
            /// DayOfWeekEnum.Tuesday - tuesday
            /// </summary>
            public static readonly DayOfWeekEnum Tuesday = new("tuesday");

            /// <summary>
            /// DayOfWeekEnum.Wednesday - wednesday
            /// </summary>
            public static readonly DayOfWeekEnum Wednesday = new("wednesday");
        
            private DayOfWeekEnum(string? value)
            {
                Value = value;
            }

            /// <summary>
            /// Converts a string to a <see cref="DayOfWeekEnum"/> implicitly.
            /// </summary>
            /// <param name="value">The string value to convert. Defaults to null.</param>
            /// <returns>A new <see cref="DayOfWeekEnum"/> instance initialized with the string value.</returns>
            public static implicit operator DayOfWeekEnum?(string? value) => value == null ? null : new DayOfWeekEnum(value);
    
            /// <summary>
            /// Converts a <see cref="DayOfWeekEnum"/> instance to a string implicitly.
            /// </summary>
            /// <param name="option">The <see cref="DayOfWeekEnum"/> instance. Default to null.</param>
            /// <returns>String value of the <see cref="DayOfWeekEnum"/> instance./// </returns>
            public static implicit operator string?(DayOfWeekEnum? option) => option?.Value;
        
            public static bool operator ==(DayOfWeekEnum? left, DayOfWeekEnum? right) => string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);
    
            public static bool operator !=(DayOfWeekEnum? left, DayOfWeekEnum? right) => !string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);

            public override bool Equals(object? obj) => obj is DayOfWeekEnum other && string.Equals(Value, other.Value, StringComparison.OrdinalIgnoreCase);
    
            public override int GetHashCode() => Value?.GetHashCode() ?? 0;
        
            public override string ToString() => Value ?? string.Empty;
        
            /// <summary>
            /// Returns a <see cref="DayOfWeekEnum?"/>.
            /// </summary>
            /// <param name="value"></param>
            /// <returns><see cref="DayOfWeekEnum"/> or null.</returns>
            public static DayOfWeekEnum? FromStringOrDefault(string value)
            {
                return value switch {
                    "friday" => DayOfWeekEnum.Friday,
                    "monday" => DayOfWeekEnum.Monday,
                    "saturday" => DayOfWeekEnum.Saturday,
                    "sunday" => DayOfWeekEnum.Sunday,
                    "thursday" => DayOfWeekEnum.Thursday,
                    "tuesday" => DayOfWeekEnum.Tuesday,
                    "wednesday" => DayOfWeekEnum.Wednesday,
                    _ => null,
                };
            }
    
            /// <summary>
            /// Converts the <see cref="DayOfWeekEnum"/> to the json value.
            /// </summary>
            /// <param name="value"><see cref="DayOfWeekEnum"/></param>
            /// <returns>String value of the enum.</returns>
            /// <exception cref="NotImplementedException"></exception>
            public static string? ToJsonValue(DayOfWeekEnum? value)
            {
                if (value == null)
                    return null;
            
                if (value == DayOfWeekEnum.Friday)
                    return "friday";
                
                if (value == DayOfWeekEnum.Monday)
                    return "monday";
                
                if (value == DayOfWeekEnum.Saturday)
                    return "saturday";
                
                if (value == DayOfWeekEnum.Sunday)
                    return "sunday";
                
                if (value == DayOfWeekEnum.Thursday)
                    return "thursday";
                
                if (value == DayOfWeekEnum.Tuesday)
                    return "tuesday";
                
                if (value == DayOfWeekEnum.Wednesday)
                    return "wednesday";
                
                return null;
            }
            
            /// <summary>
            /// JsonConverter for writing DayOfWeekEnum.               
            /// </summary>
            public class DayOfWeekEnumJsonConverter : JsonConverter<DayOfWeekEnum>
            {
                public override DayOfWeekEnum? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions jsonOptions)
                {
                    string value = reader.GetString();
                    return value == null ? null : DayOfWeekEnum.FromStringOrDefault(value) ?? new DayOfWeekEnum(value);
                }

                public override void Write(Utf8JsonWriter writer, DayOfWeekEnum value, JsonSerializerOptions jsonOptions)
                {
                    writer.WriteStringValue(DayOfWeekEnum.ToJsonValue(value));
                }
            }
        }

        /// <summary>
        /// This is used to track if an optional field is set. If set, <see cref="DayOfWeek"/> will be populated.
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<DayOfWeekEnum?> _DayOfWeekOption { get; private set; }

        /// <summary>
        /// The day of week, used when the `duration.unit` is **weeks**. If not provided, by default, this is set to **monday**.  Possible values: **sunday**, **monday**, **tuesday**, **wednesday**, **thursday**, **friday**.
        /// </summary>
        /// <value>The day of week, used when the &#x60;duration.unit&#x60; is **weeks**. If not provided, by default, this is set to **monday**.  Possible values: **sunday**, **monday**, **tuesday**, **wednesday**, **thursday**, **friday**.</value>
        [JsonPropertyName("dayOfWeek")]
        public DayOfWeekEnum? DayOfWeek { get { return this._DayOfWeekOption; } set { this._DayOfWeekOption = new(value); } }

        /// <summary>
        /// This is used to track if an optional field is set. If set, <see cref="DayOfMonth"/> will be populated.
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> _DayOfMonthOption { get; private set; }

        /// <summary>
        /// The day of month, used when the &#x60;duration.unit&#x60; is **months**. If not provided, by default, this is set to **1**, the first day of the month.
        /// </summary>
        /// <value>The day of month, used when the `duration.unit` is **months**. If not provided, by default, this is set to **1**, the first day of the month.</value>
        [JsonPropertyName("dayOfMonth")]
        public int? DayOfMonth { get { return this._DayOfMonthOption; } set { this._DayOfMonthOption = new(value); } }

        /// <summary>
        /// This is used to track if an optional field is set. If set, <see cref="Duration"/> will be populated.
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<Duration?> _DurationOption { get; private set; }

        /// <summary>
        /// <see cref="Duration"/>.
        /// </summary>
        [JsonPropertyName("duration")]
        public Duration? Duration { get { return this._DurationOption; } set { this._DurationOption = new(value); } }

        /// <summary>
        /// This is used to track if an optional field is set. If set, <see cref="TimeOfDay"/> will be populated.
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> _TimeOfDayOption { get; private set; }

        /// <summary>
        /// The time of day, in **hh:mm:ss** format, used when the &#x60;duration.unit&#x60; is **hours**. If not provided, by default, this is set to **00:00:00**.
        /// </summary>
        /// <value>The time of day, in **hh:mm:ss** format, used when the `duration.unit` is **hours**. If not provided, by default, this is set to **00:00:00**.</value>
        [JsonPropertyName("timeOfDay")]
        public string? TimeOfDay { get { return this._TimeOfDayOption; } set { this._TimeOfDayOption = new(value); } }

        /// <summary>
        /// This is used to track if an optional field is set. If set, <see cref="TimeZone"/> will be populated.
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> _TimeZoneOption { get; private set; }

        /// <summary>
        /// The [time zone](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones). For example, **Europe/Amsterdam**. By default, this is set to **UTC**.
        /// </summary>
        /// <value>The [time zone](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones). For example, **Europe/Amsterdam**. By default, this is set to **UTC**.</value>
        [JsonPropertyName("timeZone")]
        public string? TimeZone { get { return this._TimeZoneOption; } set { this._TimeZoneOption = new(value); } }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class TransactionRuleInterval {\n");
            sb.Append("  Type: ").Append(Type).Append("\n");
            sb.Append("  DayOfMonth: ").Append(DayOfMonth).Append("\n");
            sb.Append("  DayOfWeek: ").Append(DayOfWeek).Append("\n");
            sb.Append("  Duration: ").Append(Duration).Append("\n");
            sb.Append("  TimeOfDay: ").Append(TimeOfDay).Append("\n");
            sb.Append("  TimeZone: ").Append(TimeZone).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="TransactionRuleInterval" />
    /// </summary>
    public class TransactionRuleIntervalJsonConverter : JsonConverter<TransactionRuleInterval>
    {
        /// <summary>
        /// Deserializes json to <see cref="TransactionRuleInterval"/>.
        /// </summary>
        /// <param name="utf8JsonReader"><see cref="Utf8JsonReader"/>.</param>
        /// <param name="typeToConvert"><see cref="Type"/>.</param>
        /// <param name="jsonSerializerOptions">The <see cref="JsonSerializerOptions"/>, initialized from <see cref="HostConfiguration"/>.</param>
        /// <returns><see cref="TransactionRuleInterval"/>.</returns>
        /// <exception cref="JsonException"></exception>
        public override TransactionRuleInterval Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<TransactionRuleInterval.TypeEnum?> type = default;
            Option<int?> dayOfMonth = default;
            Option<TransactionRuleInterval.DayOfWeekEnum?> dayOfWeek = default;
            Option<Duration?> duration = default;
            Option<string?> timeOfDay = default;
            Option<string?> timeZone = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? jsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (jsonPropertyName)
                    {
                        case "type":
                            string? typeRawValue = utf8JsonReader.GetString();
                            type = new Option<TransactionRuleInterval.TypeEnum?>(TransactionRuleInterval.TypeEnum.FromStringOrDefault(typeRawValue));
                            break;
                        case "dayOfMonth":
                            dayOfMonth = new Option<int?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (int?)null : utf8JsonReader.GetInt32());
                            break;
                        case "dayOfWeek":
                            string? dayOfWeekRawValue = utf8JsonReader.GetString();
                            dayOfWeek = new Option<TransactionRuleInterval.DayOfWeekEnum?>(TransactionRuleInterval.DayOfWeekEnum.FromStringOrDefault(dayOfWeekRawValue));
                            break;
                        case "duration":
                            duration = new Option<Duration?>(JsonSerializer.Deserialize<Duration>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "timeOfDay":
                            timeOfDay = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "timeZone":
                            timeZone = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        default:
                            break;
                    }
                }
            }
            
            if (!type.IsSet)
                throw new ArgumentException("Property is required for class TransactionRuleInterval.", nameof(type));

            return new TransactionRuleInterval(type.Value!.Value!, dayOfMonth, dayOfWeek, duration, timeOfDay, timeZone);
        }

        /// <summary>
        /// Serializes a <see cref="TransactionRuleInterval"/>.
        /// </summary>
        /// <param name="writer"><see cref="Utf8JsonWriter"/></param>
        /// <param name="transactionRuleInterval"></param>
        /// <param name="jsonSerializerOptions"><see cref="JsonSerializerOptions"/></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, TransactionRuleInterval transactionRuleInterval, JsonSerializerOptions jsonSerializerOptions)
        {
            
            writer.WriteStartObject();
            
            WriteProperties(writer, transactionRuleInterval, jsonSerializerOptions);
            
            writer.WriteEndObject();
            
        }

        /// <summary>
        /// Serializes the properties of <see cref="TransactionRuleInterval"/>.
        /// </summary>
        /// <param name="writer"><see cref="Utf8JsonWriter"/></param>
        /// <param name="transactionRuleInterval"></param>
        /// <param name="jsonSerializerOptions"><see cref="JsonSerializerOptions"/></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, TransactionRuleInterval transactionRuleInterval, JsonSerializerOptions jsonSerializerOptions)
        {
            
            if (transactionRuleInterval.Type != null) 
            {
                string? typeRawValue = TransactionRuleInterval.TypeEnum.ToJsonValue(transactionRuleInterval.Type);
                writer.WriteString("type", typeRawValue);
            }
            
            if (transactionRuleInterval._DayOfMonthOption.IsSet)
                writer.WriteNumber("dayOfMonth", transactionRuleInterval._DayOfMonthOption.Value!.Value);

            if (transactionRuleInterval._DayOfWeekOption.IsSet && transactionRuleInterval.DayOfWeek != null) 
            {
                string? dayOfWeekRawValue = TransactionRuleInterval.DayOfWeekEnum.ToJsonValue(transactionRuleInterval._DayOfWeekOption.Value!.Value);
                writer.WriteString("dayOfWeek", dayOfWeekRawValue);
            }
            
            if (transactionRuleInterval._DurationOption.IsSet)
            {
                writer.WritePropertyName("duration");
                JsonSerializer.Serialize(writer, transactionRuleInterval.Duration, jsonSerializerOptions);
            }
            if (transactionRuleInterval._TimeOfDayOption.IsSet)
                if (transactionRuleInterval.TimeOfDay != null)
                    writer.WriteString("timeOfDay", transactionRuleInterval.TimeOfDay);

            if (transactionRuleInterval._TimeZoneOption.IsSet)
                if (transactionRuleInterval.TimeZone != null)
                    writer.WriteString("timeZone", transactionRuleInterval.TimeZone);
        }
    }
}
