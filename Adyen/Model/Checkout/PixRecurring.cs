/*
* Adyen Checkout API
*
*
* The version of the OpenAPI document: 71
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Adyen.ApiSerialization.OpenAPIDateConverter;

namespace Adyen.Model.Checkout
{
    /// <summary>
    /// PixRecurring
    /// </summary>
    [DataContract(Name = "PixRecurring")]
    public partial class PixRecurring : IEquatable<PixRecurring>, IValidatableObject
    {
        /// <summary>
        /// The frequency at which the shopper will be charged.
        /// </summary>
        /// <value>The frequency at which the shopper will be charged.</value>
        [JsonConverter(typeof(Adyen.Util.SafeStringEnumConverter))]
        public enum FrequencyEnum
        {
            /// <summary>
            /// Enum Weekly for value: weekly
            /// </summary>
            [EnumMember(Value = "weekly")]
            Weekly = 1,

            /// <summary>
            /// Enum Monthly for value: monthly
            /// </summary>
            [EnumMember(Value = "monthly")]
            Monthly = 2,

            /// <summary>
            /// Enum Quarterly for value: quarterly
            /// </summary>
            [EnumMember(Value = "quarterly")]
            Quarterly = 3,

            /// <summary>
            /// Enum HalfYearly for value: half-yearly
            /// </summary>
            [EnumMember(Value = "half-yearly")]
            HalfYearly = 4,

            /// <summary>
            /// Enum Yearly for value: yearly
            /// </summary>
            [EnumMember(Value = "yearly")]
            Yearly = 5

        }


        /// <summary>
        /// The frequency at which the shopper will be charged.
        /// </summary>
        /// <value>The frequency at which the shopper will be charged.</value>
        [DataMember(Name = "frequency", EmitDefaultValue = false)]
        public FrequencyEnum? Frequency { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="PixRecurring" /> class.
        /// </summary>
        /// <param name="billingDate">The date on which the shopper&#39;s payment method will be charged, in YYYY-MM-DD format..</param>
        /// <param name="businessDayOnly">Flag used to define whether liquidation can happen only on business days.</param>
        /// <param name="endsAt">End date of the billing plan, in YYYY-MM-DD format. The end date must align with the frequency and the start date of the billing plan. If left blank, the subscription will continue indefinitely unless it is cancelled by the shopper..</param>
        /// <param name="frequency">The frequency at which the shopper will be charged..</param>
        /// <param name="minAmount">minAmount.</param>
        /// <param name="originalPspReference">The pspReference for the failed recurring payment. Find this in AUTHORISATION webhook you received after the billing date..</param>
        /// <param name="recurringAmount">recurringAmount.</param>
        /// <param name="recurringStatement">The text that that will be shown on the shopper&#39;s bank statement for the recurring payments. We recommend to add a descriptive text about the subscription to let your shoppers recognize your recurring payments. Maximum length: 35 characters..</param>
        /// <param name="retryPolicy">When set to true, you can retry for failed recurring payments. The default value is true..</param>
        /// <param name="startsAt">Start date of the billing plan, in YYYY-MM-DD format. The default value is the transaction date..</param>
        public PixRecurring(string billingDate = default(string), bool? businessDayOnly = default(bool?), string endsAt = default(string), FrequencyEnum? frequency = default(FrequencyEnum?), Amount minAmount = default(Amount), string originalPspReference = default(string), Amount recurringAmount = default(Amount), string recurringStatement = default(string), bool? retryPolicy = default(bool?), string startsAt = default(string))
        {
            this.BillingDate = billingDate;
            this.BusinessDayOnly = businessDayOnly;
            this.EndsAt = endsAt;
            this.Frequency = frequency;
            this.MinAmount = minAmount;
            this.OriginalPspReference = originalPspReference;
            this.RecurringAmount = recurringAmount;
            this.RecurringStatement = recurringStatement;
            this.RetryPolicy = retryPolicy;
            this.StartsAt = startsAt;
        }

        /// <summary>
        /// The date on which the shopper&#39;s payment method will be charged, in YYYY-MM-DD format.
        /// </summary>
        /// <value>The date on which the shopper&#39;s payment method will be charged, in YYYY-MM-DD format.</value>
        [DataMember(Name = "billingDate", EmitDefaultValue = false)]
        public string BillingDate { get; set; }

        /// <summary>
        /// Flag used to define whether liquidation can happen only on business days
        /// </summary>
        /// <value>Flag used to define whether liquidation can happen only on business days</value>
        [DataMember(Name = "businessDayOnly", EmitDefaultValue = false)]
        public bool? BusinessDayOnly { get; set; }

        /// <summary>
        /// End date of the billing plan, in YYYY-MM-DD format. The end date must align with the frequency and the start date of the billing plan. If left blank, the subscription will continue indefinitely unless it is cancelled by the shopper.
        /// </summary>
        /// <value>End date of the billing plan, in YYYY-MM-DD format. The end date must align with the frequency and the start date of the billing plan. If left blank, the subscription will continue indefinitely unless it is cancelled by the shopper.</value>
        [DataMember(Name = "endsAt", EmitDefaultValue = false)]
        public string EndsAt { get; set; }

        /// <summary>
        /// Gets or Sets MinAmount
        /// </summary>
        [DataMember(Name = "minAmount", EmitDefaultValue = false)]
        public Amount MinAmount { get; set; }

        /// <summary>
        /// The pspReference for the failed recurring payment. Find this in AUTHORISATION webhook you received after the billing date.
        /// </summary>
        /// <value>The pspReference for the failed recurring payment. Find this in AUTHORISATION webhook you received after the billing date.</value>
        [DataMember(Name = "originalPspReference", EmitDefaultValue = false)]
        public string OriginalPspReference { get; set; }

        /// <summary>
        /// Gets or Sets RecurringAmount
        /// </summary>
        [DataMember(Name = "recurringAmount", EmitDefaultValue = false)]
        public Amount RecurringAmount { get; set; }

        /// <summary>
        /// The text that that will be shown on the shopper&#39;s bank statement for the recurring payments. We recommend to add a descriptive text about the subscription to let your shoppers recognize your recurring payments. Maximum length: 35 characters.
        /// </summary>
        /// <value>The text that that will be shown on the shopper&#39;s bank statement for the recurring payments. We recommend to add a descriptive text about the subscription to let your shoppers recognize your recurring payments. Maximum length: 35 characters.</value>
        [DataMember(Name = "recurringStatement", EmitDefaultValue = false)]
        public string RecurringStatement { get; set; }

        /// <summary>
        /// When set to true, you can retry for failed recurring payments. The default value is true.
        /// </summary>
        /// <value>When set to true, you can retry for failed recurring payments. The default value is true.</value>
        [DataMember(Name = "retryPolicy", EmitDefaultValue = false)]
        public bool? RetryPolicy { get; set; }

        /// <summary>
        /// Start date of the billing plan, in YYYY-MM-DD format. The default value is the transaction date.
        /// </summary>
        /// <value>Start date of the billing plan, in YYYY-MM-DD format. The default value is the transaction date.</value>
        [DataMember(Name = "startsAt", EmitDefaultValue = false)]
        public string StartsAt { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class PixRecurring {\n");
            sb.Append("  BillingDate: ").Append(BillingDate).Append("\n");
            sb.Append("  BusinessDayOnly: ").Append(BusinessDayOnly).Append("\n");
            sb.Append("  EndsAt: ").Append(EndsAt).Append("\n");
            sb.Append("  Frequency: ").Append(Frequency).Append("\n");
            sb.Append("  MinAmount: ").Append(MinAmount).Append("\n");
            sb.Append("  OriginalPspReference: ").Append(OriginalPspReference).Append("\n");
            sb.Append("  RecurringAmount: ").Append(RecurringAmount).Append("\n");
            sb.Append("  RecurringStatement: ").Append(RecurringStatement).Append("\n");
            sb.Append("  RetryPolicy: ").Append(RetryPolicy).Append("\n");
            sb.Append("  StartsAt: ").Append(StartsAt).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as PixRecurring);
        }

        /// <summary>
        /// Returns true if PixRecurring instances are equal
        /// </summary>
        /// <param name="input">Instance of PixRecurring to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(PixRecurring input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.BillingDate == input.BillingDate ||
                    (this.BillingDate != null &&
                    this.BillingDate.Equals(input.BillingDate))
                ) && 
                (
                    this.BusinessDayOnly == input.BusinessDayOnly ||
                    this.BusinessDayOnly.Equals(input.BusinessDayOnly)
                ) && 
                (
                    this.EndsAt == input.EndsAt ||
                    (this.EndsAt != null &&
                    this.EndsAt.Equals(input.EndsAt))
                ) && 
                (
                    this.Frequency == input.Frequency ||
                    this.Frequency.Equals(input.Frequency)
                ) && 
                (
                    this.MinAmount == input.MinAmount ||
                    (this.MinAmount != null &&
                    this.MinAmount.Equals(input.MinAmount))
                ) && 
                (
                    this.OriginalPspReference == input.OriginalPspReference ||
                    (this.OriginalPspReference != null &&
                    this.OriginalPspReference.Equals(input.OriginalPspReference))
                ) && 
                (
                    this.RecurringAmount == input.RecurringAmount ||
                    (this.RecurringAmount != null &&
                    this.RecurringAmount.Equals(input.RecurringAmount))
                ) && 
                (
                    this.RecurringStatement == input.RecurringStatement ||
                    (this.RecurringStatement != null &&
                    this.RecurringStatement.Equals(input.RecurringStatement))
                ) && 
                (
                    this.RetryPolicy == input.RetryPolicy ||
                    this.RetryPolicy.Equals(input.RetryPolicy)
                ) && 
                (
                    this.StartsAt == input.StartsAt ||
                    (this.StartsAt != null &&
                    this.StartsAt.Equals(input.StartsAt))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.BillingDate != null)
                {
                    hashCode = (hashCode * 59) + this.BillingDate.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.BusinessDayOnly.GetHashCode();
                if (this.EndsAt != null)
                {
                    hashCode = (hashCode * 59) + this.EndsAt.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.Frequency.GetHashCode();
                if (this.MinAmount != null)
                {
                    hashCode = (hashCode * 59) + this.MinAmount.GetHashCode();
                }
                if (this.OriginalPspReference != null)
                {
                    hashCode = (hashCode * 59) + this.OriginalPspReference.GetHashCode();
                }
                if (this.RecurringAmount != null)
                {
                    hashCode = (hashCode * 59) + this.RecurringAmount.GetHashCode();
                }
                if (this.RecurringStatement != null)
                {
                    hashCode = (hashCode * 59) + this.RecurringStatement.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.RetryPolicy.GetHashCode();
                if (this.StartsAt != null)
                {
                    hashCode = (hashCode * 59) + this.StartsAt.GetHashCode();
                }
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        public IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
