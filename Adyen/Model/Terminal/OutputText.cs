/*
* Adyen Terminal API
*
*
* The version of the OpenAPI document: 1
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Adyen.ApiSerialization.OpenAPIDateConverter;

namespace Adyen.Model.Terminal
{
    /// <summary>
    /// It conveys Information related to the content of the text message and its format. All the data elements related to the format of the text to display or print are parameters valid for the whole Text content. Content of text message to display or print.
    /// </summary>
    [DataContract(Name = "OutputText")]
    public partial class OutputText : IEquatable<OutputText>, IValidatableObject
    {

        /// <summary>
        /// Gets or Sets Color
        /// </summary>
        [DataMember(Name = "Color", EmitDefaultValue = false)]
        public Color? Color { get; set; }

        /// <summary>
        /// Gets or Sets CharacterWidth
        /// </summary>
        [DataMember(Name = "CharacterWidth", EmitDefaultValue = false)]
        public CharacterWidth? CharacterWidth { get; set; }

        /// <summary>
        /// Gets or Sets CharacterHeight
        /// </summary>
        [DataMember(Name = "CharacterHeight", EmitDefaultValue = false)]
        public CharacterHeight? CharacterHeight { get; set; }

        /// <summary>
        /// Gets or Sets CharacterStyle
        /// </summary>
        [DataMember(Name = "CharacterStyle", EmitDefaultValue = false)]
        public CharacterStyle? CharacterStyle { get; set; }

        /// <summary>
        /// Gets or Sets Alignment
        /// </summary>
        [DataMember(Name = "Alignment", EmitDefaultValue = false)]
        public Alignment? Alignment { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="OutputText" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected OutputText() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="OutputText" /> class.
        /// </summary>
        /// <param name="text">text (required).</param>
        /// <param name="characterSet">characterSet.</param>
        /// <param name="font">font.</param>
        /// <param name="startRow">startRow.</param>
        /// <param name="startColumn">startColumn.</param>
        /// <param name="color">color.</param>
        /// <param name="characterWidth">characterWidth.</param>
        /// <param name="characterHeight">characterHeight.</param>
        /// <param name="characterStyle">characterStyle.</param>
        /// <param name="alignment">alignment.</param>
        /// <param name="endOfLineFlag">endOfLineFlag (default to true).</param>
        public OutputText(string text = default(string), int? characterSet = default(int?), string font = default(string), int? startRow = default(int?), int? startColumn = default(int?), Color? color = default(Color?), CharacterWidth? characterWidth = default(CharacterWidth?), CharacterHeight? characterHeight = default(CharacterHeight?), CharacterStyle? characterStyle = default(CharacterStyle?), Alignment? alignment = default(Alignment?), bool? endOfLineFlag = true)
        {
            this.Text = text;
            this.CharacterSet = characterSet;
            this.Font = font;
            this.StartRow = startRow;
            this.StartColumn = startColumn;
            this.Color = color;
            this.CharacterWidth = characterWidth;
            this.CharacterHeight = characterHeight;
            this.CharacterStyle = characterStyle;
            this.Alignment = alignment;
            this.EndOfLineFlag = endOfLineFlag;
        }

        /// <summary>
        /// Gets or Sets Text
        /// </summary>
        [DataMember(Name = "Text", IsRequired = false, EmitDefaultValue = false)]
        public string Text { get; set; }

        /// <summary>
        /// Gets or Sets CharacterSet
        /// </summary>
        [DataMember(Name = "CharacterSet", EmitDefaultValue = false)]
        public int? CharacterSet { get; set; }

        /// <summary>
        /// Gets or Sets Font
        /// </summary>
        [DataMember(Name = "Font", EmitDefaultValue = false)]
        public string Font { get; set; }

        /// <summary>
        /// Gets or Sets StartRow
        /// </summary>
        [DataMember(Name = "StartRow", EmitDefaultValue = false)]
        public int? StartRow { get; set; }

        /// <summary>
        /// Gets or Sets StartColumn
        /// </summary>
        [DataMember(Name = "StartColumn", EmitDefaultValue = false)]
        public int? StartColumn { get; set; }

        /// <summary>
        /// Gets or Sets EndOfLineFlag
        /// </summary>
        [DataMember(Name = "EndOfLineFlag", EmitDefaultValue = false)]
        public bool? EndOfLineFlag { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class OutputText {\n");
            sb.Append("  Text: ").Append(Text).Append("\n");
            sb.Append("  CharacterSet: ").Append(CharacterSet).Append("\n");
            sb.Append("  Font: ").Append(Font).Append("\n");
            sb.Append("  StartRow: ").Append(StartRow).Append("\n");
            sb.Append("  StartColumn: ").Append(StartColumn).Append("\n");
            sb.Append("  Color: ").Append(Color).Append("\n");
            sb.Append("  CharacterWidth: ").Append(CharacterWidth).Append("\n");
            sb.Append("  CharacterHeight: ").Append(CharacterHeight).Append("\n");
            sb.Append("  CharacterStyle: ").Append(CharacterStyle).Append("\n");
            sb.Append("  Alignment: ").Append(Alignment).Append("\n");
            sb.Append("  EndOfLineFlag: ").Append(EndOfLineFlag).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as OutputText);
        }

        /// <summary>
        /// Returns true if OutputText instances are equal
        /// </summary>
        /// <param name="input">Instance of OutputText to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(OutputText input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Text == input.Text ||
                    (this.Text != null &&
                    this.Text.Equals(input.Text))
                ) && 
                (
                    this.CharacterSet == input.CharacterSet ||
                    this.CharacterSet.Equals(input.CharacterSet)
                ) && 
                (
                    this.Font == input.Font ||
                    (this.Font != null &&
                    this.Font.Equals(input.Font))
                ) && 
                (
                    this.StartRow == input.StartRow ||
                    this.StartRow.Equals(input.StartRow)
                ) && 
                (
                    this.StartColumn == input.StartColumn ||
                    this.StartColumn.Equals(input.StartColumn)
                ) && 
                (
                    this.Color == input.Color ||
                    this.Color.Equals(input.Color)
                ) && 
                (
                    this.CharacterWidth == input.CharacterWidth ||
                    this.CharacterWidth.Equals(input.CharacterWidth)
                ) && 
                (
                    this.CharacterHeight == input.CharacterHeight ||
                    this.CharacterHeight.Equals(input.CharacterHeight)
                ) && 
                (
                    this.CharacterStyle == input.CharacterStyle ||
                    this.CharacterStyle.Equals(input.CharacterStyle)
                ) && 
                (
                    this.Alignment == input.Alignment ||
                    this.Alignment.Equals(input.Alignment)
                ) && 
                (
                    this.EndOfLineFlag == input.EndOfLineFlag ||
                    this.EndOfLineFlag.Equals(input.EndOfLineFlag)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Text != null)
                {
                    hashCode = (hashCode * 59) + this.Text.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.CharacterSet.GetHashCode();
                if (this.Font != null)
                {
                    hashCode = (hashCode * 59) + this.Font.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.StartRow.GetHashCode();
                hashCode = (hashCode * 59) + this.StartColumn.GetHashCode();
                hashCode = (hashCode * 59) + this.Color.GetHashCode();
                hashCode = (hashCode * 59) + this.CharacterWidth.GetHashCode();
                hashCode = (hashCode * 59) + this.CharacterHeight.GetHashCode();
                hashCode = (hashCode * 59) + this.CharacterStyle.GetHashCode();
                hashCode = (hashCode * 59) + this.Alignment.GetHashCode();
                hashCode = (hashCode * 59) + this.EndOfLineFlag.GetHashCode();
                return hashCode;
            }
        }
        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        public IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> Validate(ValidationContext validationContext)
        {
            // Font (string) pattern
            Regex regexFont = new Regex(@"^.+$", RegexOptions.CultureInvariant);
            if (false == regexFont.Match(this.Font).Success)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Font, must match a pattern of " + regexFont, new [] { "Font" });
            }

            // StartRow (int) maximum
            if (this.StartRow > (int)500)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for StartRow, must be a value less than or equal to 500.", new [] { "StartRow" });
            }

            // StartRow (int) minimum
            if (this.StartRow < (int)1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for StartRow, must be a value greater than or equal to 1.", new [] { "StartRow" });
            }

            // StartColumn (int) maximum
            if (this.StartColumn > (int)500)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for StartColumn, must be a value less than or equal to 500.", new [] { "StartColumn" });
            }

            // StartColumn (int) minimum
            if (this.StartColumn < (int)1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for StartColumn, must be a value greater than or equal to 1.", new [] { "StartColumn" });
            }

            yield break;
        }
    }

}
