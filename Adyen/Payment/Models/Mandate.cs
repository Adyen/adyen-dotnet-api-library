// <auto-generated>
/*
 * Adyen Payment API
 *
 * A set of API endpoints that allow you to initiate, settle, and modify payments on the Adyen payments platform. You can use the API to accept card payments (including One-Click and 3D Secure), bank transfers, ewallets, and many other payment methods.  To learn more about the API, visit [Classic integration](https://docs.adyen.com/classic-integration).  ## Authentication You need an [API credential](https://docs.adyen.com/development-resources/api-credentials) to authenticate to the API.  If using an API key, add an `X-API-Key` header with the API key as the value, for example:   ``` curl -H \"Content-Type: application/json\" \\ -H \"X-API-Key: YOUR_API_KEY\" \\ ... ```  Alternatively, you can use the username and password to connect to the API using basic authentication, for example:  ``` curl -U \"ws@Company.YOUR_COMPANY_ACCOUNT\":\"YOUR_BASIC_AUTHENTICATION_PASSWORD\" \\ -H \"Content-Type: application/json\" \\ ... ```  ## Versioning Payments API supports [versioning](https://docs.adyen.com/development-resources/versioning) using a version suffix in the endpoint URL. This suffix has the following format: \"vXX\", where XX is the version number.  For example: ``` https://pal-test.adyen.com/pal/servlet/Payment/v68/authorise ```  ## Going live  To authenticate to the live endpoints, you need an [API credential](https://docs.adyen.com/development-resources/api-credentials) from your live Customer Area.  The live endpoint URLs contain a prefix which is unique to your company account: ```  https://{PREFIX}-pal-live.adyenpayments.com/pal/servlet/Payment/v68/authorise ```  Get your `{PREFIX}` from your live Customer Area under **Developers** > **API URLs** > **Prefix**.
 *
 * The version of the OpenAPI document: 68
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using Adyen.Core;
using Adyen.Payment.Client;

namespace Adyen.Payment.Models
{
    /// <summary>
    /// Mandate.
    /// </summary>
    public partial class Mandate
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Mandate" /> class.
        /// </summary>
        /// <param name="amount">The billing amount (in minor units) of the recurring transactions.</param>
        /// <param name="endsAt">End date of the billing plan, in YYYY-MM-DD format.</param>
        /// <param name="frequency">The frequency with which a shopper should be charged.  Possible values: **daily**, **weekly**, **biWeekly**, **monthly**, **quarterly**, **halfYearly**, **yearly**.</param>
        /// <param name="amountRule">The limitation rule of the billing amount.  Possible values:  * **max**: The transaction amount can not exceed the &#x60;amount&#x60;.   * **exact**: The transaction amount should be the same as the &#x60;amount&#x60;.  </param>
        /// <param name="billingAttemptsRule">The rule to specify the period, within which the recurring debit can happen, relative to the mandate recurring date.  Possible values:   * **on**: On a specific date.   * **before**:  Before and on a specific date.   * **after**: On and after a specific date.  </param>
        /// <param name="billingDay">The number of the day, on which the recurring debit can happen. Should be within the same calendar month as the mandate recurring date.  Possible values: 1-31 based on the &#x60;frequency&#x60;.</param>
        /// <param name="count">The number of transactions that can be performed within the given frequency.</param>
        /// <param name="remarks">The message shown by UPI to the shopper on the approval screen.</param>
        /// <param name="startsAt">Start date of the billing plan, in YYYY-MM-DD format. By default, the transaction date.</param>
        [JsonConstructor]
        public Mandate(string amount, string endsAt, FrequencyEnum frequency, Option<AmountRuleEnum?> amountRule = default, Option<BillingAttemptsRuleEnum?> billingAttemptsRule = default, Option<string?> billingDay = default, Option<string?> count = default, Option<string?> remarks = default, Option<string?> startsAt = default)
        {
            Amount = amount;
            EndsAt = endsAt;
            Frequency = frequency;
            _AmountRuleOption = amountRule;
            _BillingAttemptsRuleOption = billingAttemptsRule;
            _BillingDayOption = billingDay;
            _CountOption = count;
            _RemarksOption = remarks;
            _StartsAtOption = startsAt;
            OnCreated();
        }
        
        /// <summary>
        /// Best practice: Use the constructor to initialize your objects to understand which parameters are required/optional.
        /// </summary>
        public Mandate()
        {
        }

        partial void OnCreated();

        /// <summary>
        /// The frequency with which a shopper should be charged.  Possible values: **daily**, **weekly**, **biWeekly**, **monthly**, **quarterly**, **halfYearly**, **yearly**.
        /// </summary>
        /// <value>The frequency with which a shopper should be charged.  Possible values: **daily**, **weekly**, **biWeekly**, **monthly**, **quarterly**, **halfYearly**, **yearly**.</value>
        [JsonConverter(typeof(FrequencyEnumJsonConverter))]
        public class FrequencyEnum : IEnum
        {
            /// <summary>
            /// Returns the value of the FrequencyEnum.
            /// </summary>
            public string? Value { get; set; }

            /// <summary>
            /// FrequencyEnum.Adhoc - adhoc
            /// </summary>
            public static readonly FrequencyEnum Adhoc = new("adhoc");

            /// <summary>
            /// FrequencyEnum.Daily - daily
            /// </summary>
            public static readonly FrequencyEnum Daily = new("daily");

            /// <summary>
            /// FrequencyEnum.Weekly - weekly
            /// </summary>
            public static readonly FrequencyEnum Weekly = new("weekly");

            /// <summary>
            /// FrequencyEnum.BiWeekly - biWeekly
            /// </summary>
            public static readonly FrequencyEnum BiWeekly = new("biWeekly");

            /// <summary>
            /// FrequencyEnum.Monthly - monthly
            /// </summary>
            public static readonly FrequencyEnum Monthly = new("monthly");

            /// <summary>
            /// FrequencyEnum.Quarterly - quarterly
            /// </summary>
            public static readonly FrequencyEnum Quarterly = new("quarterly");

            /// <summary>
            /// FrequencyEnum.HalfYearly - halfYearly
            /// </summary>
            public static readonly FrequencyEnum HalfYearly = new("halfYearly");

            /// <summary>
            /// FrequencyEnum.Yearly - yearly
            /// </summary>
            public static readonly FrequencyEnum Yearly = new("yearly");
        
            private FrequencyEnum(string? value)
            {
                Value = value;
            }

            /// <summary>
            /// Converts a string to a <see cref="FrequencyEnum"/> implicitly.
            /// </summary>
            /// <param name="value">The string value to convert. Defaults to null.</param>
            /// <returns>A new <see cref="FrequencyEnum"/> instance initialized with the string value.</returns>
            public static implicit operator FrequencyEnum?(string? value) => value == null ? null : new FrequencyEnum(value);
    
            /// <summary>
            /// Converts a <see cref="FrequencyEnum"/> instance to a string implicitly.
            /// </summary>
            /// <param name="option">The <see cref="FrequencyEnum"/> instance. Default to null.</param>
            /// <returns>String value of the <see cref="FrequencyEnum"/> instance./// </returns>
            public static implicit operator string?(FrequencyEnum? option) => option?.Value;
        
            public static bool operator ==(FrequencyEnum? left, FrequencyEnum? right) => string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);
    
            public static bool operator !=(FrequencyEnum? left, FrequencyEnum? right) => !string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);

            public override bool Equals(object? obj) => obj is FrequencyEnum other && string.Equals(Value, other.Value, StringComparison.OrdinalIgnoreCase);
    
            public override int GetHashCode() => Value?.GetHashCode() ?? 0;
        
            public override string ToString() => Value ?? string.Empty;
        
            /// <summary>
            /// Returns a <see cref="FrequencyEnum?"/>.
            /// </summary>
            /// <param name="value"></param>
            /// <returns><see cref="FrequencyEnum"/> or null.</returns>
            public static FrequencyEnum? FromStringOrDefault(string value)
            {
                return value switch {
                    "adhoc" => FrequencyEnum.Adhoc,
                    "daily" => FrequencyEnum.Daily,
                    "weekly" => FrequencyEnum.Weekly,
                    "biWeekly" => FrequencyEnum.BiWeekly,
                    "monthly" => FrequencyEnum.Monthly,
                    "quarterly" => FrequencyEnum.Quarterly,
                    "halfYearly" => FrequencyEnum.HalfYearly,
                    "yearly" => FrequencyEnum.Yearly,
                    _ => null,
                };
            }
    
            /// <summary>
            /// Converts the <see cref="FrequencyEnum"/> to the json value.
            /// </summary>
            /// <param name="value"><see cref="FrequencyEnum"/></param>
            /// <returns>String value of the enum.</returns>
            /// <exception cref="NotImplementedException"></exception>
            public static string? ToJsonValue(FrequencyEnum? value)
            {
                if (value == null)
                    return null;
            
                if (value == FrequencyEnum.Adhoc)
                    return "adhoc";
                
                if (value == FrequencyEnum.Daily)
                    return "daily";
                
                if (value == FrequencyEnum.Weekly)
                    return "weekly";
                
                if (value == FrequencyEnum.BiWeekly)
                    return "biWeekly";
                
                if (value == FrequencyEnum.Monthly)
                    return "monthly";
                
                if (value == FrequencyEnum.Quarterly)
                    return "quarterly";
                
                if (value == FrequencyEnum.HalfYearly)
                    return "halfYearly";
                
                if (value == FrequencyEnum.Yearly)
                    return "yearly";
                
                return null;
            }
            
            /// <summary>
            /// JsonConverter for writing FrequencyEnum.               
            /// </summary>
            public class FrequencyEnumJsonConverter : JsonConverter<FrequencyEnum>
            {
                public override FrequencyEnum? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions jsonOptions)
                {
                    string value = reader.GetString();
                    return value == null ? null : FrequencyEnum.FromStringOrDefault(value) ?? new FrequencyEnum(value);
                }

                public override void Write(Utf8JsonWriter writer, FrequencyEnum value, JsonSerializerOptions jsonOptions)
                {
                    writer.WriteStringValue(FrequencyEnum.ToJsonValue(value));
                }
            }
        }

        /// <summary>
        /// The frequency with which a shopper should be charged.  Possible values: **daily**, **weekly**, **biWeekly**, **monthly**, **quarterly**, **halfYearly**, **yearly**.
        /// </summary>
        /// <value>The frequency with which a shopper should be charged.  Possible values: **daily**, **weekly**, **biWeekly**, **monthly**, **quarterly**, **halfYearly**, **yearly**.</value>
        [JsonPropertyName("frequency")]
        public FrequencyEnum Frequency { get; set; }

        /// <summary>
        /// The limitation rule of the billing amount.  Possible values:  * **max**: The transaction amount can not exceed the `amount`.   * **exact**: The transaction amount should be the same as the `amount`.  
        /// </summary>
        /// <value>The limitation rule of the billing amount.  Possible values:  * **max**: The transaction amount can not exceed the &#x60;amount&#x60;.   * **exact**: The transaction amount should be the same as the &#x60;amount&#x60;.  </value>
        [JsonConverter(typeof(AmountRuleEnumJsonConverter))]
        public class AmountRuleEnum : IEnum
        {
            /// <summary>
            /// Returns the value of the AmountRuleEnum.
            /// </summary>
            public string? Value { get; set; }

            /// <summary>
            /// AmountRuleEnum.Max - max
            /// </summary>
            public static readonly AmountRuleEnum Max = new("max");

            /// <summary>
            /// AmountRuleEnum.Exact - exact
            /// </summary>
            public static readonly AmountRuleEnum Exact = new("exact");
        
            private AmountRuleEnum(string? value)
            {
                Value = value;
            }

            /// <summary>
            /// Converts a string to a <see cref="AmountRuleEnum"/> implicitly.
            /// </summary>
            /// <param name="value">The string value to convert. Defaults to null.</param>
            /// <returns>A new <see cref="AmountRuleEnum"/> instance initialized with the string value.</returns>
            public static implicit operator AmountRuleEnum?(string? value) => value == null ? null : new AmountRuleEnum(value);
    
            /// <summary>
            /// Converts a <see cref="AmountRuleEnum"/> instance to a string implicitly.
            /// </summary>
            /// <param name="option">The <see cref="AmountRuleEnum"/> instance. Default to null.</param>
            /// <returns>String value of the <see cref="AmountRuleEnum"/> instance./// </returns>
            public static implicit operator string?(AmountRuleEnum? option) => option?.Value;
        
            public static bool operator ==(AmountRuleEnum? left, AmountRuleEnum? right) => string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);
    
            public static bool operator !=(AmountRuleEnum? left, AmountRuleEnum? right) => !string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);

            public override bool Equals(object? obj) => obj is AmountRuleEnum other && string.Equals(Value, other.Value, StringComparison.OrdinalIgnoreCase);
    
            public override int GetHashCode() => Value?.GetHashCode() ?? 0;
        
            public override string ToString() => Value ?? string.Empty;
        
            /// <summary>
            /// Returns a <see cref="AmountRuleEnum?"/>.
            /// </summary>
            /// <param name="value"></param>
            /// <returns><see cref="AmountRuleEnum"/> or null.</returns>
            public static AmountRuleEnum? FromStringOrDefault(string value)
            {
                return value switch {
                    "max" => AmountRuleEnum.Max,
                    "exact" => AmountRuleEnum.Exact,
                    _ => null,
                };
            }
    
            /// <summary>
            /// Converts the <see cref="AmountRuleEnum"/> to the json value.
            /// </summary>
            /// <param name="value"><see cref="AmountRuleEnum"/></param>
            /// <returns>String value of the enum.</returns>
            /// <exception cref="NotImplementedException"></exception>
            public static string? ToJsonValue(AmountRuleEnum? value)
            {
                if (value == null)
                    return null;
            
                if (value == AmountRuleEnum.Max)
                    return "max";
                
                if (value == AmountRuleEnum.Exact)
                    return "exact";
                
                return null;
            }
            
            /// <summary>
            /// JsonConverter for writing AmountRuleEnum.               
            /// </summary>
            public class AmountRuleEnumJsonConverter : JsonConverter<AmountRuleEnum>
            {
                public override AmountRuleEnum? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions jsonOptions)
                {
                    string value = reader.GetString();
                    return value == null ? null : AmountRuleEnum.FromStringOrDefault(value) ?? new AmountRuleEnum(value);
                }

                public override void Write(Utf8JsonWriter writer, AmountRuleEnum value, JsonSerializerOptions jsonOptions)
                {
                    writer.WriteStringValue(AmountRuleEnum.ToJsonValue(value));
                }
            }
        }

        /// <summary>
        /// This is used to track if an optional field is set. If set, <see cref="AmountRule"/> will be populated.
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<AmountRuleEnum?> _AmountRuleOption { get; private set; }

        /// <summary>
        /// The limitation rule of the billing amount.  Possible values:  * **max**: The transaction amount can not exceed the `amount`.   * **exact**: The transaction amount should be the same as the `amount`.  
        /// </summary>
        /// <value>The limitation rule of the billing amount.  Possible values:  * **max**: The transaction amount can not exceed the &#x60;amount&#x60;.   * **exact**: The transaction amount should be the same as the &#x60;amount&#x60;.  </value>
        [JsonPropertyName("amountRule")]
        public AmountRuleEnum? AmountRule { get { return this._AmountRuleOption; } set { this._AmountRuleOption = new(value); } }

        /// <summary>
        /// The rule to specify the period, within which the recurring debit can happen, relative to the mandate recurring date.  Possible values:   * **on**: On a specific date.   * **before**:  Before and on a specific date.   * **after**: On and after a specific date.  
        /// </summary>
        /// <value>The rule to specify the period, within which the recurring debit can happen, relative to the mandate recurring date.  Possible values:   * **on**: On a specific date.   * **before**:  Before and on a specific date.   * **after**: On and after a specific date.  </value>
        [JsonConverter(typeof(BillingAttemptsRuleEnumJsonConverter))]
        public class BillingAttemptsRuleEnum : IEnum
        {
            /// <summary>
            /// Returns the value of the BillingAttemptsRuleEnum.
            /// </summary>
            public string? Value { get; set; }

            /// <summary>
            /// BillingAttemptsRuleEnum.On - on
            /// </summary>
            public static readonly BillingAttemptsRuleEnum On = new("on");

            /// <summary>
            /// BillingAttemptsRuleEnum.Before - before
            /// </summary>
            public static readonly BillingAttemptsRuleEnum Before = new("before");

            /// <summary>
            /// BillingAttemptsRuleEnum.After - after
            /// </summary>
            public static readonly BillingAttemptsRuleEnum After = new("after");
        
            private BillingAttemptsRuleEnum(string? value)
            {
                Value = value;
            }

            /// <summary>
            /// Converts a string to a <see cref="BillingAttemptsRuleEnum"/> implicitly.
            /// </summary>
            /// <param name="value">The string value to convert. Defaults to null.</param>
            /// <returns>A new <see cref="BillingAttemptsRuleEnum"/> instance initialized with the string value.</returns>
            public static implicit operator BillingAttemptsRuleEnum?(string? value) => value == null ? null : new BillingAttemptsRuleEnum(value);
    
            /// <summary>
            /// Converts a <see cref="BillingAttemptsRuleEnum"/> instance to a string implicitly.
            /// </summary>
            /// <param name="option">The <see cref="BillingAttemptsRuleEnum"/> instance. Default to null.</param>
            /// <returns>String value of the <see cref="BillingAttemptsRuleEnum"/> instance./// </returns>
            public static implicit operator string?(BillingAttemptsRuleEnum? option) => option?.Value;
        
            public static bool operator ==(BillingAttemptsRuleEnum? left, BillingAttemptsRuleEnum? right) => string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);
    
            public static bool operator !=(BillingAttemptsRuleEnum? left, BillingAttemptsRuleEnum? right) => !string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);

            public override bool Equals(object? obj) => obj is BillingAttemptsRuleEnum other && string.Equals(Value, other.Value, StringComparison.OrdinalIgnoreCase);
    
            public override int GetHashCode() => Value?.GetHashCode() ?? 0;
        
            public override string ToString() => Value ?? string.Empty;
        
            /// <summary>
            /// Returns a <see cref="BillingAttemptsRuleEnum?"/>.
            /// </summary>
            /// <param name="value"></param>
            /// <returns><see cref="BillingAttemptsRuleEnum"/> or null.</returns>
            public static BillingAttemptsRuleEnum? FromStringOrDefault(string value)
            {
                return value switch {
                    "on" => BillingAttemptsRuleEnum.On,
                    "before" => BillingAttemptsRuleEnum.Before,
                    "after" => BillingAttemptsRuleEnum.After,
                    _ => null,
                };
            }
    
            /// <summary>
            /// Converts the <see cref="BillingAttemptsRuleEnum"/> to the json value.
            /// </summary>
            /// <param name="value"><see cref="BillingAttemptsRuleEnum"/></param>
            /// <returns>String value of the enum.</returns>
            /// <exception cref="NotImplementedException"></exception>
            public static string? ToJsonValue(BillingAttemptsRuleEnum? value)
            {
                if (value == null)
                    return null;
            
                if (value == BillingAttemptsRuleEnum.On)
                    return "on";
                
                if (value == BillingAttemptsRuleEnum.Before)
                    return "before";
                
                if (value == BillingAttemptsRuleEnum.After)
                    return "after";
                
                return null;
            }
            
            /// <summary>
            /// JsonConverter for writing BillingAttemptsRuleEnum.               
            /// </summary>
            public class BillingAttemptsRuleEnumJsonConverter : JsonConverter<BillingAttemptsRuleEnum>
            {
                public override BillingAttemptsRuleEnum? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions jsonOptions)
                {
                    string value = reader.GetString();
                    return value == null ? null : BillingAttemptsRuleEnum.FromStringOrDefault(value) ?? new BillingAttemptsRuleEnum(value);
                }

                public override void Write(Utf8JsonWriter writer, BillingAttemptsRuleEnum value, JsonSerializerOptions jsonOptions)
                {
                    writer.WriteStringValue(BillingAttemptsRuleEnum.ToJsonValue(value));
                }
            }
        }

        /// <summary>
        /// This is used to track if an optional field is set. If set, <see cref="BillingAttemptsRule"/> will be populated.
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<BillingAttemptsRuleEnum?> _BillingAttemptsRuleOption { get; private set; }

        /// <summary>
        /// The rule to specify the period, within which the recurring debit can happen, relative to the mandate recurring date.  Possible values:   * **on**: On a specific date.   * **before**:  Before and on a specific date.   * **after**: On and after a specific date.  
        /// </summary>
        /// <value>The rule to specify the period, within which the recurring debit can happen, relative to the mandate recurring date.  Possible values:   * **on**: On a specific date.   * **before**:  Before and on a specific date.   * **after**: On and after a specific date.  </value>
        [JsonPropertyName("billingAttemptsRule")]
        public BillingAttemptsRuleEnum? BillingAttemptsRule { get { return this._BillingAttemptsRuleOption; } set { this._BillingAttemptsRuleOption = new(value); } }

        /// <summary>
        /// The billing amount (in minor units) of the recurring transactions.
        /// </summary>
        /// <value>The billing amount (in minor units) of the recurring transactions.</value>
        [JsonPropertyName("amount")]
        public string Amount { get; set; }

        /// <summary>
        /// End date of the billing plan, in YYYY-MM-DD format.
        /// </summary>
        /// <value>End date of the billing plan, in YYYY-MM-DD format.</value>
        [JsonPropertyName("endsAt")]
        public string EndsAt { get; set; }

        /// <summary>
        /// This is used to track if an optional field is set. If set, <see cref="BillingDay"/> will be populated.
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> _BillingDayOption { get; private set; }

        /// <summary>
        /// The number of the day, on which the recurring debit can happen. Should be within the same calendar month as the mandate recurring date.  Possible values: 1-31 based on the &#x60;frequency&#x60;.
        /// </summary>
        /// <value>The number of the day, on which the recurring debit can happen. Should be within the same calendar month as the mandate recurring date.  Possible values: 1-31 based on the `frequency`.</value>
        [JsonPropertyName("billingDay")]
        public string? BillingDay { get { return this._BillingDayOption; } set { this._BillingDayOption = new(value); } }

        /// <summary>
        /// This is used to track if an optional field is set. If set, <see cref="Count"/> will be populated.
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> _CountOption { get; private set; }

        /// <summary>
        /// The number of transactions that can be performed within the given frequency.
        /// </summary>
        /// <value>The number of transactions that can be performed within the given frequency.</value>
        [JsonPropertyName("count")]
        public string? Count { get { return this._CountOption; } set { this._CountOption = new(value); } }

        /// <summary>
        /// This is used to track if an optional field is set. If set, <see cref="Remarks"/> will be populated.
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> _RemarksOption { get; private set; }

        /// <summary>
        /// The message shown by UPI to the shopper on the approval screen.
        /// </summary>
        /// <value>The message shown by UPI to the shopper on the approval screen.</value>
        [JsonPropertyName("remarks")]
        public string? Remarks { get { return this._RemarksOption; } set { this._RemarksOption = new(value); } }

        /// <summary>
        /// This is used to track if an optional field is set. If set, <see cref="StartsAt"/> will be populated.
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> _StartsAtOption { get; private set; }

        /// <summary>
        /// Start date of the billing plan, in YYYY-MM-DD format. By default, the transaction date.
        /// </summary>
        /// <value>Start date of the billing plan, in YYYY-MM-DD format. By default, the transaction date.</value>
        [JsonPropertyName("startsAt")]
        public string? StartsAt { get { return this._StartsAtOption; } set { this._StartsAtOption = new(value); } }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class Mandate {\n");
            sb.Append("  Amount: ").Append(Amount).Append("\n");
            sb.Append("  EndsAt: ").Append(EndsAt).Append("\n");
            sb.Append("  Frequency: ").Append(Frequency).Append("\n");
            sb.Append("  AmountRule: ").Append(AmountRule).Append("\n");
            sb.Append("  BillingAttemptsRule: ").Append(BillingAttemptsRule).Append("\n");
            sb.Append("  BillingDay: ").Append(BillingDay).Append("\n");
            sb.Append("  Count: ").Append(Count).Append("\n");
            sb.Append("  Remarks: ").Append(Remarks).Append("\n");
            sb.Append("  StartsAt: ").Append(StartsAt).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="Mandate" />
    /// </summary>
    public class MandateJsonConverter : JsonConverter<Mandate>
    {
        /// <summary>
        /// Deserializes json to <see cref="Mandate"/>.
        /// </summary>
        /// <param name="utf8JsonReader"><see cref="Utf8JsonReader"/>.</param>
        /// <param name="typeToConvert"><see cref="Type"/>.</param>
        /// <param name="jsonSerializerOptions">The <see cref="JsonSerializerOptions"/>, initialized from <see cref="HostConfiguration"/>.</param>
        /// <returns><see cref="Mandate"/>.</returns>
        /// <exception cref="JsonException"></exception>
        public override Mandate Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<string?> amount = default;
            Option<string?> endsAt = default;
            Option<Mandate.FrequencyEnum?> frequency = default;
            Option<Mandate.AmountRuleEnum?> amountRule = default;
            Option<Mandate.BillingAttemptsRuleEnum?> billingAttemptsRule = default;
            Option<string?> billingDay = default;
            Option<string?> count = default;
            Option<string?> remarks = default;
            Option<string?> startsAt = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? jsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (jsonPropertyName)
                    {
                        case "amount":
                            amount = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "endsAt":
                            endsAt = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "frequency":
                            string? frequencyRawValue = utf8JsonReader.GetString();
                            frequency = new Option<Mandate.FrequencyEnum?>(Mandate.FrequencyEnum.FromStringOrDefault(frequencyRawValue));
                            break;
                        case "amountRule":
                            string? amountRuleRawValue = utf8JsonReader.GetString();
                            amountRule = new Option<Mandate.AmountRuleEnum?>(Mandate.AmountRuleEnum.FromStringOrDefault(amountRuleRawValue));
                            break;
                        case "billingAttemptsRule":
                            string? billingAttemptsRuleRawValue = utf8JsonReader.GetString();
                            billingAttemptsRule = new Option<Mandate.BillingAttemptsRuleEnum?>(Mandate.BillingAttemptsRuleEnum.FromStringOrDefault(billingAttemptsRuleRawValue));
                            break;
                        case "billingDay":
                            billingDay = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "count":
                            count = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "remarks":
                            remarks = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "startsAt":
                            startsAt = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        default:
                            break;
                    }
                }
            }
            
            if (!amount.IsSet)
                throw new ArgumentException("Property is required for class Mandate.", nameof(amount));

            if (!endsAt.IsSet)
                throw new ArgumentException("Property is required for class Mandate.", nameof(endsAt));

            if (!frequency.IsSet)
                throw new ArgumentException("Property is required for class Mandate.", nameof(frequency));

            return new Mandate(amount.Value!, endsAt.Value!, frequency.Value!.Value!, amountRule, billingAttemptsRule, billingDay, count, remarks, startsAt);
        }

        /// <summary>
        /// Serializes a <see cref="Mandate"/>.
        /// </summary>
        /// <param name="writer"><see cref="Utf8JsonWriter"/></param>
        /// <param name="mandate"></param>
        /// <param name="jsonSerializerOptions"><see cref="JsonSerializerOptions"/></param>
        public override void Write(Utf8JsonWriter writer, Mandate mandate, JsonSerializerOptions jsonSerializerOptions)
        {
            
            writer.WriteStartObject();
            
            WriteProperties(writer, mandate, jsonSerializerOptions);
            
            writer.WriteEndObject();
            
        }

        /// <summary>
        /// Serializes the properties of <see cref="Mandate"/>.
        /// </summary>
        /// <param name="writer"><see cref="Utf8JsonWriter"/></param>
        /// <param name="mandate"></param>
        /// <param name="jsonSerializerOptions"><see cref="JsonSerializerOptions"/></param>
        public void WriteProperties(Utf8JsonWriter writer, Mandate mandate, JsonSerializerOptions jsonSerializerOptions)
        {
            
            if (mandate.Amount != null)
                writer.WriteString("amount", mandate.Amount);

            if (mandate.EndsAt != null)
                writer.WriteString("endsAt", mandate.EndsAt);

            if (mandate.Frequency != null) 
            {
                string? frequencyRawValue = Mandate.FrequencyEnum.ToJsonValue(mandate.Frequency);
                writer.WriteString("frequency", frequencyRawValue);
            }
            
            if (mandate._AmountRuleOption.IsSet && mandate.AmountRule != null) 
            {
                string? amountRuleRawValue = Mandate.AmountRuleEnum.ToJsonValue(mandate._AmountRuleOption.Value!.Value);
                writer.WriteString("amountRule", amountRuleRawValue);
            }
            
            if (mandate._BillingAttemptsRuleOption.IsSet && mandate.BillingAttemptsRule != null) 
            {
                string? billingAttemptsRuleRawValue = Mandate.BillingAttemptsRuleEnum.ToJsonValue(mandate._BillingAttemptsRuleOption.Value!.Value);
                writer.WriteString("billingAttemptsRule", billingAttemptsRuleRawValue);
            }
            
            if (mandate._BillingDayOption.IsSet)
                if (mandate.BillingDay != null)
                    writer.WriteString("billingDay", mandate.BillingDay);

            if (mandate._CountOption.IsSet)
                if (mandate.Count != null)
                    writer.WriteString("count", mandate.Count);

            if (mandate._RemarksOption.IsSet)
                if (mandate.Remarks != null)
                    writer.WriteString("remarks", mandate.Remarks);

            if (mandate._StartsAtOption.IsSet)
                if (mandate.StartsAt != null)
                    writer.WriteString("startsAt", mandate.StartsAt);
        }
    }
}
