// <auto-generated>
/*
 * Transfer webhooks
 *
 * Adyen sends webhooks to inform your system about incoming and outgoing transfers in your platform.  You can use these webhooks to build your implementation. For example, you can use this information to update balances in your own dashboards or to keep track of incoming funds.
 *
 * The version of the OpenAPI document: 4
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using Adyen.Core;
using Adyen.TransferWebhooks.Client;

namespace Adyen.TransferWebhooks.Models
{
    /// <summary>
    /// IssuedCard.
    /// </summary>
    public partial class IssuedCard : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="IssuedCard" /> class.
        /// </summary>
        /// <param name="authorisationType">The authorisation type. For example, **defaultAuthorisation**, **preAuthorisation**, **finalAuthorisation**</param>
        /// <param name="panEntryMode">Indicates the method used for entering the PAN to initiate a transaction.  Possible values: **manual**, **chip**, **magstripe**, **contactless**, **cof**, **ecommerce**, **token**.</param>
        /// <param name="processingType">Contains information about how the payment was processed. For example, **ecommerce** for online or **pos** for in-person payments.</param>
        /// <param name="relayedAuthorisationData">relayedAuthorisationData</param>
        /// <param name="schemeTraceId">The identifier of the original payment. This ID is provided by the scheme and can be alphanumeric or numeric, depending on the scheme. The &#x60;schemeTraceID&#x60; should refer to an original &#x60;schemeUniqueTransactionID&#x60; provided in an earlier payment (not necessarily processed by Adyen). A &#x60;schemeTraceId&#x60; is typically available for authorization adjustments or recurring payments.</param>
        /// <param name="schemeUniqueTransactionId">The unique identifier created by the scheme. This ID can be alphanumeric or numeric depending on the scheme.</param>
        /// <param name="threeDSecure">threeDSecure</param>
        /// <param name="type">**issuedCard** (default to TypeEnum.IssuedCard)</param>
        /// <param name="validationFacts">The evaluation of the validation facts. See [validation checks](https://docs.adyen.com/issuing/validation-checks) for more information.</param>
        [JsonConstructor]
        public IssuedCard(Option<string?> authorisationType = default, Option<PanEntryModeEnum?> panEntryMode = default, Option<ProcessingTypeEnum?> processingType = default, Option<RelayedAuthorisationData?> relayedAuthorisationData = default, Option<string?> schemeTraceId = default, Option<string?> schemeUniqueTransactionId = default, Option<ThreeDSecure?> threeDSecure = default, Option<TypeEnum?> type = default, Option<List<TransferNotificationValidationFact>?> validationFacts = default)
        {
            _AuthorisationTypeOption = authorisationType;
            _PanEntryModeOption = panEntryMode;
            _ProcessingTypeOption = processingType;
            _RelayedAuthorisationDataOption = relayedAuthorisationData;
            _SchemeTraceIdOption = schemeTraceId;
            _SchemeUniqueTransactionIdOption = schemeUniqueTransactionId;
            _ThreeDSecureOption = threeDSecure;
            _TypeOption = type;
            _ValidationFactsOption = validationFacts;
            OnCreated();
        }
        
        /// <summary>
        /// Best practice: Use the parameterized constructor above to initialize your objects to understand which parameters are required.
        /// </summary>
        public IssuedCard()
        {
        }

        partial void OnCreated();

        /// <summary>
        /// Indicates the method used for entering the PAN to initiate a transaction.  Possible values: **manual**, **chip**, **magstripe**, **contactless**, **cof**, **ecommerce**, **token**.
        /// </summary>
        /// <value>Indicates the method used for entering the PAN to initiate a transaction.  Possible values: **manual**, **chip**, **magstripe**, **contactless**, **cof**, **ecommerce**, **token**.</value>
        [JsonConverter(typeof(PanEntryModeEnumJsonConverter))]
        public class PanEntryModeEnum : IEnum
        {
            /// <summary>
            /// Returns the value of the PanEntryModeEnum.
            /// </summary>
            public string? Value { get; set; }

            /// <summary>
            /// PanEntryModeEnum.Chip - chip
            /// </summary>
            public static readonly PanEntryModeEnum Chip = new("chip");

            /// <summary>
            /// PanEntryModeEnum.Cof - cof
            /// </summary>
            public static readonly PanEntryModeEnum Cof = new("cof");

            /// <summary>
            /// PanEntryModeEnum.Contactless - contactless
            /// </summary>
            public static readonly PanEntryModeEnum Contactless = new("contactless");

            /// <summary>
            /// PanEntryModeEnum.Ecommerce - ecommerce
            /// </summary>
            public static readonly PanEntryModeEnum Ecommerce = new("ecommerce");

            /// <summary>
            /// PanEntryModeEnum.Magstripe - magstripe
            /// </summary>
            public static readonly PanEntryModeEnum Magstripe = new("magstripe");

            /// <summary>
            /// PanEntryModeEnum.Manual - manual
            /// </summary>
            public static readonly PanEntryModeEnum Manual = new("manual");

            /// <summary>
            /// PanEntryModeEnum.Token - token
            /// </summary>
            public static readonly PanEntryModeEnum Token = new("token");
        
            private PanEntryModeEnum(string? value)
            {
                Value = value;
            }

            /// <summary>
            /// Converts a string to a <see cref="PanEntryModeEnum"/> implicitly.
            /// </summary>
            /// <param name="value">The string value to convert. Defaults to null.</param>
            /// <returns>A new <see cref="PanEntryModeEnum"/> instance initialized with the string value.</returns>
            public static implicit operator PanEntryModeEnum?(string? value) => value == null ? null : new PanEntryModeEnum(value);
    
            /// <summary>
            /// Converts a <see cref="PanEntryModeEnum"/> instance to a string implicitly.
            /// </summary>
            /// <param name="option">The <see cref="PanEntryModeEnum"/> instance. Default to null.</param>
            /// <returns>String value of the <see cref="PanEntryModeEnum"/> instance./// </returns>
            public static implicit operator string?(PanEntryModeEnum? option) => option?.Value;
        
            public static bool operator ==(PanEntryModeEnum? left, PanEntryModeEnum? right) => string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);
    
            public static bool operator !=(PanEntryModeEnum? left, PanEntryModeEnum? right) => !string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);

            public override bool Equals(object? obj) => obj is PanEntryModeEnum other && string.Equals(Value, other.Value, StringComparison.OrdinalIgnoreCase);
    
            public override int GetHashCode() => Value?.GetHashCode() ?? 0;
        
            public override string ToString() => Value ?? string.Empty;
        
            /// <summary>
            /// Returns a <see cref="PanEntryModeEnum?"/>.
            /// </summary>
            /// <param name="value"></param>
            /// <returns><see cref="PanEntryModeEnum"/> or null.</returns>
            public static PanEntryModeEnum? FromStringOrDefault(string value)
            {
                return value switch {
                    "chip" => PanEntryModeEnum.Chip,
                    "cof" => PanEntryModeEnum.Cof,
                    "contactless" => PanEntryModeEnum.Contactless,
                    "ecommerce" => PanEntryModeEnum.Ecommerce,
                    "magstripe" => PanEntryModeEnum.Magstripe,
                    "manual" => PanEntryModeEnum.Manual,
                    "token" => PanEntryModeEnum.Token,
                    _ => null,
                };
            }
    
            /// <summary>
            /// Converts the <see cref="PanEntryModeEnum"/> to the json value.
            /// </summary>
            /// <param name="value"><see cref="PanEntryModeEnum"/></param>
            /// <returns>String value of the enum.</returns>
            /// <exception cref="NotImplementedException"></exception>
            public static string? ToJsonValue(PanEntryModeEnum? value)
            {
                if (value == null)
                    return null;
            
                if (value == PanEntryModeEnum.Chip)
                    return "chip";
                
                if (value == PanEntryModeEnum.Cof)
                    return "cof";
                
                if (value == PanEntryModeEnum.Contactless)
                    return "contactless";
                
                if (value == PanEntryModeEnum.Ecommerce)
                    return "ecommerce";
                
                if (value == PanEntryModeEnum.Magstripe)
                    return "magstripe";
                
                if (value == PanEntryModeEnum.Manual)
                    return "manual";
                
                if (value == PanEntryModeEnum.Token)
                    return "token";
                
                return null;
            }
            
            /// <summary>
            /// JsonConverter for writing PanEntryModeEnum.               
            /// </summary>
            public class PanEntryModeEnumJsonConverter : JsonConverter<PanEntryModeEnum>
            {
                public override PanEntryModeEnum? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions jsonOptions)
                {
                    string value = reader.GetString();
                    return value == null ? null : PanEntryModeEnum.FromStringOrDefault(value) ?? new PanEntryModeEnum(value);
                }

                public override void Write(Utf8JsonWriter writer, PanEntryModeEnum value, JsonSerializerOptions jsonOptions)
                {
                    writer.WriteStringValue(PanEntryModeEnum.ToJsonValue(value));
                }
            }
        }

         /// <summary>
        /// Used to track if an optional field is set. If set, <see cref="PanEntryMode"/> will be populated.
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<PanEntryModeEnum?> _PanEntryModeOption { get; private set; }

        /// <summary>
        /// Indicates the method used for entering the PAN to initiate a transaction.  Possible values: **manual**, **chip**, **magstripe**, **contactless**, **cof**, **ecommerce**, **token**.
        /// </summary>
        /// <value>Indicates the method used for entering the PAN to initiate a transaction.  Possible values: **manual**, **chip**, **magstripe**, **contactless**, **cof**, **ecommerce**, **token**.</value>
        [JsonPropertyName("panEntryMode")]
        public PanEntryModeEnum? PanEntryMode { get { return this._PanEntryModeOption; } set { this._PanEntryModeOption = new(value); } }

        /// <summary>
        /// Contains information about how the payment was processed. For example, **ecommerce** for online or **pos** for in-person payments.
        /// </summary>
        /// <value>Contains information about how the payment was processed. For example, **ecommerce** for online or **pos** for in-person payments.</value>
        [JsonConverter(typeof(ProcessingTypeEnumJsonConverter))]
        public class ProcessingTypeEnum : IEnum
        {
            /// <summary>
            /// Returns the value of the ProcessingTypeEnum.
            /// </summary>
            public string? Value { get; set; }

            /// <summary>
            /// ProcessingTypeEnum.AtmWithdraw - atmWithdraw
            /// </summary>
            public static readonly ProcessingTypeEnum AtmWithdraw = new("atmWithdraw");

            /// <summary>
            /// ProcessingTypeEnum.BalanceInquiry - balanceInquiry
            /// </summary>
            public static readonly ProcessingTypeEnum BalanceInquiry = new("balanceInquiry");

            /// <summary>
            /// ProcessingTypeEnum.Ecommerce - ecommerce
            /// </summary>
            public static readonly ProcessingTypeEnum Ecommerce = new("ecommerce");

            /// <summary>
            /// ProcessingTypeEnum.Moto - moto
            /// </summary>
            public static readonly ProcessingTypeEnum Moto = new("moto");

            /// <summary>
            /// ProcessingTypeEnum.Pos - pos
            /// </summary>
            public static readonly ProcessingTypeEnum Pos = new("pos");

            /// <summary>
            /// ProcessingTypeEnum.PurchaseWithCashback - purchaseWithCashback
            /// </summary>
            public static readonly ProcessingTypeEnum PurchaseWithCashback = new("purchaseWithCashback");

            /// <summary>
            /// ProcessingTypeEnum.Recurring - recurring
            /// </summary>
            public static readonly ProcessingTypeEnum Recurring = new("recurring");

            /// <summary>
            /// ProcessingTypeEnum.Token - token
            /// </summary>
            public static readonly ProcessingTypeEnum Token = new("token");
        
            private ProcessingTypeEnum(string? value)
            {
                Value = value;
            }

            /// <summary>
            /// Converts a string to a <see cref="ProcessingTypeEnum"/> implicitly.
            /// </summary>
            /// <param name="value">The string value to convert. Defaults to null.</param>
            /// <returns>A new <see cref="ProcessingTypeEnum"/> instance initialized with the string value.</returns>
            public static implicit operator ProcessingTypeEnum?(string? value) => value == null ? null : new ProcessingTypeEnum(value);
    
            /// <summary>
            /// Converts a <see cref="ProcessingTypeEnum"/> instance to a string implicitly.
            /// </summary>
            /// <param name="option">The <see cref="ProcessingTypeEnum"/> instance. Default to null.</param>
            /// <returns>String value of the <see cref="ProcessingTypeEnum"/> instance./// </returns>
            public static implicit operator string?(ProcessingTypeEnum? option) => option?.Value;
        
            public static bool operator ==(ProcessingTypeEnum? left, ProcessingTypeEnum? right) => string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);
    
            public static bool operator !=(ProcessingTypeEnum? left, ProcessingTypeEnum? right) => !string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);

            public override bool Equals(object? obj) => obj is ProcessingTypeEnum other && string.Equals(Value, other.Value, StringComparison.OrdinalIgnoreCase);
    
            public override int GetHashCode() => Value?.GetHashCode() ?? 0;
        
            public override string ToString() => Value ?? string.Empty;
        
            /// <summary>
            /// Returns a <see cref="ProcessingTypeEnum?"/>.
            /// </summary>
            /// <param name="value"></param>
            /// <returns><see cref="ProcessingTypeEnum"/> or null.</returns>
            public static ProcessingTypeEnum? FromStringOrDefault(string value)
            {
                return value switch {
                    "atmWithdraw" => ProcessingTypeEnum.AtmWithdraw,
                    "balanceInquiry" => ProcessingTypeEnum.BalanceInquiry,
                    "ecommerce" => ProcessingTypeEnum.Ecommerce,
                    "moto" => ProcessingTypeEnum.Moto,
                    "pos" => ProcessingTypeEnum.Pos,
                    "purchaseWithCashback" => ProcessingTypeEnum.PurchaseWithCashback,
                    "recurring" => ProcessingTypeEnum.Recurring,
                    "token" => ProcessingTypeEnum.Token,
                    _ => null,
                };
            }
    
            /// <summary>
            /// Converts the <see cref="ProcessingTypeEnum"/> to the json value.
            /// </summary>
            /// <param name="value"><see cref="ProcessingTypeEnum"/></param>
            /// <returns>String value of the enum.</returns>
            /// <exception cref="NotImplementedException"></exception>
            public static string? ToJsonValue(ProcessingTypeEnum? value)
            {
                if (value == null)
                    return null;
            
                if (value == ProcessingTypeEnum.AtmWithdraw)
                    return "atmWithdraw";
                
                if (value == ProcessingTypeEnum.BalanceInquiry)
                    return "balanceInquiry";
                
                if (value == ProcessingTypeEnum.Ecommerce)
                    return "ecommerce";
                
                if (value == ProcessingTypeEnum.Moto)
                    return "moto";
                
                if (value == ProcessingTypeEnum.Pos)
                    return "pos";
                
                if (value == ProcessingTypeEnum.PurchaseWithCashback)
                    return "purchaseWithCashback";
                
                if (value == ProcessingTypeEnum.Recurring)
                    return "recurring";
                
                if (value == ProcessingTypeEnum.Token)
                    return "token";
                
                return null;
            }
            
            /// <summary>
            /// JsonConverter for writing ProcessingTypeEnum.               
            /// </summary>
            public class ProcessingTypeEnumJsonConverter : JsonConverter<ProcessingTypeEnum>
            {
                public override ProcessingTypeEnum? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions jsonOptions)
                {
                    string value = reader.GetString();
                    return value == null ? null : ProcessingTypeEnum.FromStringOrDefault(value) ?? new ProcessingTypeEnum(value);
                }

                public override void Write(Utf8JsonWriter writer, ProcessingTypeEnum value, JsonSerializerOptions jsonOptions)
                {
                    writer.WriteStringValue(ProcessingTypeEnum.ToJsonValue(value));
                }
            }
        }

         /// <summary>
        /// Used to track if an optional field is set. If set, <see cref="ProcessingType"/> will be populated.
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<ProcessingTypeEnum?> _ProcessingTypeOption { get; private set; }

        /// <summary>
        /// Contains information about how the payment was processed. For example, **ecommerce** for online or **pos** for in-person payments.
        /// </summary>
        /// <value>Contains information about how the payment was processed. For example, **ecommerce** for online or **pos** for in-person payments.</value>
        [JsonPropertyName("processingType")]
        public ProcessingTypeEnum? ProcessingType { get { return this._ProcessingTypeOption; } set { this._ProcessingTypeOption = new(value); } }

        /// <summary>
        /// **issuedCard**
        /// </summary>
        /// <value>**issuedCard**</value>
        [JsonConverter(typeof(TypeEnumJsonConverter))]
        public class TypeEnum : IEnum
        {
            /// <summary>
            /// Returns the value of the TypeEnum.
            /// </summary>
            public string? Value { get; set; }

            /// <summary>
            /// TypeEnum.IssuedCard - issuedCard
            /// </summary>
            public static readonly TypeEnum IssuedCard = new("issuedCard");
        
            private TypeEnum(string? value)
            {
                Value = value;
            }

            /// <summary>
            /// Converts a string to a <see cref="TypeEnum"/> implicitly.
            /// </summary>
            /// <param name="value">The string value to convert. Defaults to null.</param>
            /// <returns>A new <see cref="TypeEnum"/> instance initialized with the string value.</returns>
            public static implicit operator TypeEnum?(string? value) => value == null ? null : new TypeEnum(value);
    
            /// <summary>
            /// Converts a <see cref="TypeEnum"/> instance to a string implicitly.
            /// </summary>
            /// <param name="option">The <see cref="TypeEnum"/> instance. Default to null.</param>
            /// <returns>String value of the <see cref="TypeEnum"/> instance./// </returns>
            public static implicit operator string?(TypeEnum? option) => option?.Value;
        
            public static bool operator ==(TypeEnum? left, TypeEnum? right) => string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);
    
            public static bool operator !=(TypeEnum? left, TypeEnum? right) => !string.Equals(left?.Value, right?.Value, StringComparison.OrdinalIgnoreCase);

            public override bool Equals(object? obj) => obj is TypeEnum other && string.Equals(Value, other.Value, StringComparison.OrdinalIgnoreCase);
    
            public override int GetHashCode() => Value?.GetHashCode() ?? 0;
        
            public override string ToString() => Value ?? string.Empty;
        
            /// <summary>
            /// Returns a <see cref="TypeEnum?"/>.
            /// </summary>
            /// <param name="value"></param>
            /// <returns><see cref="TypeEnum"/> or null.</returns>
            public static TypeEnum? FromStringOrDefault(string value)
            {
                return value switch {
                    "issuedCard" => TypeEnum.IssuedCard,
                    _ => null,
                };
            }
    
            /// <summary>
            /// Converts the <see cref="TypeEnum"/> to the json value.
            /// </summary>
            /// <param name="value"><see cref="TypeEnum"/></param>
            /// <returns>String value of the enum.</returns>
            /// <exception cref="NotImplementedException"></exception>
            public static string? ToJsonValue(TypeEnum? value)
            {
                if (value == null)
                    return null;
            
                if (value == TypeEnum.IssuedCard)
                    return "issuedCard";
                
                return null;
            }
            
            /// <summary>
            /// JsonConverter for writing TypeEnum.               
            /// </summary>
            public class TypeEnumJsonConverter : JsonConverter<TypeEnum>
            {
                public override TypeEnum? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions jsonOptions)
                {
                    string value = reader.GetString();
                    return value == null ? null : TypeEnum.FromStringOrDefault(value) ?? new TypeEnum(value);
                }

                public override void Write(Utf8JsonWriter writer, TypeEnum value, JsonSerializerOptions jsonOptions)
                {
                    writer.WriteStringValue(TypeEnum.ToJsonValue(value));
                }
            }
        }

         /// <summary>
        /// Used to track if an optional field is set. If set, <see cref="Type"/> will be populated.
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<TypeEnum?> _TypeOption { get; private set; }

        /// <summary>
        /// **issuedCard**
        /// </summary>
        /// <value>**issuedCard**</value>
        [JsonPropertyName("type")]
        public TypeEnum? Type { get { return this._TypeOption; } set { this._TypeOption = new(value); } }

        /// <summary>
        /// Used to track the state of AuthorisationType
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> _AuthorisationTypeOption { get; private set; }

        /// <summary>
        /// The authorisation type. For example, **defaultAuthorisation**, **preAuthorisation**, **finalAuthorisation**
        /// </summary>
        /// <value>The authorisation type. For example, **defaultAuthorisation**, **preAuthorisation**, **finalAuthorisation**</value>
        [JsonPropertyName("authorisationType")]
        public string? AuthorisationType { get { return this._AuthorisationTypeOption; } set { this._AuthorisationTypeOption = new(value); } }

        /// <summary>
        /// Used to track the state of RelayedAuthorisationData
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<RelayedAuthorisationData?> _RelayedAuthorisationDataOption { get; private set; }

        /// <summary>
        /// Gets or Sets RelayedAuthorisationData
        /// </summary>
        [JsonPropertyName("relayedAuthorisationData")]
        public RelayedAuthorisationData? RelayedAuthorisationData { get { return this._RelayedAuthorisationDataOption; } set { this._RelayedAuthorisationDataOption = new(value); } }

        /// <summary>
        /// Used to track the state of SchemeTraceId
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> _SchemeTraceIdOption { get; private set; }

        /// <summary>
        /// The identifier of the original payment. This ID is provided by the scheme and can be alphanumeric or numeric, depending on the scheme. The &#x60;schemeTraceID&#x60; should refer to an original &#x60;schemeUniqueTransactionID&#x60; provided in an earlier payment (not necessarily processed by Adyen). A &#x60;schemeTraceId&#x60; is typically available for authorization adjustments or recurring payments.
        /// </summary>
        /// <value>The identifier of the original payment. This ID is provided by the scheme and can be alphanumeric or numeric, depending on the scheme. The &#x60;schemeTraceID&#x60; should refer to an original &#x60;schemeUniqueTransactionID&#x60; provided in an earlier payment (not necessarily processed by Adyen). A &#x60;schemeTraceId&#x60; is typically available for authorization adjustments or recurring payments.</value>
        [JsonPropertyName("schemeTraceId")]
        public string? SchemeTraceId { get { return this._SchemeTraceIdOption; } set { this._SchemeTraceIdOption = new(value); } }

        /// <summary>
        /// Used to track the state of SchemeUniqueTransactionId
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> _SchemeUniqueTransactionIdOption { get; private set; }

        /// <summary>
        /// The unique identifier created by the scheme. This ID can be alphanumeric or numeric depending on the scheme.
        /// </summary>
        /// <value>The unique identifier created by the scheme. This ID can be alphanumeric or numeric depending on the scheme.</value>
        [JsonPropertyName("schemeUniqueTransactionId")]
        public string? SchemeUniqueTransactionId { get { return this._SchemeUniqueTransactionIdOption; } set { this._SchemeUniqueTransactionIdOption = new(value); } }

        /// <summary>
        /// Used to track the state of ThreeDSecure
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<ThreeDSecure?> _ThreeDSecureOption { get; private set; }

        /// <summary>
        /// Gets or Sets ThreeDSecure
        /// </summary>
        [JsonPropertyName("threeDSecure")]
        public ThreeDSecure? ThreeDSecure { get { return this._ThreeDSecureOption; } set { this._ThreeDSecureOption = new(value); } }

        /// <summary>
        /// Used to track the state of ValidationFacts
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<TransferNotificationValidationFact>?> _ValidationFactsOption { get; private set; }

        /// <summary>
        /// The evaluation of the validation facts. See [validation checks](https://docs.adyen.com/issuing/validation-checks) for more information.
        /// </summary>
        /// <value>The evaluation of the validation facts. See [validation checks](https://docs.adyen.com/issuing/validation-checks) for more information.</value>
        [JsonPropertyName("validationFacts")]
        public List<TransferNotificationValidationFact>? ValidationFacts { get { return this._ValidationFactsOption; } set { this._ValidationFactsOption = new(value); } }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class IssuedCard {\n");
            sb.Append("  AuthorisationType: ").Append(AuthorisationType).Append("\n");
            sb.Append("  PanEntryMode: ").Append(PanEntryMode).Append("\n");
            sb.Append("  ProcessingType: ").Append(ProcessingType).Append("\n");
            sb.Append("  RelayedAuthorisationData: ").Append(RelayedAuthorisationData).Append("\n");
            sb.Append("  SchemeTraceId: ").Append(SchemeTraceId).Append("\n");
            sb.Append("  SchemeUniqueTransactionId: ").Append(SchemeUniqueTransactionId).Append("\n");
            sb.Append("  ThreeDSecure: ").Append(ThreeDSecure).Append("\n");
            sb.Append("  Type: ").Append(Type).Append("\n");
            sb.Append("  ValidationFacts: ").Append(ValidationFacts).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="IssuedCard" />
    /// </summary>
    public class IssuedCardJsonConverter : JsonConverter<IssuedCard>
    {
        /// <summary>
        /// Deserializes json to <see cref="IssuedCard"/>.
        /// </summary>
        /// <param name="utf8JsonReader"><see cref="Utf8JsonReader"/>.</param>
        /// <param name="typeToConvert"><see cref="Type"/>.</param>
        /// <param name="jsonSerializerOptions">The <see cref="JsonSerializerOptions"/>, initialized from <see cref="HostConfiguration"/>.</param>
        /// <returns><see cref="IssuedCard"/>.</returns>
        /// <exception cref="JsonException"></exception>
        public override IssuedCard Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<string?> authorisationType = default;
            Option<IssuedCard.PanEntryModeEnum?> panEntryMode = default;
            Option<IssuedCard.ProcessingTypeEnum?> processingType = default;
            Option<RelayedAuthorisationData?> relayedAuthorisationData = default;
            Option<string?> schemeTraceId = default;
            Option<string?> schemeUniqueTransactionId = default;
            Option<ThreeDSecure?> threeDSecure = default;
            Option<IssuedCard.TypeEnum?> type = default;
            Option<List<TransferNotificationValidationFact>?> validationFacts = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? jsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (jsonPropertyName)
                    {
                        case "authorisationType":
                            authorisationType = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "panEntryMode":
                            string? panEntryModeRawValue = utf8JsonReader.GetString();
                            panEntryMode = new Option<IssuedCard.PanEntryModeEnum?>(IssuedCard.PanEntryModeEnum.FromStringOrDefault(panEntryModeRawValue));
                            break;
                        case "processingType":
                            string? processingTypeRawValue = utf8JsonReader.GetString();
                            processingType = new Option<IssuedCard.ProcessingTypeEnum?>(IssuedCard.ProcessingTypeEnum.FromStringOrDefault(processingTypeRawValue));
                            break;
                        case "relayedAuthorisationData":
                            relayedAuthorisationData = new Option<RelayedAuthorisationData?>(JsonSerializer.Deserialize<RelayedAuthorisationData>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "schemeTraceId":
                            schemeTraceId = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "schemeUniqueTransactionId":
                            schemeUniqueTransactionId = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "threeDSecure":
                            threeDSecure = new Option<ThreeDSecure?>(JsonSerializer.Deserialize<ThreeDSecure>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "type":
                            string? typeRawValue = utf8JsonReader.GetString();
                            type = new Option<IssuedCard.TypeEnum?>(IssuedCard.TypeEnum.FromStringOrDefault(typeRawValue));
                            break;
                        case "validationFacts":
                            validationFacts = new Option<List<TransferNotificationValidationFact>?>(JsonSerializer.Deserialize<List<TransferNotificationValidationFact>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        default:
                            break;
                    }
                }
            }
            

            return new IssuedCard(authorisationType, panEntryMode, processingType, relayedAuthorisationData, schemeTraceId, schemeUniqueTransactionId, threeDSecure, type, validationFacts);
        }

        /// <summary>
        /// Serializes a <see cref="IssuedCard"/>.
        /// </summary>
        /// <param name="writer"><see cref="Utf8JsonWriter"/></param>
        /// <param name="issuedCard"></param>
        /// <param name="jsonSerializerOptions"><see cref="JsonSerializerOptions"/></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, IssuedCard issuedCard, JsonSerializerOptions jsonSerializerOptions)
        {
            
            writer.WriteStartObject();
            
            WriteProperties(writer, issuedCard, jsonSerializerOptions);
            
            writer.WriteEndObject();
            
        }

        /// <summary>
        /// Serializes the properties of <see cref="IssuedCard"/>.
        /// </summary>
        /// <param name="writer"><see creft="Utf8JsonWriter"/></param>
        /// <param name="issuedCard"></param>
        /// <param name="jsonSerializerOptions"><see cref="JsonSerializerOptions"/></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, IssuedCard issuedCard, JsonSerializerOptions jsonSerializerOptions)
        {
            
            if (issuedCard._AuthorisationTypeOption.IsSet)
                if (issuedCard.AuthorisationType != null)
                    writer.WriteString("authorisationType", issuedCard.AuthorisationType);

            if (issuedCard._PanEntryModeOption.IsSet && issuedCard.PanEntryMode != null) 
            {
                string? panEntryModeRawValue = IssuedCard.PanEntryModeEnum.ToJsonValue(issuedCard._PanEntryModeOption.Value!.Value);
                writer.WriteString("panEntryMode", panEntryModeRawValue);
            }
            
            if (issuedCard._ProcessingTypeOption.IsSet && issuedCard.ProcessingType != null) 
            {
                string? processingTypeRawValue = IssuedCard.ProcessingTypeEnum.ToJsonValue(issuedCard._ProcessingTypeOption.Value!.Value);
                writer.WriteString("processingType", processingTypeRawValue);
            }
            
            if (issuedCard._RelayedAuthorisationDataOption.IsSet)
            {
                writer.WritePropertyName("relayedAuthorisationData");
                JsonSerializer.Serialize(writer, issuedCard.RelayedAuthorisationData, jsonSerializerOptions);
            }
            if (issuedCard._SchemeTraceIdOption.IsSet)
                if (issuedCard.SchemeTraceId != null)
                    writer.WriteString("schemeTraceId", issuedCard.SchemeTraceId);

            if (issuedCard._SchemeUniqueTransactionIdOption.IsSet)
                if (issuedCard.SchemeUniqueTransactionId != null)
                    writer.WriteString("schemeUniqueTransactionId", issuedCard.SchemeUniqueTransactionId);

            if (issuedCard._ThreeDSecureOption.IsSet)
            {
                writer.WritePropertyName("threeDSecure");
                JsonSerializer.Serialize(writer, issuedCard.ThreeDSecure, jsonSerializerOptions);
            }
            if (issuedCard._TypeOption.IsSet && issuedCard.Type != null) 
            {
                string? typeRawValue = IssuedCard.TypeEnum.ToJsonValue(issuedCard._TypeOption.Value!.Value);
                writer.WriteString("type", typeRawValue);
            }
            
            if (issuedCard._ValidationFactsOption.IsSet)
            {
                writer.WritePropertyName("validationFacts");
                JsonSerializer.Serialize(writer, issuedCard.ValidationFacts, jsonSerializerOptions);
            }
        }
    }
}
